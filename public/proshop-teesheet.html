<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MyCaddy Pro ‚Ä¢ Tee Sheet</title>
  <style>
    :root {
      --bg: #f8fafc;
      --card: #fff;
      --ink: #1e293b;
      --muted: #64748b;
      --brand: #3b82f6;
      --border: #e2e8f0;
      --course-a: #dcfce7;
      --course-a-header: #86efac;
      --course-b: #dbeafe;
      --course-b-header: #93c5fd;
      --course-c: #fef3c7;
      --course-c-header: #fcd34d;
      --course-d: #f3e8ff;
      --course-d-header: #99f6e4;
      --regular: #dcfce7;
      --vip: #fef3c7;
      --society: #dbeafe;
      --tournament: #fce7f3;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--ink);
      height: 100vh;
      overflow: hidden;
    }

    /* Full-Screen Container */
    .teesheet-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* Top Header Bar (dark) */
    .top-header-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      background: linear-gradient(90deg, #166534 0%, #15803d 50%, #166534 100%);
      border-bottom: 2px solid #22c55e;
      flex-shrink: 0;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .logo-section {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .logo-section svg {
      width: 28px;
      height: 28px;
      fill: #22c55e;
    }
    .course-name-display {
      font-size: 18px;
      font-weight: 700;
      color: #fff;
    }
    .live-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(0,0,0,0.3);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
    }
    .live-dot {
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse-dot 1.5s infinite;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }
    .header-center {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .date-display-large {
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      background: rgba(0,0,0,0.3);
      padding: 6px 16px;
      border-radius: 8px;
      cursor: pointer;
    }
    .date-nav-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      color: #fff;
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      transition: background 0.15s;
    }
    .date-nav-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .current-time-display {
      font-size: 24px;
      font-weight: 700;
      color: #22c55e;
      font-variant-numeric: tabular-nums;
    }
    .header-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      text-decoration: none;
    }
    .header-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    .header-btn.primary {
      background: #22c55e;
      border-color: #22c55e;
    }
    .header-btn.primary:hover {
      background: #16a34a;
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      overflow: auto;
      padding: 12px;
    }

    /* Header Row - now inside main content */
    .header-row {
      display: none; /* Hide old header, replaced by top-header-bar */
    }
    .language-select {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }
    .language-select svg {
      width: 16px;
      height: 16px;
    }
    .language-select select {
      padding: 8px 32px 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2364748b' d='M2 4l4 4 4-4'/%3E%3C/svg%3E") no-repeat right 12px center;
      appearance: none;
      font-size: 14px;
      cursor: pointer;
    }

    /* Controls Row */
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-end;
      margin-bottom: 16px;
      background: #fff;
      padding: 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .control-group label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .control-group input,
    .control-group select {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      background: #fff;
      min-width: 120px;
    }
    .control-group input:focus,
    .control-group select:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Date Control */
    .date-control {
      display: flex;
      align-items: center;
      gap: 0;
    }
    .date-control button {
      width: 40px;
      height: 42px;
      border: 1px solid var(--border);
      background: var(--ink);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
    .date-control button:first-child {
      border-radius: 8px 0 0 8px;
    }
    .date-control button:last-child {
      border-radius: 0 8px 8px 0;
    }
    .date-control input[type="date"] {
      border-radius: 0;
      border-left: none;
      border-right: none;
      min-width: 140px;
    }

    /* Search */
    .search-group {
      flex: 1;
      min-width: 200px;
    }
    .search-group input {
      width: 100%;
    }

    /* Buttons */
    .btn {
      padding: 10px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      background: #fff;
      color: var(--ink);
      transition: all 0.15s;
    }
    .btn:hover {
      background: #f8fafc;
    }
    .btn-clear {
      background: #fff;
      color: #ef4444;
      border-color: #fecaca;
    }
    .btn-clear:hover {
      background: #fef2f2;
    }
    .btn-primary {
      background: var(--brand);
      color: #fff;
      border-color: var(--brand);
    }
    .btn-primary:hover {
      background: #2563eb;
    }

    /* Legend Row */
    .legend-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .course-legend,
    .type-legend {
      display: flex;
      gap: 16px;
      align-items: center;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    .legend-dot {
      width: 14px;
      height: 14px;
      border-radius: 4px;
    }
    .legend-dot.course-a { background: var(--course-a-header); }
    .legend-dot.course-b { background: var(--course-b-header); }
    .legend-dot.course-c { background: var(--course-c-header); }
    .legend-dot.course-d { background: var(--course-d-header); }
    .legend-dot.regular { background: var(--regular); border: 1px solid #86efac; }
    .legend-dot.vip { background: var(--vip); border: 1px solid #fcd34d; }
    .legend-dot.society { background: var(--society); border: 1px solid #93c5fd; }
    .legend-dot.tournament { background: var(--tournament); border: 1px solid #f9a8d4; }

    /* Tee Sheet Grid */
    .teesheet-grid {
      background: #fff;
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .grid-header {
      display: grid;
      grid-template-columns: 80px repeat(var(--cols), 1fr);
      background: #f8fafc;
      border-bottom: 2px solid var(--border);
    }
    .grid-header-cell {
      padding: 14px 8px;
      text-align: center;
      font-weight: 600;
      font-size: 14px;
      border-right: 1px solid var(--border);
    }
    .grid-header-cell:last-child {
      border-right: none;
    }
    .grid-header-cell.time-header {
      background: #fff;
      color: var(--ink);
    }
    .grid-header-cell.course-a { background: var(--course-a-header); color: #166534; }
    .grid-header-cell.course-b { background: var(--course-b-header); color: #1e40af; }
    .grid-header-cell.course-c { background: var(--course-c-header); color: #92400e; }
    .grid-header-cell.course-d { background: var(--course-d-header); color: #0f766e; }

    .grid-row {
      display: grid;
      grid-template-columns: 80px repeat(var(--cols), 1fr);
      border-bottom: 1px solid var(--border);
    }
    .grid-row:last-child {
      border-bottom: none;
    }
    .grid-row:hover {
      background: #fafbfc;
    }
    .time-cell {
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
      font-size: 13px;
      color: var(--ink);
      background: #fff;
      border-right: 1px solid var(--border);
      font-variant-numeric: tabular-nums;
    }
    .slot {
      padding: 4px;
      min-height: 52px;
      border-right: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }
    .slot:hover {
      background: #f1f5f9;
    }
    .slot.course-a { background: var(--course-a); }
    .slot.course-b { background: var(--course-b); }
    .slot.course-c { background: var(--course-c); }
    .slot.course-d { background: var(--course-d); }
    .slot.course-a:hover { background: #bbf7d0; }
    .slot.course-b:hover { background: #bfdbfe; }
    .slot.course-c:hover { background: #fde68a; }
    .slot.course-d:hover { background: #e9d5ff; }

    /* Booking Pills */
    .pill {
      position: relative;
      background: #fff;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 12px;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border-left: 3px solid #86efac;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
    }
    .pill:active {
      cursor: grabbing;
    }
    .pill.vip { border-left-color: #fcd34d; background: #fffbeb; }
    .pill.society { border-left-color: #93c5fd; background: #eff6ff; }
    .pill.tournament { border-left-color: #f9a8d4; background: #fdf2f8; }
    .pill.society:active, .pill.society[draggable="true"]:hover {
      cursor: grab;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }
    .pill.society:active::after {
      content: "‚ö° Will sync to society";
      position: absolute;
      bottom: -18px;
      left: 0;
      font-size: 9px;
      color: #3b82f6;
      white-space: nowrap;
    }
    .pill-name {
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 2px;
    }
    .pill-info {
      font-size: 11px;
      color: var(--muted);
    }

    /* Modal */
    dialog {
      border: none;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.2);
      padding: 0;
      max-width: 700px;
      width: 95%;
      margin: auto;
      max-height: 90vh;
      overflow: hidden;
    }
    dialog[open] {
      display: flex;
      flex-direction: column;
    }
    dialog::backdrop {
      background: rgba(0,0,0,0.5);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: #f8fafc;
      flex-shrink: 0;
    }
    .modal-header h2 {
      font-size: 16px;
      font-weight: 600;
    }
    .modal-close {
      width: 28px;
      height: 28px;
      border: none;
      background: none;
      font-size: 18px;
      cursor: pointer;
      color: var(--muted);
      border-radius: 6px;
    }
    .modal-close:hover {
      background: #e2e8f0;
    }
    .modal-body {
      padding: 16px;
      overflow-y: auto;
      flex: 1;
    }
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      background: #f8fafc;
      flex-shrink: 0;
    }

    /* Today Button */
    .date-control .today-btn {
      background: var(--brand);
      border: 1px solid var(--brand);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 4px;
      white-space: nowrap;
      width: auto;
      height: auto;
    }
    .today-btn:hover {
      background: #2563eb;
      transform: scale(1.05);
    }

    /* Calendar Navigator Button */
    .cal-nav-btn {
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 4px;
    }
    .cal-nav-btn:hover {
      background: #e2e8f0;
      transform: scale(1.05);
    }

    /* Calendar Navigator Modal */
    #calendar-navigator {
      width: 900px;
      max-width: 95vw;
      max-height: 90vh;
      padding: 0;
      border: none;
      border-radius: 12px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }
    #calendar-navigator::backdrop {
      background: rgba(0, 0, 0, 0.5);
    }
    .cal-nav-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #e5e7eb;
      background: #f8fafc;
    }
    .cal-nav-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cal-nav-title h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      min-width: 160px;
      text-align: center;
    }
    .cal-arrow {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .cal-arrow:hover {
      background: #f1f5f9;
    }
    .cal-nav-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .cal-nav-controls select {
      padding: 8px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
    }
    .cal-close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #6b7280;
      padding: 4px 8px;
    }
    .cal-close-btn:hover {
      color: #1f2937;
    }

    .cal-nav-body {
      display: flex;
      gap: 0;
      min-height: 450px;
    }
    .cal-nav-calendar {
      flex: 0 0 60%;
      padding: 16px;
      border-right: 1px solid #e5e7eb;
    }
    .cal-weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      text-align: center;
      font-size: 11px;
      font-weight: 600;
      color: #6b7280;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e5e7eb;
    }
    .cal-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
    }
    .cal-day {
      min-height: 65px;
      padding: 4px 6px;
      cursor: pointer;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      font-size: 12px;
      background: #fff;
      transition: all 0.15s;
      overflow: hidden;
    }
    .cal-day:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
    }
    .cal-day.today {
      border: 2px solid #3b82f6;
      background: #eff6ff;
    }
    .cal-day.selected {
      background: #dbeafe;
      border-color: #3b82f6;
    }
    .cal-day.other-month {
      opacity: 0.4;
    }
    .cal-day.has-bookings {
      background: #f0fdf4;
    }
    .cal-day-num {
      font-weight: 600;
      font-size: 13px;
      color: #1f2937;
      margin-bottom: 2px;
    }
    .cal-day-preview {
      font-size: 9px;
      color: #6b7280;
      line-height: 1.3;
      overflow: hidden;
      max-height: 36px;
    }
    .cal-day-preview .preview-item {
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 1px 0;
    }
    .cal-day-preview .preview-item.society { color: #2563eb; }
    .cal-day-preview .preview-item.vip { color: #d97706; }
    .cal-day-preview .preview-item.tournament { color: #db2777; }
    .cal-day-preview .more {
      color: #9ca3af;
      font-style: italic;
    }

    .cal-legend {
      display: flex;
      gap: 16px;
      justify-content: center;
      padding: 12px 0;
      margin-top: 12px;
      border-top: 1px solid #e5e7eb;
      font-size: 11px;
      color: #6b7280;
    }
    .cal-legend .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .cal-legend .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .cal-legend .dot.regular { background: #22c55e; }
    .cal-legend .dot.vip { background: #f59e0b; }
    .cal-legend .dot.society { background: #3b82f6; }
    .cal-legend .dot.tournament { background: #ec4899; }

    /* Detail Panel */
    .cal-nav-detail {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #f8fafc;
    }
    .cal-detail-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      font-size: 15px;
      background: #fff;
    }
    .cal-detail-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px;
    }
    .cal-detail-empty {
      color: #9ca3af;
      text-align: center;
      padding: 40px 20px;
      font-size: 13px;
    }
    .cal-detail-group {
      margin-bottom: 16px;
      padding: 12px;
      background: #fff;
      border-radius: 8px;
      border-left: 3px solid #3b82f6;
    }
    .cal-detail-group.vip { border-left-color: #f59e0b; }
    .cal-detail-group.tournament { border-left-color: #ec4899; }
    .cal-detail-group.regular { border-left-color: #22c55e; }
    .cal-detail-group-name {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 6px;
      color: #1f2937;
    }
    .cal-detail-time {
      font-size: 11px;
      color: #6b7280;
    }
    .cal-detail-footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e7eb;
      background: #fff;
    }
    .cal-detail-summary {
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 10px;
    }
    .cal-go-btn {
      width: 100%;
      padding: 10px 16px;
      background: #3b82f6;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .cal-go-btn:hover:not(:disabled) {
      background: #2563eb;
    }
    .cal-go-btn:disabled {
      background: #e5e7eb;
      color: #9ca3af;
      cursor: not-allowed;
    }

    /* Form */
    .form-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      min-width: 100px;
    }
    .form-group label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
    }
    .form-group input,
    .form-group select,
    .form-group textarea {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 13px;
    }
    .form-group textarea {
      resize: none;
      height: 50px;
    }

    /* Golfer Rows */
    .golfers-section h3 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .golfer-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding: 14px;
      background: #f8fafc;
      border-radius: 10px;
      margin-bottom: 10px;
      border: 1px solid var(--border);
    }
    .golfer-num {
      width: 32px;
      height: 32px;
      background: var(--brand);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      flex-shrink: 0;
      margin-top: 20px;
    }
    .golfer-fields {
      flex: 1;
      display: flex;
      gap: 12px;
    }
    .golfer-field {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .golfer-field label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
    }
    .golfer-field input {
      padding: 12px 14px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      width: 100%;
    }
    .golfer-field input:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    .caddy-select-wrapper {
      position: relative;
      width: 100%;
    }
    .caddy-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    .caddy-dropdown.show { display: block; }
    .caddy-option {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f1f5f9;
    }
    .caddy-option:hover { background: #f8fafc; }
    .caddy-option:last-child { border-bottom: none; }
    .caddy-option-name { font-weight: 600; font-size: 13px; }
    .caddy-option-info { font-size: 11px; color: var(--muted); }
    .caddy-option-rating { float: right; color: #f59e0b; font-size: 12px; }
    .caddy-option.booked {
      background: #fef2f2;
      opacity: 0.7;
      cursor: not-allowed;
    }
    .caddy-option.booked:hover { background: #fef2f2; }
    .caddy-option.booked .caddy-option-name {
      color: #991b1b;
      text-decoration: line-through;
    }
    .caddy-booked-badge {
      display: inline-block;
      background: #ef4444;
      color: #fff;
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 6px;
      font-weight: 600;
      text-transform: uppercase;
    }

    /* Caddy Picker Modal */
    #caddy-picker-modal {
      width: 90vw;
      max-width: 1000px;
      max-height: 85vh;
      border-radius: 16px;
      border: none;
      box-shadow: 0 25px 50px rgba(0,0,0,0.25);
      padding: 0;
      overflow: hidden;
    }
    #caddy-picker-modal::backdrop {
      background: rgba(0,0,0,0.5);
    }
    .caddy-picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(135deg, #1e3a5f 0%, #2563eb 100%);
      color: #fff;
    }
    .caddy-picker-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .caddy-picker-close {
      background: rgba(255,255,255,0.2);
      border: none;
      color: #fff;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .caddy-picker-close:hover {
      background: rgba(255,255,255,0.3);
    }
    .caddy-picker-search {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: #f8fafc;
    }
    .caddy-picker-search input {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
    }
    .caddy-picker-search input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }
    .caddy-picker-stats {
      padding: 8px 20px;
      background: #f1f5f9;
      font-size: 12px;
      color: var(--muted);
      border-bottom: 1px solid var(--border);
    }
    .caddy-picker-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
      padding: 20px;
      max-height: calc(85vh - 200px);
      overflow-y: auto;
    }
    .caddy-card {
      background: #fff;
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    .caddy-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .caddy-card.unavailable {
      opacity: 0.5;
      cursor: not-allowed;
      background: #fef2f2;
    }
    .caddy-card.unavailable:hover {
      transform: none;
      box-shadow: none;
      border-color: #fecaca;
    }
    .caddy-card-photo {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      object-fit: cover;
      background: #e5e7eb;
      margin-bottom: 8px;
    }
    .caddy-card-number {
      font-size: 18px;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 2px;
    }
    .caddy-card-name {
      font-size: 13px;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 4px;
      line-height: 1.2;
    }
    .caddy-card-rating {
      color: #f59e0b;
      font-size: 12px;
      margin-bottom: 4px;
    }
    .caddy-card-lang {
      font-size: 10px;
      color: var(--muted);
      background: #f1f5f9;
      padding: 2px 8px;
      border-radius: 4px;
    }
    .caddy-card-status {
      font-size: 10px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
      margin-top: 6px;
    }
    .caddy-card-status.booked {
      background: #fef2f2;
      color: #991b1b;
    }
    .caddy-card-status.in-group {
      background: #fef3c7;
      color: #92400e;
    }

    /* Caddy Browse Button - styled like Today button */
    .open-picker-btn {
      background: var(--brand);
      border: 1px solid var(--brand);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .open-picker-btn:hover {
      background: #2563eb;
      transform: scale(1.05);
    }

    .remove-golfer {
      width: 32px;
      height: 32px;
      border: 1px solid #fecaca;
      background: #fef2f2;
      color: #ef4444;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      flex-shrink: 0;
      margin-top: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .remove-golfer:hover { background: #fee2e2; }
    .add-golfer-btn {
      font-size: 13px;
      padding: 8px 16px;
      background: #eff6ff;
      color: var(--brand);
      border: 1px solid #bfdbfe;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
    }
    .add-golfer-btn:hover { background: #dbeafe; }

    /* Range Booking Toggle */
    .range-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    .range-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--brand);
    }
    .range-toggle label {
      font-size: 14px;
      font-weight: 600;
      color: var(--ink);
      cursor: pointer;
    }
    .range-toggle .range-hint {
      font-size: 12px;
      color: var(--muted);
      margin-left: auto;
    }

    /* Recurring Booking Styles */
    .recurring-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px dashed var(--border);
    }
    .recurring-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: #fdf4ff;
      border: 1px solid #e879f9;
      border-radius: 8px;
    }
    .recurring-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #2dd4bf;
    }
    .recurring-toggle label {
      font-size: 14px;
      font-weight: 600;
      color: var(--ink);
      cursor: pointer;
    }
    .recurring-toggle .recurring-hint {
      font-size: 12px;
      color: var(--muted);
      margin-left: auto;
    }
    .recurring-options {
      margin-top: 12px;
      padding: 12px;
      background: #f0fdfa;
      border: 1px solid #e9d5ff;
      border-radius: 8px;
    }
    .weekdays-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .weekdays-row > label {
      font-size: 13px;
      font-weight: 500;
      color: var(--ink);
    }
    .weekday-checkboxes {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .weekday-checkboxes label {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .weekday-checkboxes label:has(input:checked) {
      background: #2dd4bf;
      border-color: #2dd4bf;
      color: #fff;
    }
    .weekday-checkboxes input {
      display: none;
    }
    .recurring-preview {
      margin-top: 12px;
      padding: 10px;
      background: #fff;
      border: 1px solid #e9d5ff;
      border-radius: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    .recurring-preview strong {
      color: #0d9488;
    }

    /* Range Time Selectors */
    .range-time-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      padding: 12px;
      background: #fef3c7;
      border: 1px solid #fcd34d;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    .range-time-row .form-group {
      flex: 1;
    }
    .range-time-row .range-info {
      font-size: 13px;
      color: #92400e;
      font-weight: 500;
      padding: 8px 0;
    }

    /* Slot Cards for Range Booking */
    .range-slots-container {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 8px;
    }
    .slot-card {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 10px;
      margin-bottom: 12px;
      overflow: hidden;
    }
    .slot-card.collapsed .slot-body { display: none; }
    .slot-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: #f8fafc;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
    }
    .slot-header:hover { background: #f1f5f9; }
    .slot-time-badge {
      background: var(--brand);
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }
    .slot-summary {
      flex: 1;
      font-size: 13px;
      color: var(--muted);
    }
    .slot-summary .names {
      color: var(--ink);
      font-weight: 500;
    }
    .slot-expand-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 18px;
      transition: transform 0.2s;
    }
    .slot-card:not(.collapsed) .slot-expand-icon { transform: rotate(180deg); }
    .slot-body {
      padding: 14px;
    }

    /* Range Booking Pill */
    .pill.range-group {
      border-left-width: 5px;
      position: relative;
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    }
    .pill.range-group.society {
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
      border-left-color: #3b82f6;
    }
    .pill.range-group.tournament {
      background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
      border-left-color: #ec4899;
    }
    .pill.range-group.vip {
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
      border-left-color: #f59e0b;
    }
    .pill.range-start {
      border-radius: 6px 6px 2px 2px;
      margin-bottom: 2px;
    }
    .pill.range-middle {
      border-radius: 2px;
      margin-bottom: 2px;
    }
    .pill.range-end {
      border-radius: 2px 2px 6px 6px;
    }
    .pill.range-group .pill-name {
      font-weight: 600;
    }

    .btn-delete {
      background: #fff;
      color: #ef4444;
      border-color: #fecaca;
    }
    .btn-delete:hover {
      background: #fef2f2;
    }

    /* Back to Top Button */
    .back-to-top {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      background: var(--brand);
      color: #fff;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1000;
      transition: transform 0.2s, opacity 0.2s;
    }
    .back-to-top:hover {
      transform: scale(1.1);
    }
    .back-to-top.show {
      display: flex;
    }

    /* Settings Modal */
    .settings-btn {
      background: var(--ink);
      color: #fff;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .settings-btn:hover {
      background: #334155;
    }
    .settings-modal {
      max-width: 900px;
      width: 95%;
    }
    .settings-tabs {
      display: flex;
      gap: 0;
      border-bottom: 2px solid var(--border);
      background: #f8fafc;
      padding: 0 16px;
    }
    .settings-tab {
      padding: 14px 20px;
      border: none;
      background: none;
      font-size: 14px;
      font-weight: 500;
      color: var(--muted);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.15s;
    }
    .settings-tab:hover {
      color: var(--ink);
    }
    .settings-tab.active {
      color: var(--brand);
      border-bottom-color: var(--brand);
      background: #fff;
    }
    .settings-content {
      padding: 20px;
      max-height: 60vh;
      overflow-y: auto;
    }
    .settings-panel {
      display: none;
    }
    .settings-panel.active {
      display: block;
    }
    .settings-section {
      margin-bottom: 24px;
    }
    .settings-section h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }
    .settings-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .settings-field label {
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
    }
    .settings-field input,
    .settings-field select {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
    }
    .settings-field input:focus,
    .settings-field select:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Time Periods */
    .time-period-row {
      display: grid;
      grid-template-columns: 100px 120px 120px 100px 40px;
      gap: 12px;
      align-items: center;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .time-period-row input {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 13px;
    }
    .time-period-label {
      font-weight: 600;
      font-size: 13px;
      color: var(--ink);
    }
    .add-period-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #eff6ff;
      color: var(--brand);
      border: 1px solid #bfdbfe;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }
    .add-period-btn:hover {
      background: #dbeafe;
    }
    .remove-period-btn {
      width: 32px;
      height: 32px;
      border: 1px solid #fecaca;
      background: #fef2f2;
      color: #ef4444;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }
    .remove-period-btn:hover {
      background: #fee2e2;
    }

    /* Package Cards */
    .package-card {
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .package-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .package-name {
      font-weight: 600;
      font-size: 14px;
    }
    .package-fields {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    .package-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .package-field label {
      font-size: 11px;
      color: var(--muted);
    }
    .package-field input,
    .package-field select {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 13px;
    }

    /* Currency Input */
    .currency-input {
      position: relative;
    }
    .currency-input::before {
      content: '‡∏ø';
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--muted);
      font-size: 14px;
    }
    .currency-input input {
      padding-left: 28px;
    }

    /* Settings Summary */
    .settings-summary {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }
    .settings-summary h4 {
      font-size: 13px;
      font-weight: 600;
      color: #0369a1;
      margin-bottom: 8px;
    }
    .settings-summary-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      font-size: 12px;
    }
    .summary-item {
      display: flex;
      flex-direction: column;
    }
    .summary-label {
      color: var(--muted);
    }
    .summary-value {
      font-weight: 600;
      color: var(--ink);
    }
  </style>
</head>
<body>
  <div class="teesheet-container">
    <!-- Top Header Bar -->
    <div class="top-header-bar">
      <div class="header-left">
        <div class="logo-section">
          <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="#22c55e" stroke-width="2"/><path d="M8 12l3 3 5-6" stroke="#22c55e" stroke-width="2" fill="none"/></svg>
          <span class="course-name-display" id="course-name-display">Select Course</span>
        </div>
        <div class="live-badge">
          <div class="live-dot"></div>
          <span>LIVE TEE SHEET</span>
        </div>
      </div>
      <div class="header-center">
        <button class="date-nav-btn" id="header-prev-day">‚Äπ</button>
        <div class="date-display-large" id="date-display-large">Loading...</div>
        <button class="date-nav-btn" id="header-next-day">‚Ä∫</button>
      </div>
      <div class="header-right">
        <div class="current-time-display" id="current-time-display">--:--</div>
        <select id="lang-select" style="background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.3);color:#fff;padding:6px 10px;border-radius:6px;font-size:12px;cursor:pointer;">
          <option value="en" style="background:#1e293b;color:#fff;">üá¨üáß EN</option>
          <option value="th" style="background:#1e293b;color:#fff;">üáπüá≠ TH</option>
          <option value="ko" style="background:#1e293b;color:#fff;">üá∞üá∑ KO</option>
          <option value="ja" style="background:#1e293b;color:#fff;">üáØüáµ JA</option>
        </select>
        <button class="header-btn" id="settings-btn">‚öô Settings</button>
        <a href="/index.html#proshop" class="header-btn primary">‚Üê Dashboard</a>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
    <!-- Old Header (hidden) -->
    <div class="header-row">
      <h1 data-i18n="teeSheet">Tee Sheet</h1>
    </div>

    <!-- Controls -->
    <div class="controls-row">
      <!-- Course select hidden - controlled via URL param and settings only -->
      <!-- Course select - maps to CaddySystem.allCaddys homeClub values -->
      <select id="course-select" style="display:none;">
        <option value="">-- Select Course --</option>
        <option value="bangpakong">Bangpakong Riverside CC</option>
        <option value="bangpra-international">Bangpra International GC</option>
        <option value="burapha-ac">Burapha Golf Club A+C</option>
        <option value="burapha-cd">Burapha Golf Club C+D</option>
        <option value="burapha-east">Burapha Golf Club East</option>
        <option value="cheechan">Chee Chan Golf Resort</option>
        <option value="crystal-bay">Crystal Bay Golf Club</option>
        <option value="eastern-star">Eastern Star CC</option>
        <option value="grand-prix">Grand Prix International GC</option>
        <option value="greenwood">Greenwood Golf Club</option>
        <option value="hermes">Hermes Golf Club</option>
        <option value="khao-kheow">Khao Kheow Country Club</option>
        <option value="laem-chabang">Laem Chabang International CC</option>
        <option value="mountain-shadow">Mountain Shadow GC</option>
        <option value="pattana-golf-resort">Pattana Golf Resort</option>
        <option value="pattavia">Pattavia Century GC</option>
        <option value="pattaya-golf">Pattaya Golf Club</option>
        <option value="phoenix">Phoenix Gold Golf CC</option>
        <option value="pleasant-valley">Pleasant Valley CC</option>
        <option value="plutaluang">Plutaluang Navy GC</option>
        <option value="royal-garden">Royal Garden Golf Club</option>
        <option value="royal-lakeside">Royal Lakeside GC</option>
        <option value="siam-cc-old">Siam CC Old Course</option>
        <option value="siam-cc-plantation">Siam CC Plantation</option>
        <option value="siam-cc-waterside">Siam CC Waterside</option>
        <option value="siam-plantation">Siam Plantation GC</option>
        <option value="st-andrews-2000">St. Andrews 2000 GC</option>
        <option value="thai-country-club">Thai Country Club</option>
        <option value="treasure-hill-golf">Treasure Hill Golf & Country Club</option>
      </select>

      <div class="control-group">
        <label data-i18n="date">DATE</label>
        <div class="date-control">
          <button id="prev-day">‚Äπ</button>
          <input type="date" id="date-input">
          <button id="next-day">‚Ä∫</button>
          <button id="today-btn" class="today-btn" title="Go to Today">Today</button>
          <button id="calendar-nav-btn" class="cal-nav-btn" title="Month View">üìÖ</button>
        </div>
      </div>

      <div class="control-group">
        <label data-i18n="courseLayout">COURSE LAYOUT</label>
        <select id="complex-select">
          <option value="18" selected>18 holes (A/B)</option>
          <option value="27">27 holes (A/B/C)</option>
          <option value="36">36 holes (A/B/C/D)</option>
        </select>
      </div>

      <div class="control-group">
        <label data-i18n="start">START</label>
        <select id="start-time" data-time-picker data-default="06:00"></select>
      </div>

      <div class="control-group">
        <label data-i18n="end">END</label>
        <select id="end-time" data-time-picker data-default="18:00"></select>
      </div>

      <div class="control-group">
        <label data-i18n="interval">INTERVAL</label>
        <select id="interval-select">
          <option value="5">5 min</option>
          <option value="7" selected>7 min</option>
          <option value="8">8 min</option>
          <option value="10">10 min</option>
          <option value="12">12 min</option>
          <option value="15">15 min</option>
        </select>
      </div>

      <div class="control-group">
        <label data-i18n="teesCourse">TEES/COURSE</label>
        <select id="tees-select">
          <option value="1">1</option>
          <option value="2" selected>2</option>
        </select>
      </div>

      <div class="control-group search-group">
        <label data-i18n="search">SEARCH</label>
        <input type="text" id="search-input" placeholder="Golfer or caddy..." data-i18n-placeholder="searchPlaceholder">
      </div>

      <button class="btn" id="find-btn" data-i18n="find">Find</button>
      <button class="btn" id="next-btn" data-i18n="next">Next</button>
      <button class="btn btn-clear" id="clear-btn" data-i18n="clearDay">Clear Day</button>
    </div>

    <!-- Legend -->
    <div class="legend-row">
      <div class="course-legend" id="course-legend">
        <div class="legend-item"><span class="legend-dot course-a"></span> <span data-i18n="courseA">Course A</span></div>
        <div class="legend-item"><span class="legend-dot course-b"></span> <span data-i18n="courseB">Course B</span></div>
        <div class="legend-item" id="legend-c"><span class="legend-dot course-c"></span> <span data-i18n="courseC">Course C</span></div>
        <div class="legend-item" id="legend-d" style="display:none"><span class="legend-dot course-d"></span> <span data-i18n="courseD">Course D</span></div>
      </div>
      <div class="type-legend">
        <div class="legend-item"><span class="legend-dot regular"></span> <span data-i18n="regular">Regular</span></div>
        <div class="legend-item"><span class="legend-dot vip"></span> <span data-i18n="vip">VIP</span></div>
        <div class="legend-item"><span class="legend-dot society"></span> <span data-i18n="society">Society</span></div>
        <div class="legend-item"><span class="legend-dot tournament"></span> <span data-i18n="tournament">Tournament</span></div>
      </div>
    </div>

    <!-- Tee Sheet Grid -->
    <div class="teesheet-grid">
      <div class="grid-header" id="grid-header"></div>
      <div id="grid-body"></div>
    </div>
    </div><!-- end main-content -->
  </div><!-- end teesheet-container -->

  <!-- Booking Modal -->
  <dialog id="booking-dialog">
    <div class="modal-header">
      <h2 data-i18n="bookSlot">Book Slot</h2>
      <button class="modal-close" id="close-dialog">&times;</button>
    </div>
    <div class="modal-body">
      <input type="hidden" id="booking-id">
      <input type="hidden" id="booking-group-id">

      <!-- Range Booking Toggle -->
      <div class="range-toggle">
        <input type="checkbox" id="range-mode-toggle">
        <label for="range-mode-toggle" data-i18n="blockTimeRange">Block Time Range</label>
        <span class="range-hint" data-i18n="rangeHint">For society/group bookings</span>
      </div>

      <!-- Single Booking Row (shown when range mode is OFF) -->
      <div class="form-row" id="single-booking-row">
        <div class="form-group">
          <label data-i18n="time">Time</label>
          <select id="booking-time" style="font-weight:600;"></select>
        </div>
        <div class="form-group">
          <label data-i18n="course">Course</label>
          <select id="booking-course"></select>
        </div>
        <div class="form-group">
          <label data-i18n="tee">Tee</label>
          <select id="booking-tee">
            <option value="1">1</option>
            <option value="2">2</option>
          </select>
        </div>
        <div class="form-group">
          <label data-i18n="bookingType">Booking Type</label>
          <select id="booking-type">
            <option value="regular" data-i18n="regular">Regular</option>
            <option value="vip" data-i18n="vip">VIP</option>
            <option value="society" data-i18n="society">Society</option>
            <option value="tournament" data-i18n="tournament">Tournament</option>
          </select>
        </div>
      </div>

      <!-- Range Time Row (shown when range mode is ON) -->
      <div class="range-time-row" id="range-time-row" style="display:none;">
        <div class="form-group">
          <label data-i18n="startTime">Start Time</label>
          <select id="range-start-time" style="font-weight:600;"></select>
        </div>
        <div class="form-group">
          <label data-i18n="endTime">End Time</label>
          <select id="range-end-time" style="font-weight:600;"></select>
        </div>
        <div class="form-group">
          <label data-i18n="course">Course</label>
          <select id="range-course"></select>
        </div>
        <div class="form-group">
          <label data-i18n="tee">Tee</label>
          <select id="range-tee">
            <option value="1">1</option>
            <option value="2">2</option>
          </select>
        </div>
        <div class="form-group">
          <label data-i18n="bookingType">Booking Type</label>
          <select id="range-type">
            <option value="society" data-i18n="society" selected>Society</option>
            <option value="tournament" data-i18n="tournament">Tournament</option>
            <option value="vip" data-i18n="vip">VIP</option>
          </select>
        </div>
        <div class="range-info" id="range-info"></div>
      </div>

      <!-- Group Name for Range Booking -->
      <div class="form-row" id="range-group-name-row" style="display:none;">
        <div class="form-group" style="flex:1">
          <label data-i18n="groupName">Group / Society Name</label>
          <input type="text" id="range-group-name" placeholder="e.g., XYZ Corporate Outing">
        </div>
      </div>

      <!-- Single Booking Golfers (when range mode is OFF) -->
      <div class="golfers-section" id="single-golfers-section">
        <h3>
          <span data-i18n="golfers">Golfers</span>
          <button type="button" class="add-golfer-btn" id="add-golfer" data-i18n="addGolfer">+ Add Golfer</button>
        </h3>
        <div id="golfers-list"></div>
      </div>

      <!-- Range Booking Slots (when range mode is ON) -->
      <div class="golfers-section" id="range-slots-section" style="display:none;">
        <h3>
          <span data-i18n="timeSlots">Time Slots</span>
          <span id="slot-count-badge" style="background:#e0f2fe;color:#0369a1;padding:4px 10px;border-radius:12px;font-size:12px;margin-left:8px;">0 slots</span>
        </h3>
        <div class="range-slots-container" id="range-slots-list"></div>
      </div>

      <div class="form-row">
        <div class="form-group" style="flex:1">
          <label data-i18n="notes">Notes</label>
          <textarea id="booking-notes" rows="2"></textarea>
        </div>
      </div>

      <!-- Recurring Booking Section -->
      <div class="recurring-section" id="recurring-section">
        <div class="recurring-toggle">
          <input type="checkbox" id="recurring-toggle">
          <label for="recurring-toggle" data-i18n="recurringBooking">Recurring Booking</label>
          <span class="recurring-hint" data-i18n="recurringHint">For standing tee times</span>
        </div>
        <div class="recurring-options" id="recurring-options" style="display:none;">
          <div class="form-row">
            <div class="form-group">
              <label data-i18n="repeatFrequency">Repeat</label>
              <select id="recurring-frequency">
                <option value="daily" data-i18n="daily">Daily</option>
                <option value="weekly" data-i18n="weekly" selected>Weekly</option>
                <option value="biweekly" data-i18n="biweekly">Every 2 Weeks</option>
                <option value="monthly" data-i18n="monthly">Monthly</option>
              </select>
            </div>
            <div class="form-group">
              <label data-i18n="repeatUntil">Until</label>
              <input type="date" id="recurring-until">
            </div>
            <div class="form-group">
              <label data-i18n="occurrences">Or # of times</label>
              <input type="number" id="recurring-count" min="1" max="52" placeholder="e.g., 12">
            </div>
          </div>
          <div class="form-row weekdays-row" id="weekdays-row">
            <label data-i18n="repeatOn">Repeat on:</label>
            <div class="weekday-checkboxes">
              <label><input type="checkbox" name="weekday" value="0"> <span data-i18n="sun">Sun</span></label>
              <label><input type="checkbox" name="weekday" value="1"> <span data-i18n="mon">Mon</span></label>
              <label><input type="checkbox" name="weekday" value="2"> <span data-i18n="tue">Tue</span></label>
              <label><input type="checkbox" name="weekday" value="3"> <span data-i18n="wed">Wed</span></label>
              <label><input type="checkbox" name="weekday" value="4"> <span data-i18n="thu">Thu</span></label>
              <label><input type="checkbox" name="weekday" value="5"> <span data-i18n="fri">Fri</span></label>
              <label><input type="checkbox" name="weekday" value="6"> <span data-i18n="sat">Sat</span></label>
            </div>
          </div>
          <div class="recurring-preview" id="recurring-preview"></div>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-delete" id="delete-booking" style="display:none" data-i18n="delete">Delete</button>
      <button class="btn" id="cancel-booking" data-i18n="cancel">Cancel</button>
      <button class="btn btn-primary" id="save-booking" data-i18n="save">Save</button>
    </div>
  </dialog>

  <!-- Caddy Picker Modal -->
  <dialog id="caddy-picker-modal">
    <div class="caddy-picker-header">
      <h3><span class="material-icons" style="vertical-align:middle;margin-right:8px;">sports_golf</span>Select Caddy</h3>
      <button class="caddy-picker-close" id="caddy-picker-close">&times;</button>
    </div>
    <div class="caddy-picker-search">
      <input type="text" id="caddy-picker-search" placeholder="Search by name or number...">
    </div>
    <div class="caddy-picker-stats" id="caddy-picker-stats">
      Showing 0 caddies
    </div>
    <div class="caddy-picker-grid" id="caddy-picker-grid">
      <!-- Caddy cards rendered here -->
    </div>
  </dialog>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="back-to-top" title="Back to top">‚Üë</button>

  <!-- Settings Modal -->
  <dialog id="settings-dialog" class="settings-modal">
    <div class="modal-header">
      <h2 data-i18n="teeSheetSettings">Tee Sheet Settings</h2>
      <button class="modal-close" id="close-settings">&times;</button>
    </div>

    <div class="settings-tabs">
      <button class="settings-tab active" data-tab="course" data-i18n="courseConfig">Course Configuration</button>
      <button class="settings-tab" data-tab="pricing" data-i18n="pricing">Green Fees & Pricing</button>
      <button class="settings-tab" data-tab="services" data-i18n="services">Caddy & Cart</button>
      <button class="settings-tab" data-tab="packages" data-i18n="packages">Packages & Promotions</button>
    </div>

    <div class="settings-content">
      <!-- Course Configuration Tab -->
      <div class="settings-panel active" id="panel-course">
        <div class="settings-section">
          <h3 data-i18n="courseDetails">Course Details</h3>
          <div class="settings-grid">
            <div class="settings-field" style="grid-column: span 2;">
              <label data-i18n="golfCourse">Golf Course</label>
              <select id="settings-course">
        <option value="">-- Select Course --</option>
        <option value="bangpakong">Bangpakong Riverside CC</option>
        <option value="bangpra-international">Bangpra International GC</option>
        <option value="burapha-ac">Burapha Golf Club A+C</option>
        <option value="burapha-cd">Burapha Golf Club C+D</option>
        <option value="burapha-east">Burapha Golf Club East</option>
        <option value="cheechan">Chee Chan Golf Resort</option>
        <option value="crystal-bay">Crystal Bay Golf Club</option>
        <option value="eastern-star">Eastern Star CC</option>
        <option value="grand-prix">Grand Prix International GC</option>
        <option value="greenwood">Greenwood Golf Club</option>
        <option value="hermes">Hermes Golf Club</option>
        <option value="khao-kheow">Khao Kheow Country Club</option>
        <option value="laem-chabang">Laem Chabang International CC</option>
        <option value="mountain-shadow">Mountain Shadow GC</option>
        <option value="pattana-golf-resort">Pattana Golf Resort</option>
        <option value="pattavia">Pattavia Century GC</option>
        <option value="pattaya-golf">Pattaya Golf Club</option>
        <option value="phoenix">Phoenix Gold Golf CC</option>
        <option value="pleasant-valley">Pleasant Valley CC</option>
        <option value="plutaluang">Plutaluang Navy GC</option>
        <option value="royal-garden">Royal Garden Golf Club</option>
        <option value="royal-lakeside">Royal Lakeside GC</option>
        <option value="siam-cc-old">Siam CC Old Course</option>
        <option value="siam-cc-plantation">Siam CC Plantation</option>
        <option value="siam-cc-waterside">Siam CC Waterside</option>
        <option value="siam-plantation">Siam Plantation GC</option>
        <option value="st-andrews-2000">St. Andrews 2000 GC</option>
        <option value="thai-country-club">Thai Country Club</option>
        <option value="treasure-hill-golf">Treasure Hill Golf & Country Club</option>
              </select>
            </div>
            <div class="settings-field">
              <label data-i18n="courseLayout">Course Layout</label>
              <select id="settings-layout">
                <option value="18">18 holes (A/B)</option>
                <option value="27">27 holes (A/B/C)</option>
                <option value="36">36 holes (A/B/C/D)</option>
              </select>
            </div>
            <div class="settings-field">
              <label data-i18n="teesCourse">Tees Per Course</label>
              <select id="settings-tees">
                <option value="1">1 Tee</option>
                <option value="2">2 Tees</option>
              </select>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3 data-i18n="operatingHours">Operating Hours</h3>
          <div class="settings-grid">
            <div class="settings-field">
              <label data-i18n="firstTeeTime">First Tee Time</label>
              <select id="settings-start" data-time-picker data-default="06:00"></select>
            </div>
            <div class="settings-field">
              <label data-i18n="lastTeeTime">Last Tee Time</label>
              <select id="settings-end" data-time-picker data-default="18:00"></select>
            </div>
            <div class="settings-field">
              <label data-i18n="interval">Tee Time Interval</label>
              <select id="settings-interval">
                <option value="5">5 minutes</option>
                <option value="7">7 minutes</option>
                <option value="8">8 minutes</option>
                <option value="10">10 minutes</option>
                <option value="12">12 minutes</option>
                <option value="15">15 minutes</option>
              </select>
            </div>
            <div class="settings-field">
              <label data-i18n="roundDuration">Round Duration (hrs)</label>
              <select id="settings-round-duration">
                <option value="240">4 hours</option>
                <option value="270" selected>4.5 hours</option>
                <option value="300">5 hours</option>
                <option value="330">5.5 hours</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <!-- Green Fees & Pricing Tab -->
      <div class="settings-panel" id="panel-pricing">
        <div class="settings-section">
          <h3 data-i18n="weekdayPricing">Weekday Pricing (Mon-Fri)</h3>
          <div id="weekday-periods">
            <div class="time-period-row">
              <span class="time-period-label" data-i18n="peak">Peak</span>
              <select class="period-start" data-time-picker data-default="06:00"></select>
              <select class="period-end" data-time-picker data-default="10:00"></select>
              <div class="currency-input">
                <input type="number" class="period-price" value="2500" placeholder="Price">
              </div>
              <button class="remove-period-btn" title="Remove">&times;</button>
            </div>
            <div class="time-period-row">
              <span class="time-period-label" data-i18n="offPeak">Off-Peak</span>
              <select class="period-start" data-time-picker data-default="10:00"></select>
              <select class="period-end" data-time-picker data-default="14:00"></select>
              <div class="currency-input">
                <input type="number" class="period-price" value="1800" placeholder="Price">
              </div>
              <button class="remove-period-btn" title="Remove">&times;</button>
            </div>
            <div class="time-period-row">
              <span class="time-period-label" data-i18n="twilight">Twilight</span>
              <select class="period-start" data-time-picker data-default="14:00"></select>
              <select class="period-end" data-time-picker data-default="18:00"></select>
              <div class="currency-input">
                <input type="number" class="period-price" value="1200" placeholder="Price">
              </div>
              <button class="remove-period-btn" title="Remove">&times;</button>
            </div>
          </div>
          <button class="add-period-btn" id="add-weekday-period">+ <span data-i18n="addPeriod">Add Time Period</span></button>
        </div>

        <div class="settings-section">
          <h3 data-i18n="weekendPricing">Weekend/Holiday Pricing (Sat-Sun)</h3>
          <div id="weekend-periods">
            <div class="time-period-row">
              <span class="time-period-label" data-i18n="peak">Peak</span>
              <select class="period-start" data-time-picker data-default="06:00"></select>
              <select class="period-end" data-time-picker data-default="12:00"></select>
              <div class="currency-input">
                <input type="number" class="period-price" value="3500" placeholder="Price">
              </div>
              <button class="remove-period-btn" title="Remove">&times;</button>
            </div>
            <div class="time-period-row">
              <span class="time-period-label" data-i18n="twilight">Twilight</span>
              <select class="period-start" data-time-picker data-default="12:00"></select>
              <select class="period-end" data-time-picker data-default="18:00"></select>
              <div class="currency-input">
                <input type="number" class="period-price" value="2200" placeholder="Price">
              </div>
              <button class="remove-period-btn" title="Remove">&times;</button>
            </div>
          </div>
          <button class="add-period-btn" id="add-weekend-period">+ <span data-i18n="addPeriod">Add Time Period</span></button>
        </div>
      </div>

      <!-- Caddy & Cart Tab -->
      <div class="settings-panel" id="panel-services">
        <div class="settings-section">
          <h3 data-i18n="caddyFees">Caddy Fees</h3>
          <div class="settings-grid">
            <div class="settings-field">
              <label data-i18n="caddyFee18">18 Holes Caddy Fee</label>
              <div class="currency-input">
                <input type="number" id="caddy-fee-18" value="400" placeholder="400">
              </div>
            </div>
            <div class="settings-field">
              <label data-i18n="caddyFee9">9 Holes Caddy Fee</label>
              <div class="currency-input">
                <input type="number" id="caddy-fee-9" value="250" placeholder="250">
              </div>
            </div>
            <div class="settings-field">
              <label data-i18n="caddyTip">Suggested Caddy Tip</label>
              <div class="currency-input">
                <input type="number" id="caddy-tip" value="300" placeholder="300">
              </div>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3 data-i18n="cartFees">Golf Cart Fees</h3>
          <div class="settings-grid">
            <div class="settings-field">
              <label data-i18n="cartFee18">18 Holes Cart Fee</label>
              <div class="currency-input">
                <input type="number" id="cart-fee-18" value="700" placeholder="700">
              </div>
            </div>
            <div class="settings-field">
              <label data-i18n="cartFee9">9 Holes Cart Fee</label>
              <div class="currency-input">
                <input type="number" id="cart-fee-9" value="400" placeholder="400">
              </div>
            </div>
            <div class="settings-field">
              <label data-i18n="cartSharing">Cart Sharing</label>
              <select id="cart-sharing">
                <option value="single" data-i18n="singleRiderOnly">Single Rider Only</option>
                <option value="shared" selected data-i18n="sharedCart">Shared (2 riders)</option>
                <option value="both" data-i18n="bothOptions">Both Options</option>
              </select>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3 data-i18n="otherServices">Other Services</h3>
          <div class="settings-grid">
            <div class="settings-field">
              <label data-i18n="clubRental">Club Rental</label>
              <div class="currency-input">
                <input type="number" id="club-rental" value="1500" placeholder="1500">
              </div>
            </div>
            <div class="settings-field">
              <label data-i18n="shoeRental">Shoe Rental</label>
              <div class="currency-input">
                <input type="number" id="shoe-rental" value="300" placeholder="300">
              </div>
            </div>
            <div class="settings-field">
              <label data-i18n="rangeBalls">Range Balls (bucket)</label>
              <div class="currency-input">
                <input type="number" id="range-balls" value="100" placeholder="100">
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Packages & Promotions Tab -->
      <div class="settings-panel" id="panel-packages">
        <div class="settings-section">
          <h3 data-i18n="societyRates">Society / Group Rates</h3>
          <div class="settings-grid">
            <div class="settings-field">
              <label data-i18n="minGroupSize">Minimum Group Size</label>
              <input type="number" id="society-min-size" value="12" min="4">
            </div>
            <div class="settings-field">
              <label data-i18n="societyDiscount">Discount (%)</label>
              <input type="number" id="society-discount" value="15" min="0" max="50">
            </div>
            <div class="settings-field">
              <label data-i18n="freeSlots">Free Slots per Group</label>
              <input type="number" id="society-free-slots" value="1" min="0">
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3 data-i18n="promotionalPackages">Promotional Packages</h3>
          <div id="packages-list">
            <div class="package-card">
              <div class="package-header">
                <input type="text" class="package-name" value="Weekday Special" placeholder="Package Name" data-i18n-placeholder="packageName">
                <button class="remove-period-btn remove-package">&times;</button>
              </div>
              <div class="package-fields">
                <div class="package-field">
                  <label data-i18n="greenFee">Green Fee</label>
                  <div class="currency-input">
                    <input type="number" class="pkg-green-fee" value="1500">
                  </div>
                </div>
                <div class="package-field">
                  <label data-i18n="includesCaddy">Includes Caddy</label>
                  <select class="pkg-includes-caddy">
                    <option value="yes" data-i18n="yes">Yes</option>
                    <option value="no" data-i18n="no">No</option>
                  </select>
                </div>
                <div class="package-field">
                  <label data-i18n="includesCart">Includes Cart</label>
                  <select class="pkg-includes-cart">
                    <option value="yes" data-i18n="yes">Yes</option>
                    <option value="no" selected data-i18n="no">No</option>
                  </select>
                </div>
                <div class="package-field">
                  <label data-i18n="validDays">Valid Days</label>
                  <select class="pkg-valid-days">
                    <option value="weekday" data-i18n="monFri">Mon-Fri</option>
                    <option value="weekend" data-i18n="satSun">Sat-Sun</option>
                    <option value="all" data-i18n="allDays">All Days</option>
                  </select>
                </div>
                <div class="package-field">
                  <label data-i18n="validFrom">Valid From</label>
                  <select class="pkg-valid-from" data-time-picker data-default="10:00"></select>
                </div>
                <div class="package-field">
                  <label data-i18n="validUntil">Valid Until</label>
                  <select class="pkg-valid-until" data-time-picker data-default="14:00"></select>
                </div>
              </div>
            </div>

            <div class="package-card">
              <div class="package-header">
                <input type="text" class="package-name" value="Twilight Deal" placeholder="Package Name" data-i18n-placeholder="packageName">
                <button class="remove-period-btn remove-package">&times;</button>
              </div>
              <div class="package-fields">
                <div class="package-field">
                  <label data-i18n="greenFee">Green Fee</label>
                  <div class="currency-input">
                    <input type="number" class="pkg-green-fee" value="1200">
                  </div>
                </div>
                <div class="package-field">
                  <label data-i18n="includesCaddy">Includes Caddy</label>
                  <select class="pkg-includes-caddy">
                    <option value="yes" data-i18n="yes">Yes</option>
                    <option value="no" data-i18n="no">No</option>
                  </select>
                </div>
                <div class="package-field">
                  <label data-i18n="includesCart">Includes Cart</label>
                  <select class="pkg-includes-cart">
                    <option value="yes" selected data-i18n="yes">Yes</option>
                    <option value="no" data-i18n="no">No</option>
                  </select>
                </div>
                <div class="package-field">
                  <label data-i18n="validDays">Valid Days</label>
                  <select class="pkg-valid-days">
                    <option value="weekday" data-i18n="monFri">Mon-Fri</option>
                    <option value="weekend" data-i18n="satSun">Sat-Sun</option>
                    <option value="all" selected data-i18n="allDays">All Days</option>
                  </select>
                </div>
                <div class="package-field">
                  <label data-i18n="validFrom">Valid From</label>
                  <select class="pkg-valid-from" data-time-picker data-default="14:00"></select>
                </div>
                <div class="package-field">
                  <label data-i18n="validUntil">Valid Until</label>
                  <select class="pkg-valid-until" data-time-picker data-default="18:00"></select>
                </div>
              </div>
            </div>
          </div>
          <button class="add-period-btn" id="add-package">+ <span data-i18n="addPackage">Add Package</span></button>
        </div>
      </div>

      <!-- Settings Summary -->
      <div class="settings-summary">
        <h4 data-i18n="currentSettings">Current Settings Summary</h4>
        <div class="settings-summary-grid">
          <div class="summary-item">
            <span class="summary-label" data-i18n="course">Course</span>
            <span class="summary-value" id="summary-course">-</span>
          </div>
          <div class="summary-item">
            <span class="summary-label" data-i18n="layout">Layout</span>
            <span class="summary-value" id="summary-layout">-</span>
          </div>
          <div class="summary-item">
            <span class="summary-label" data-i18n="hours">Hours</span>
            <span class="summary-value" id="summary-hours">-</span>
          </div>
          <div class="summary-item">
            <span class="summary-label" data-i18n="interval">Interval</span>
            <span class="summary-value" id="summary-interval">-</span>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-footer">
      <button class="btn" id="cancel-settings" data-i18n="cancel">Cancel</button>
      <button class="btn btn-primary" id="save-settings" data-i18n="saveSettings">Save Settings</button>
    </div>
  </dialog>

  <!-- Calendar Navigator Modal -->
  <dialog id="calendar-navigator">
    <div class="cal-nav-header">
      <div class="cal-nav-title">
        <button id="cal-prev-month" class="cal-arrow">‚óÄ</button>
        <h2 id="cal-month-title">January 2026</h2>
        <button id="cal-next-month" class="cal-arrow">‚ñ∂</button>
      </div>
      <div class="cal-nav-controls">
        <select id="cal-filter-type">
          <option value="">All Types</option>
          <option value="society">Society Only</option>
          <option value="vip">VIP Only</option>
          <option value="tournament">Tournament Only</option>
          <option value="regular">Regular Only</option>
        </select>
        <button id="cal-close" class="cal-close-btn">&times;</button>
      </div>
    </div>

    <div class="cal-nav-body">
      <!-- Left: Calendar Grid -->
      <div class="cal-nav-calendar">
        <div class="cal-weekdays">
          <span>Sun</span><span>Mon</span><span>Tue</span>
          <span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span>
        </div>
        <div id="cal-grid" class="cal-grid">
          <!-- Generated by JS -->
        </div>
        <div class="cal-legend">
          <span class="legend-item"><span class="dot regular"></span> Regular</span>
          <span class="legend-item"><span class="dot vip"></span> VIP</span>
          <span class="legend-item"><span class="dot society"></span> Society</span>
          <span class="legend-item"><span class="dot tournament"></span> Tournament</span>
        </div>
      </div>

      <!-- Right: Detail Panel -->
      <div class="cal-nav-detail">
        <div id="cal-detail-header" class="cal-detail-header">
          <span>üìÖ</span>
          <span id="cal-detail-date">Select a day</span>
        </div>
        <div id="cal-detail-content" class="cal-detail-content">
          <p class="cal-detail-empty">Hover or click a day to see bookings</p>
        </div>
        <div id="cal-detail-footer" class="cal-detail-footer">
          <div id="cal-detail-summary"></div>
          <button id="cal-go-to-day" class="cal-go-btn" disabled>
            Go to this day ‚Üí
          </button>
        </div>
      </div>
    </div>
  </dialog>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  (function() {
    'use strict';

    // ==================== SUPABASE INIT ====================
    const SUPABASE_URL = 'https://pyeeplwsnupmhgbguwqs.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5ZWVwbHdzbnVwbWhnYmd1d3FzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk4NDM2NjksImV4cCI6MjA3NTQxOTY2OX0.KVQ6WvDKz9s77lxn3AhSA_YTMCN6rsht9kDkMIDhngk';
    let supabaseClient = null;
    try {
      supabaseClient = window.supabase?.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      console.log('[TeeSheet] Supabase client initialized');
    } catch (e) {
      console.warn('[TeeSheet] Supabase init failed:', e);
    }

    // Cache for caddy bookings from database
    let caddyBookingsCache = {};
    let lastFetchTime = {};

    // Fetch caddy bookings from Supabase for a specific date
    async function fetchCaddyBookings(date) {
      if (!supabaseClient) return [];

      // Cache for 10 seconds to avoid hammering the database
      const now = Date.now();
      if (lastFetchTime[date] && (now - lastFetchTime[date]) < 10000) {
        return caddyBookingsCache[date] || [];
      }

      try {
        // Get caddy bookings with caddy profile
        const { data, error } = await supabaseClient
          .from('caddy_bookings')
          .select('*, caddy_profiles(name, caddy_number, photo_url)')
          .eq('booking_date', date)
          .neq('status', 'cancelled');

        if (error) {
          console.error('[TeeSheet] Error fetching caddy bookings:', error);
          return caddyBookingsCache[date] || [];
        }

        // Get user profiles for golfer names
        const userIds = [...new Set((data || []).map(b => b.user_id).filter(Boolean))];
        let userProfiles = {};
        if (userIds.length > 0) {
          const { data: profiles } = await supabaseClient
            .from('user_profiles')
            .select('line_user_id, name, email')
            .in('line_user_id', userIds);
          (profiles || []).forEach(p => { userProfiles[p.line_user_id] = p; });
        }

        // Convert to tee sheet format
        const bookings = (data || []).map(b => {
          const profile = userProfiles[b.user_id];
          const golferName = profile?.name || profile?.email?.split('@')[0] || 'Golfer';
          const teeTime = b.tee_time ? b.tee_time.substring(0, 5) : null;
          return {
            id: `caddy-${b.id}`,
            dbId: b.id,
            time: teeTime,
            course: 'A',
            tee: 1,
            col: 0,
            bookingType: 'regular',
            source: 'caddy-booking-db',
            golfers: [{
              name: golferName,
              odoo_id: b.user_id,
              caddyId: b.caddy_id,
              caddyName: b.caddy_profiles?.name || 'Caddy',
              caddyNumber: b.caddy_profiles?.caddy_number || null
            }],
            status: b.status,
            createdAt: b.created_at
          };
        });

        caddyBookingsCache[date] = bookings;
        lastFetchTime[date] = now;
        return bookings;
      } catch (e) {
        console.error('[TeeSheet] Fetch error:', e);
        return caddyBookingsCache[date] || [];
      }
    }

    // Cache for society events
    let societyEventsCache = {};
    let societyEventsLastFetchTime = {};

    // Course name mapping: database course_name -> tee sheet course ID
    const courseNameToId = {
      'treasure hill golf & country club': 'treasure-hill-golf',
      'treasure hill': 'treasure-hill-golf',
      'treasure hill cc': 'treasure-hill-golf',
      'treasure hill country club': 'treasure-hill-golf',
      't.hill': 'treasure-hill-golf',
      't hill': 'treasure-hill-golf',
      'pattana golf resort': 'pattana-golf-resort',
      'pattana golf club & resort': 'pattana-golf-resort',
      'pattana': 'pattana-golf-resort',
      'chee chan golf resort': 'cheechan',
      'cheechan': 'cheechan',
      'greenwood golf club': 'greenwood',
      'greenwood': 'greenwood',
      'bangpakong riverside cc': 'bangpakong',
      'bangpakong riverside country club': 'bangpakong',
      'bangpakong': 'bangpakong',
      'pleasant valley cc': 'pleasant-valley',
      'pleasant valley': 'pleasant-valley',
      'plutaluang navy gc': 'plutaluang',
      'plutaluang': 'plutaluang',
      'mountain shadow gc': 'mountain-shadow',
      'mountain shadow': 'mountain-shadow',
      'eastern star cc': 'eastern-star',
      'eastern star country club': 'eastern-star',
      'pattaya c.c.': 'pattaya-golf',
      'pattaya golf club': 'pattaya-golf',
      'phoenix gold golf cc': 'phoenix',
      'phoenix gold golf & country club': 'phoenix',
      'phoenix': 'phoenix',
      'khao kheow country club': 'khao-kheow',
      'khao kheow': 'khao-kheow',
      'laem chabang international cc': 'laem-chabang',
      'laem chabang international country club': 'laem-chabang',
      'laem chabang': 'laem-chabang',
      'burapha golf club': 'burapha-ac',
      'burapha': 'burapha-ac',
      'siam cc old course': 'siam-cc-old',
      'siam country club - old course': 'siam-cc-old',
      'siam cc plantation': 'siam-cc-plantation',
      'siam country club - plantation': 'siam-cc-plantation',
      'siam cc waterside': 'siam-cc-waterside',
      'crystal bay golf club': 'crystal-bay',
      'crystal bay': 'crystal-bay',
      'st. andrews 2000 gc': 'st-andrews-2000',
      'st andrews 2000': 'st-andrews-2000',
      'royal lakeside gc': 'royal-lakeside',
      'royal lakeside': 'royal-lakeside',
      'thai country club': 'thai-country-club',
      'grand prix international gc': 'grand-prix',
      'grand prix': 'grand-prix',
      'hermes golf club': 'hermes',
      'hermes': 'hermes',
      'pattavia century gc': 'pattavia',
      'pattavia': 'pattavia',
      'bangpra international gc': 'bangpra-international',
      'bangpra': 'bangpra-international',
      'royal garden golf club': 'royal-garden',
      'royal garden': 'royal-garden',
      'green valley': 'greenwood' // Some events use Green Valley for Greenwood area
    };

    // Helper to match course name to tee sheet course ID
    function matchCourseToId(courseName) {
      if (!courseName) return null;
      const normalized = courseName.toLowerCase().trim();
      return courseNameToId[normalized] || null;
    }

    // Fetch society events from Supabase for a specific date and course
    async function fetchSocietyEvents(date) {
      if (!supabaseClient) return [];

      const selectedCourseId = el?.courseSelect?.value || '';
      const cacheKey = `${date}::${selectedCourseId}`;

      const now = Date.now();
      if (societyEventsLastFetchTime[cacheKey] && (now - societyEventsLastFetchTime[cacheKey]) < 10000) {
        return societyEventsCache[cacheKey] || [];
      }

      try {
        // Get society events for this date (exclude cancelled events)
        const { data, error } = await supabaseClient
          .from('society_events')
          .select('id, title, event_date, start_time, end_time, course_name, society_id, status, organizer_name')
          .eq('event_date', date)
          .neq('status', 'cancelled');

        if (error) {
          console.error('[TeeSheet] Error fetching society events:', error);
          return societyEventsCache[cacheKey] || [];
        }

        // Filter to only events matching the selected course
        const filteredData = (data || []).filter(evt => {
          if (!selectedCourseId) return true;
          const eventCourseId = matchCourseToId(evt.course_name);
          return eventCourseId === selectedCourseId;
        });

        // Convert to tee sheet booking format
        const events = filteredData.map(evt => {
          const startTime = evt.start_time ? evt.start_time.substring(0, 5) : '08:00';
          const endTime = evt.end_time ? evt.end_time.substring(0, 5) : null;
          const endMins = endTime ? minutes(endTime) : minutes(startTime) + 60;
          const startMins = minutes(startTime);
          const step = parseInt(el?.intervalSelect?.value) || 10;
          const numSlots = Math.ceil((endMins - startMins) / step);

          // Create group of time slots for the blocked range
          const slots = [];
          for (let i = 0; i < numSlots; i++) {
            const slotTime = hhmm(startMins + (i * step));
            slots.push({
              id: `society-${evt.id}-slot-${i}`,
              eventId: evt.id,
              time: slotTime,
              course: 'A',
              tee: 1,
              col: 0,
              bookingType: 'society',
              type: 'society_event',
              source: 'society-event-db',
              groupId: `society-${evt.id}`,
              groupName: evt.title || evt.organizer_name || 'Society Event',
              societyName: evt.organizer_name || '',
              eventName: evt.title,
              groupIndex: i,
              groupTotal: numSlots,
              startTime: startTime,
              endTime: endTime || hhmm(endMins),
              golfers: [],
              status: 'confirmed',
              createdAt: new Date().toISOString()
            });
          }
          return slots;
        }).flat();

        societyEventsCache[cacheKey] = events;
        societyEventsLastFetchTime[cacheKey] = now;
        return events;
      } catch (e) {
        console.error('[TeeSheet] Society events fetch error:', e);
        return societyEventsCache[cacheKey] || [];
      }
    }

    // Cache for event registrations with caddy info
    let eventRegistrationsCache = {};
    let eventRegLastFetchTime = {};

    // Fetch event registrations with caddy info for society events on a given date
    async function fetchEventRegistrations(date) {
      if (!supabaseClient) return [];

      const now = Date.now();
      if (eventRegLastFetchTime[date] && (now - eventRegLastFetchTime[date]) < 10000) {
        return eventRegistrationsCache[date] || [];
      }

      try {
        // Get event registrations for society events on this date
        const { data, error } = await supabaseClient
          .from('event_registrations')
          .select(`
            id,
            event_id,
            player_id,
            player_name,
            caddy_numbers,
            society_events!inner(id, title, event_date, start_time, end_time, course_name)
          `)
          .eq('society_events.event_date', date);

        if (error) {
          console.error('[TeeSheet] Error fetching event registrations:', error);
          return eventRegistrationsCache[date] || [];
        }

        // Group by event_id for easy lookup
        const regsByEvent = {};
        (data || []).forEach(reg => {
          if (!regsByEvent[reg.event_id]) {
            regsByEvent[reg.event_id] = {
              eventId: reg.event_id,
              eventTitle: reg.society_events?.title || 'Society Event',
              startTime: reg.society_events?.start_time?.substring(0, 5) || '08:00',
              endTime: reg.society_events?.end_time?.substring(0, 5) || null,
              registrations: []
            };
          }
          regsByEvent[reg.event_id].registrations.push({
            playerId: reg.player_id,
            playerName: reg.player_name,
            caddyNumbers: reg.caddy_numbers
          });
        });

        const result = Object.values(regsByEvent);
        eventRegistrationsCache[date] = result;
        eventRegLastFetchTime[date] = now;
        console.log('[TeeSheet] Fetched event registrations for', result.length, 'events on', date);
        return result;
      } catch (e) {
        console.error('[TeeSheet] Event registrations fetch error:', e);
        return eventRegistrationsCache[date] || [];
      }
    }

    // Helper to check if a time falls within a society event's blocked range
    function isTimeInEventRange(timeStr, eventStart, eventEnd, intervalMins = 60) {
      if (!timeStr || !eventStart) return false;
      const timeMins = minutes(timeStr);
      const startMins = minutes(eventStart);
      // If no end time specified, assume 1 hour block
      const endMins = eventEnd ? minutes(eventEnd) : startMins + intervalMins;
      return timeMins >= startMins && timeMins < endMins;
    }

    // ==================== TIME PICKER UTILITY ====================
    const TimePickerUtils = {
      defaults: {
        startHour: 6,
        endHour: 19,
        interval: 10, // minutes - 10min for faster load
        format: '24h'
      },

      generateTimeOptions(options = {}) {
        const start = (options.startHour ?? this.defaults.startHour) * 60;
        const end = (options.endHour ?? this.defaults.endHour) * 60;
        const interval = options.interval ?? this.defaults.interval;
        const format = options.format ?? this.defaults.format;

        const times = [];
        for (let m = start; m <= end; m += interval) {
          const hours = Math.floor(m / 60);
          const mins = m % 60;
          const value = `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;

          let label = value;
          if (format === '12h') {
            const h = hours % 12 || 12;
            const ampm = hours < 12 ? 'AM' : 'PM';
            label = `${h}:${String(mins).padStart(2, '0')} ${ampm}`;
          }
          times.push({ value, label });
        }
        return times;
      },

      populateSelect(selectEl, options = {}) {
        if (!selectEl) return;
        const times = this.generateTimeOptions(options);
        const currentValue = selectEl.value || options.defaultValue || '';

        selectEl.innerHTML = '';
        if (options.placeholder) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = options.placeholder;
          selectEl.appendChild(opt);
        }

        times.forEach(t => {
          const opt = document.createElement('option');
          opt.value = t.value;
          opt.textContent = t.label;
          if (t.value === currentValue) opt.selected = true;
          selectEl.appendChild(opt);
        });

        // Find closest if no exact match
        if (currentValue && !selectEl.value) {
          const targetMins = this.timeToMinutes(currentValue);
          let closest = times[0]?.value;
          let minDiff = Infinity;
          times.forEach(t => {
            const diff = Math.abs(this.timeToMinutes(t.value) - targetMins);
            if (diff < minDiff) {
              minDiff = diff;
              closest = t.value;
            }
          });
          selectEl.value = closest;
        }
      },

      timeToMinutes(timeStr) {
        if (!timeStr) return 0;
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + (m || 0);
      },

      initAll(container = document) {
        container.querySelectorAll('select[data-time-picker]').forEach(el => {
          if (el.options.length === 0) {
            const opts = {};
            if (el.dataset.default) opts.defaultValue = el.dataset.default;
            this.populateSelect(el, opts);
          }
        });
      }
    };

    // ==================== TRANSLATIONS ====================
    const translations = {
      en: {
        teeSheet: "Tee Sheet", language: "LANGUAGE", golfCourse: "GOLF COURSE", date: "DATE", courseLayout: "COURSE LAYOUT",
        start: "START", end: "END", interval: "INTERVAL", teesCourse: "TEES/COURSE", search: "SEARCH",
        find: "Find", next: "Next", clearDay: "Clear Day",
        courseA: "Course A", courseB: "Course B", courseC: "Course C", courseD: "Course D",
        regular: "Regular", vip: "VIP", society: "Society", tournament: "Tournament",
        bookSlot: "Book Slot", bookingType: "Booking Type", course: "Course", tee: "Tee", time: "Time",
        golfers: "Golfers", addGolfer: "+ Add Golfer",
        golferName: "Golfer Name", caddy: "Caddy", searchCaddy: "Search caddy...", noCaddy: "No Caddy",
        notes: "Notes", delete: "Delete", cancel: "Cancel", save: "Save",
        searchPlaceholder: "Golfer or caddy...", confirmClear: "Clear all bookings for this day?",
        noMatches: "No matches found.", player: "Player",
        blockTimeRange: "Block Time Range", rangeHint: "For society/group bookings",
        startTime: "Start Time", endTime: "End Time", groupName: "Group / Society Name",
        timeSlots: "Time Slots", slotsCount: "{n} slots", noGolfers: "No golfers assigned",
        deleteGroup: "Delete Entire Group", confirmDeleteGroup: "Delete all {n} slots in this group?",
        booked: "BOOKED", caddyAlreadyBooked: "This caddy is already booked for this time",
        caddyInGroup: "This caddy is already assigned to another golfer in this group",
        inGroup: "IN GROUP", selectCourse: "Select Course", noDatesSelected: "No dates selected",
        // Recurring booking translations
        recurringBooking: "Recurring Booking", recurringHint: "For standing tee times",
        repeatFrequency: "Repeat", repeatUntil: "Until", occurrences: "Or # of times",
        repeatOn: "Repeat on:", daily: "Daily", weekly: "Weekly", biweekly: "Every 2 Weeks", monthly: "Monthly",
        sun: "Sun", mon: "Mon", tue: "Tue", wed: "Wed", thu: "Thu", fri: "Fri", sat: "Sat",
        recurringPreview: "Will create {n} bookings through {date}",
        // Settings translations
        settings: "Settings", teeSheetSettings: "Tee Sheet Settings", courseConfig: "Course Configuration",
        pricing: "Green Fees & Pricing", services: "Caddy & Cart", packages: "Packages & Promotions",
        courseDetails: "Course Details", operatingHours: "Operating Hours", firstTeeTime: "First Tee Time",
        lastTeeTime: "Last Tee Time", roundDuration: "Round Duration (hrs)", weekdayPricing: "Weekday Pricing (Mon-Fri)",
        weekendPricing: "Weekend/Holiday Pricing (Sat-Sun)", peak: "Peak", offPeak: "Off-Peak", twilight: "Twilight",
        addPeriod: "Add Time Period", caddyFees: "Caddy Fees", caddyFee18: "18 Holes Caddy Fee",
        caddyFee9: "9 Holes Caddy Fee", caddyTip: "Suggested Caddy Tip", cartFees: "Golf Cart Fees",
        cartFee18: "18 Holes Cart Fee", cartFee9: "9 Holes Cart Fee", cartSharing: "Cart Sharing",
        otherServices: "Other Services", clubRental: "Club Rental", shoeRental: "Shoe Rental",
        rangeBalls: "Range Balls (bucket)", societyRates: "Society / Group Rates", minGroupSize: "Minimum Group Size",
        societyDiscount: "Discount (%)", freeSlots: "Free Slots per Group", promotionalPackages: "Promotional Packages",
        greenFee: "Green Fee", includesCaddy: "Includes Caddy", includesCart: "Includes Cart",
        validDays: "Valid Days", validFrom: "Valid From", validUntil: "Valid Until", addPackage: "Add Package",
        currentSettings: "Current Settings Summary", layout: "Layout", hours: "Hours", saveSettings: "Save Settings",
        yes: "Yes", no: "No", min: "min",
        // Additional settings translations
        singleRiderOnly: "Single Rider Only", sharedCart: "Shared (2 riders)", bothOptions: "Both Options",
        monFri: "Mon-Fri", satSun: "Sat-Sun", allDays: "All Days",
        packageName: "Package Name", weekdaySpecial: "Weekday Special", twilightDeal: "Twilight Deal"
      },
      th: {
        teeSheet: "‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü", language: "‡∏†‡∏≤‡∏©‡∏≤", golfCourse: "‡∏™‡∏ô‡∏≤‡∏°‡∏Å‡∏≠‡∏•‡πå‡∏ü", date: "‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà", courseLayout: "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏≠‡∏£‡πå‡∏™",
        start: "‡πÄ‡∏£‡∏¥‡πà‡∏°", end: "‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î", interval: "‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤", teesCourse: "‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü/‡∏Ñ‡∏≠‡∏£‡πå‡∏™", search: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤",
        find: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤", next: "‡∏ñ‡∏±‡∏î‡πÑ‡∏õ", clearDay: "‡∏•‡πâ‡∏≤‡∏á‡∏ß‡∏±‡∏ô",
        courseA: "‡∏Ñ‡∏≠‡∏£‡πå‡∏™ A", courseB: "‡∏Ñ‡∏≠‡∏£‡πå‡∏™ B", courseC: "‡∏Ñ‡∏≠‡∏£‡πå‡∏™ C", courseD: "‡∏Ñ‡∏≠‡∏£‡πå‡∏™ D",
        regular: "‡∏õ‡∏Å‡∏ï‡∏¥", vip: "VIP", society: "‡∏Å‡∏•‡∏∏‡πà‡∏°", tournament: "‡∏ó‡∏±‡∏ß‡∏£‡πå‡∏ô‡∏≤‡πÄ‡∏°‡∏ô‡∏ï‡πå",
        bookSlot: "‡∏à‡∏≠‡∏á‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤", bookingType: "‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á", course: "‡∏Ñ‡∏≠‡∏£‡πå‡∏™", tee: "‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü", time: "‡πÄ‡∏ß‡∏•‡∏≤",
        golfers: "‡∏ô‡∏±‡∏Å‡∏Å‡∏≠‡∏•‡πå‡∏ü", addGolfer: "+ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏Å‡∏Å‡∏≠‡∏•‡πå‡∏ü",
        golferName: "‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡∏Å‡∏≠‡∏•‡πå‡∏ü", caddy: "‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ", searchCaddy: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ...", noCaddy: "‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ",
        notes: "‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏", delete: "‡∏•‡∏ö", cancel: "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", save: "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å",
        searchPlaceholder: "‡∏ô‡∏±‡∏Å‡∏Å‡∏≠‡∏•‡πå‡∏ü‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ...", confirmClear: "‡∏•‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ?",
        noMatches: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå", player: "‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
        blockTimeRange: "‡∏à‡∏≠‡∏á‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤", rangeHint: "‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏±‡∏á‡∏Ñ‡∏°",
        startTime: "‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", endTime: "‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î", groupName: "‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏∏‡πà‡∏° / ‡∏™‡∏±‡∏á‡∏Ñ‡∏°",
        timeSlots: "‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤", slotsCount: "{n} ‡∏ä‡πà‡∏ß‡∏á", noGolfers: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ô‡∏±‡∏Å‡∏Å‡∏≠‡∏•‡πå‡∏ü",
        deleteGroup: "‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°", confirmDeleteGroup: "‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î {n} ‡∏ä‡πà‡∏ß‡∏á‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ?",
        booked: "‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß", caddyAlreadyBooked: "‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ô‡∏µ‡πâ‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ",
        caddyInGroup: "‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏Å‡∏≠‡∏•‡πå‡∏ü‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß",
        inGroup: "‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°", selectCourse: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏ô‡∏≤‡∏°", noDatesSelected: "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà",
        // Recurring booking translations
        recurringBooking: "‡∏à‡∏≠‡∏á‡∏ã‡πâ‡∏≥", recurringHint: "‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü‡∏õ‡∏£‡∏∞‡∏à‡∏≥",
        repeatFrequency: "‡∏ó‡∏≥‡∏ã‡πâ‡∏≥", repeatUntil: "‡∏à‡∏ô‡∏ñ‡∏∂‡∏á", occurrences: "‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
        repeatOn: "‡∏ó‡∏≥‡∏ã‡πâ‡∏≥‡∏ß‡∏±‡∏ô:", daily: "‡∏ó‡∏∏‡∏Å‡∏ß‡∏±‡∏ô", weekly: "‡∏ó‡∏∏‡∏Å‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå", biweekly: "‡∏ó‡∏∏‡∏Å 2 ‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå", monthly: "‡∏ó‡∏∏‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô",
        sun: "‡∏≠‡∏≤", mon: "‡∏à", tue: "‡∏≠", wed: "‡∏û", thu: "‡∏û‡∏§", fri: "‡∏®", sat: "‡∏™",
        recurringPreview: "‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á {n} ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ñ‡∏∂‡∏á {date}",
        // Settings translations
        settings: "‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤", teeSheetSettings: "‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü", courseConfig: "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏£‡πå‡∏™",
        pricing: "‡∏Ñ‡πà‡∏≤‡∏Å‡∏£‡∏µ‡∏ô‡∏ü‡∏µ & ‡∏£‡∏≤‡∏Ñ‡∏≤", services: "‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ & ‡∏£‡∏ñ‡∏Å‡∏≠‡∏•‡πå‡∏ü", packages: "‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏Å‡∏à & ‡πÇ‡∏õ‡∏£‡πÇ‡∏°‡∏ä‡∏±‡πà‡∏ô",
        courseDetails: "‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ñ‡∏≠‡∏£‡πå‡∏™", operatingHours: "‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏Å‡∏≤‡∏£", firstTeeTime: "‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü‡πÅ‡∏£‡∏Å",
        lastTeeTime: "‡∏ó‡∏µ‡∏≠‡∏≠‡∏ü‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢", roundDuration: "‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏ö (‡∏ä‡∏°.)", weekdayPricing: "‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ß‡∏±‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤ (‡∏à-‡∏®)",
        weekendPricing: "‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ß‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î (‡∏™-‡∏≠‡∏≤)", peak: "‡∏ä‡πà‡∏ß‡∏á‡∏û‡∏µ‡∏Ñ", offPeak: "‡∏ô‡∏≠‡∏Å‡∏û‡∏µ‡∏Ñ", twilight: "‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏¢‡πá‡∏ô",
        addPeriod: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤", caddyFees: "‡∏Ñ‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ", caddyFee18: "‡∏Ñ‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ 18 ‡∏´‡∏•‡∏∏‡∏°",
        caddyFee9: "‡∏Ñ‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ 9 ‡∏´‡∏•‡∏∏‡∏°", caddyTip: "‡∏ó‡∏¥‡∏õ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥", cartFees: "‡∏Ñ‡πà‡∏≤‡∏£‡∏ñ‡∏Å‡∏≠‡∏•‡πå‡∏ü",
        cartFee18: "‡∏Ñ‡πà‡∏≤‡∏£‡∏ñ 18 ‡∏´‡∏•‡∏∏‡∏°", cartFee9: "‡∏Ñ‡πà‡∏≤‡∏£‡∏ñ 9 ‡∏´‡∏•‡∏∏‡∏°", cartSharing: "‡πÉ‡∏ä‡πâ‡∏£‡∏ñ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô",
        otherServices: "‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏≠‡∏∑‡πà‡∏ô‡πÜ", clubRental: "‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏°‡πâ‡∏Å‡∏≠‡∏•‡πå‡∏ü", shoeRental: "‡πÄ‡∏ä‡πà‡∏≤‡∏£‡∏≠‡∏á‡πÄ‡∏ó‡πâ‡∏≤",
        rangeBalls: "‡∏•‡∏π‡∏Å‡∏ã‡πâ‡∏≠‡∏° (‡∏ï‡∏∞‡∏Å‡∏£‡πâ‡∏≤)", societyRates: "‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Å‡∏•‡∏∏‡πà‡∏°", minGroupSize: "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥",
        societyDiscount: "‡∏™‡πà‡∏ß‡∏ô‡∏•‡∏î (%)", freeSlots: "‡∏ü‡∏£‡∏µ‡∏ï‡πà‡∏≠‡∏Å‡∏•‡∏∏‡πà‡∏°", promotionalPackages: "‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏Å‡∏à‡πÇ‡∏õ‡∏£‡πÇ‡∏°‡∏ä‡∏±‡πà‡∏ô",
        greenFee: "‡∏Ñ‡πà‡∏≤‡∏Å‡∏£‡∏µ‡∏ô‡∏ü‡∏µ", includesCaddy: "‡∏£‡∏ß‡∏°‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ", includesCart: "‡∏£‡∏ß‡∏°‡∏£‡∏ñ‡∏Å‡∏≠‡∏•‡πå‡∏ü",
        validDays: "‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ", validFrom: "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà", validUntil: "‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà", addPackage: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏Å‡∏à",
        currentSettings: "‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤", layout: "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö", hours: "‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á", saveSettings: "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤",
        yes: "‡πÉ‡∏ä‡πà", no: "‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà", min: "‡∏ô‡∏≤‡∏ó‡∏µ",
        // Additional settings translations
        singleRiderOnly: "‡πÑ‡∏£‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß", sharedCart: "‡πÅ‡∏ä‡∏£‡πå‡∏£‡∏ñ (2 ‡∏Ñ‡∏ô)", bothOptions: "‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÅ‡∏ö‡∏ö",
        monFri: "‡∏à-‡∏®", satSun: "‡∏™-‡∏≠‡∏≤", allDays: "‡∏ó‡∏∏‡∏Å‡∏ß‡∏±‡∏ô",
        packageName: "‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏û‡πá‡∏Ñ‡πÄ‡∏Å‡∏à", weekdaySpecial: "‡πÇ‡∏õ‡∏£‡∏ß‡∏±‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤", twilightDeal: "‡πÇ‡∏õ‡∏£‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏¢‡πá‡∏ô"
      },
      ko: {
        teeSheet: "Ìã∞ ÏãúÌä∏", language: "Ïñ∏Ïñ¥", golfCourse: "Í≥®ÌîÑÏû•", date: "ÎÇ†Ïßú", courseLayout: "ÏΩîÏä§ Î†àÏù¥ÏïÑÏõÉ",
        start: "ÏãúÏûë", end: "Ï¢ÖÎ£å", interval: "Í∞ÑÍ≤©", teesCourse: "Ìã∞/ÏΩîÏä§", search: "Í≤ÄÏÉâ",
        find: "Í≤ÄÏÉâ", next: "Îã§Ïùå", clearDay: "ÏùºÏùº ÏÇ≠Ï†ú",
        courseA: "ÏΩîÏä§ A", courseB: "ÏΩîÏä§ B", courseC: "ÏΩîÏä§ C", courseD: "ÏΩîÏä§ D",
        regular: "ÏùºÎ∞ò", vip: "VIP", society: "Îã®Ï≤¥", tournament: "ÌÜ†ÎÑàÎ®ºÌä∏",
        bookSlot: "Ïä¨Î°Ø ÏòàÏïΩ", bookingType: "ÏòàÏïΩ Ïú†Ìòï", course: "ÏΩîÏä§", tee: "Ìã∞", time: "ÏãúÍ∞Ñ",
        golfers: "Í≥®Ìçº", addGolfer: "+ Í≥®Ìçº Ï∂îÍ∞Ä",
        golferName: "Í≥®Ìçº Ïù¥Î¶Ñ", caddy: "Ï∫êÎîî", searchCaddy: "Ï∫êÎîî Í≤ÄÏÉâ...", noCaddy: "Ï∫êÎîî ÏóÜÏùå",
        notes: "Î©îÎ™®", delete: "ÏÇ≠Ï†ú", cancel: "Ï∑®ÏÜå", save: "Ï†ÄÏû•",
        searchPlaceholder: "Í≥®Ìçº ÎòêÎäî Ï∫êÎîî...", confirmClear: "Ïò§Îäò ÏòàÏïΩÏùÑ Î™®Îëê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        noMatches: "Í≤∞Í≥ºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", player: "ÌîåÎ†àÏù¥Ïñ¥",
        blockTimeRange: "ÏãúÍ∞ÑÎåÄ Ï∞®Îã®", rangeHint: "Îã®Ï≤¥/Í∑∏Î£π ÏòàÏïΩÏö©",
        startTime: "ÏãúÏûë ÏãúÍ∞Ñ", endTime: "Ï¢ÖÎ£å ÏãúÍ∞Ñ", groupName: "Í∑∏Î£π/Îã®Ï≤¥ Ïù¥Î¶Ñ",
        timeSlots: "ÏãúÍ∞ÑÎåÄ", slotsCount: "{n}Í∞ú Ïä¨Î°Ø", noGolfers: "Í≥®Ìçº ÎØ∏Î∞∞Ï†ï",
        deleteGroup: "Í∑∏Î£π Ï†ÑÏ≤¥ ÏÇ≠Ï†ú", confirmDeleteGroup: "Ïù¥ Í∑∏Î£πÏùò {n}Í∞ú Ïä¨Î°ØÏùÑ Î™®Îëê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        booked: "ÏòàÏïΩÎê®", caddyAlreadyBooked: "Ïù¥ Ï∫êÎîîÎäî Ìï¥Îãπ ÏãúÍ∞ÑÏóê Ïù¥ÎØ∏ ÏòàÏïΩÎêòÏñ¥ ÏûàÏäµÎãàÎã§",
        caddyInGroup: "Ïù¥ Ï∫êÎîîÎäî Ïù¥ÎØ∏ Í∑∏Î£π ÎÇ¥ Îã§Î•∏ Í≥®ÌçºÏóêÍ≤å Î∞∞Ï†ïÎêòÏóàÏäµÎãàÎã§",
        inGroup: "Í∑∏Î£πÎÇ¥", selectCourse: "ÏΩîÏä§ ÏÑ†ÌÉù", noDatesSelected: "ÎÇ†Ïßú ÏÑ†ÌÉù ÏïàÎê®",
        // Recurring booking translations
        recurringBooking: "Î∞òÎ≥µ ÏòàÏïΩ", recurringHint: "Ï†ïÍ∏∞ Ìã∞ÌÉÄÏûÑÏö©",
        repeatFrequency: "Î∞òÎ≥µ", repeatUntil: "ÍπåÏßÄ", occurrences: "ÎòêÎäî ÌöüÏàò",
        repeatOn: "Î∞òÎ≥µ ÏöîÏùº:", daily: "Îß§Ïùº", weekly: "Îß§Ï£º", biweekly: "2Ï£ºÎßàÎã§", monthly: "Îß§Ïõî",
        sun: "Ïùº", mon: "Ïõî", tue: "Ìôî", wed: "Ïàò", thu: "Î™©", fri: "Í∏à", sat: "ÌÜ†",
        recurringPreview: "{date}ÍπåÏßÄ {n}Í∞ú ÏòàÏïΩ ÏÉùÏÑ±",
        // Settings translations
        settings: "ÏÑ§Ï†ï", teeSheetSettings: "Ìã∞ ÏãúÌä∏ ÏÑ§Ï†ï", courseConfig: "ÏΩîÏä§ ÏÑ§Ï†ï",
        pricing: "Í∑∏Î¶∞Ìîº & ÏöîÍ∏à", services: "Ï∫êÎîî & Ïπ¥Ìä∏", packages: "Ìå®ÌÇ§ÏßÄ & ÌîÑÎ°úÎ™®ÏÖò",
        courseDetails: "ÏΩîÏä§ Ï†ïÎ≥¥", operatingHours: "Ïö¥ÏòÅ ÏãúÍ∞Ñ", firstTeeTime: "Ï≤´ Ìã∞ ÌÉÄÏûÑ",
        lastTeeTime: "ÎßàÏßÄÎßâ Ìã∞ ÌÉÄÏûÑ", roundDuration: "ÎùºÏö¥Îìú ÏãúÍ∞Ñ (Ïãú)", weekdayPricing: "ÌèâÏùº ÏöîÍ∏à (Ïõî-Í∏à)",
        weekendPricing: "Ï£ºÎßê/Í≥µÌú¥Ïùº ÏöîÍ∏à (ÌÜ†-Ïùº)", peak: "ÌîºÌÅ¨", offPeak: "Ïò§ÌîÑÌîºÌÅ¨", twilight: "Ìä∏ÏôÄÏùºÎùºÏûá",
        addPeriod: "ÏãúÍ∞ÑÎåÄ Ï∂îÍ∞Ä", caddyFees: "Ï∫êÎîî ÏöîÍ∏à", caddyFee18: "18ÌôÄ Ï∫êÎîî ÏöîÍ∏à",
        caddyFee9: "9ÌôÄ Ï∫êÎîî ÏöîÍ∏à", caddyTip: "Í∂åÏû• Ï∫êÎîî ÌåÅ", cartFees: "Ïπ¥Ìä∏ ÏöîÍ∏à",
        cartFee18: "18ÌôÄ Ïπ¥Ìä∏ ÏöîÍ∏à", cartFee9: "9ÌôÄ Ïπ¥Ìä∏ ÏöîÍ∏à", cartSharing: "Ïπ¥Ìä∏ Í≥µÏú†",
        otherServices: "Í∏∞ÌÉÄ ÏÑúÎπÑÏä§", clubRental: "ÌÅ¥ÎüΩ Î†åÌÉà", shoeRental: "Ïã†Î∞ú Î†åÌÉà",
        rangeBalls: "Ïó∞ÏäµÍµ¨ (Î≤ÑÌÇ∑)", societyRates: "Îã®Ï≤¥ ÏöîÍ∏à", minGroupSize: "ÏµúÏÜå Í∑∏Î£π Ïù∏Ïõê",
        societyDiscount: "Ìï†Ïù∏ (%)", freeSlots: "Í∑∏Î£πÎãπ Î¨¥Î£å Ïä¨Î°Ø", promotionalPackages: "ÌîÑÎ°úÎ™®ÏÖò Ìå®ÌÇ§ÏßÄ",
        greenFee: "Í∑∏Î¶∞Ìîº", includesCaddy: "Ï∫êÎîî Ìè¨Ìï®", includesCart: "Ïπ¥Ìä∏ Ìè¨Ìï®",
        validDays: "Ïú†Ìö® ÏöîÏùº", validFrom: "ÏãúÏûë ÏãúÍ∞Ñ", validUntil: "Ï¢ÖÎ£å ÏãúÍ∞Ñ", addPackage: "Ìå®ÌÇ§ÏßÄ Ï∂îÍ∞Ä",
        currentSettings: "ÌòÑÏû¨ ÏÑ§Ï†ï ÏöîÏïΩ", layout: "Î†àÏù¥ÏïÑÏõÉ", hours: "ÏãúÍ∞Ñ", saveSettings: "ÏÑ§Ï†ï Ï†ÄÏû•",
        yes: "Ïòà", no: "ÏïÑÎãàÏò§", min: "Î∂Ñ",
        // Additional settings translations
        singleRiderOnly: "1Ïù∏ ÌÉëÏäπÎßå", sharedCart: "Í≥µÏú† (2Ïù∏)", bothOptions: "Îëê ÏòµÏÖò Î™®Îëê",
        monFri: "Ïõî-Í∏à", satSun: "ÌÜ†-Ïùº", allDays: "Îß§Ïùº",
        packageName: "Ìå®ÌÇ§ÏßÄ Ïù¥Î¶Ñ", weekdaySpecial: "ÌèâÏùº Ïä§ÌéòÏÖú", twilightDeal: "Ìä∏ÏôÄÏùºÎùºÏûá Îîú"
      },
      ja: {
        teeSheet: "„ÉÜ„Ç£„Éº„Ç∑„Éº„Éà", language: "Ë®ÄË™û", golfCourse: "„Ç¥„É´„ÉïÂ†¥", date: "Êó•‰ªò", courseLayout: "„Ç≥„Éº„Çπ„É¨„Ç§„Ç¢„Ç¶„Éà",
        start: "ÈñãÂßã", end: "ÁµÇ‰∫Ü", interval: "ÈñìÈöî", teesCourse: "„ÉÜ„Ç£„Éº/„Ç≥„Éº„Çπ", search: "Ê§úÁ¥¢",
        find: "Ê§úÁ¥¢", next: "Ê¨°„Å∏", clearDay: "Êó•‰ªò„ÇØ„É™„Ç¢",
        courseA: "„Ç≥„Éº„Çπ A", courseB: "„Ç≥„Éº„Çπ B", courseC: "„Ç≥„Éº„Çπ C", courseD: "„Ç≥„Éº„Çπ D",
        regular: "‰∏ÄËà¨", vip: "VIP", society: "Âõ£‰Ωì", tournament: "„Éà„Éº„Éä„É°„É≥„Éà",
        bookSlot: "„Çπ„É≠„ÉÉ„Éà‰∫àÁ¥Ñ", bookingType: "‰∫àÁ¥Ñ„Çø„Ç§„Éó", course: "„Ç≥„Éº„Çπ", tee: "„ÉÜ„Ç£„Éº", time: "ÊôÇÈñì",
        golfers: "„Ç¥„É´„Éï„Ç°„Éº", addGolfer: "+ „Ç¥„É´„Éï„Ç°„ÉºËøΩÂä†",
        golferName: "„Ç¥„É´„Éï„Ç°„ÉºÂêç", caddy: "„Ç≠„É£„Éá„Ç£„Éº", searchCaddy: "„Ç≠„É£„Éá„Ç£„ÉºÊ§úÁ¥¢...", noCaddy: "„Ç≠„É£„Éá„Ç£„Éº„Å™„Åó",
        notes: "„É°„É¢", delete: "ÂâäÈô§", cancel: "„Ç≠„É£„É≥„Çª„É´", save: "‰øùÂ≠ò",
        searchPlaceholder: "„Ç¥„É´„Éï„Ç°„Éº„Åæ„Åü„ÅØ„Ç≠„É£„Éá„Ç£„Éº...", confirmClear: "Êú¨Êó•„ÅÆ‰∫àÁ¥Ñ„Çí„Åô„Åπ„Å¶ÂâäÈô§„Åó„Åæ„Åô„Åã?",
        noMatches: "ÁµêÊûú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", player: "„Éó„É¨„Ç§„É§„Éº",
        blockTimeRange: "ÊôÇÈñìÂ∏Ø„Çí„Éñ„É≠„ÉÉ„ÇØ", rangeHint: "Âõ£‰Ωì/„Ç∞„É´„Éº„Éó‰∫àÁ¥ÑÁî®",
        startTime: "ÈñãÂßãÊôÇÈñì", endTime: "ÁµÇ‰∫ÜÊôÇÈñì", groupName: "„Ç∞„É´„Éº„Éó/Âõ£‰ΩìÂêç",
        timeSlots: "„Çø„Ç§„É†„Çπ„É≠„ÉÉ„Éà", slotsCount: "{n}„Çπ„É≠„ÉÉ„Éà", noGolfers: "„Ç¥„É´„Éï„Ç°„ÉºÊú™Ââ≤ÂΩì",
        deleteGroup: "„Ç∞„É´„Éº„ÉóÂÖ®‰Ωì„ÇíÂâäÈô§", confirmDeleteGroup: "„Åì„ÅÆ„Ç∞„É´„Éº„Éó„ÅÆ{n}„Çπ„É≠„ÉÉ„Éà„Çí„Åô„Åπ„Å¶ÂâäÈô§„Åó„Åæ„Åô„Åã?",
        booked: "‰∫àÁ¥ÑÊ∏à", caddyAlreadyBooked: "„Åì„ÅÆ„Ç≠„É£„Éá„Ç£„Éº„ÅØ„Åì„ÅÆÊôÇÈñì„Å´Êó¢„Å´‰∫àÁ¥Ñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô",
        caddyInGroup: "„Åì„ÅÆ„Ç≠„É£„Éá„Ç£„Éº„ÅØÊó¢„Å´„Ç∞„É´„Éº„ÉóÂÜÖ„ÅÆÂà•„ÅÆ„Ç¥„É´„Éï„Ç°„Éº„Å´Ââ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô",
        inGroup: "„Ç∞„É´„Éº„ÉóÂÜÖ", selectCourse: "„Ç≥„Éº„ÇπÈÅ∏Êäû", noDatesSelected: "Êó•‰ªòÊú™ÈÅ∏Êäû",
        // Recurring booking translations
        recurringBooking: "Áπ∞„ÇäËøî„Åó‰∫àÁ¥Ñ", recurringHint: "ÂÆöÊúü„ÉÜ„Ç£„Éº„Çø„Ç§„É†Áî®",
        repeatFrequency: "Áπ∞„ÇäËøî„Åó", repeatUntil: "„Åæ„Åß", occurrences: "„Åæ„Åü„ÅØÂõûÊï∞",
        repeatOn: "Áπ∞„ÇäËøî„ÅóÊõúÊó•:", daily: "ÊØéÊó•", weekly: "ÊØéÈÄ±", biweekly: "ÈöîÈÄ±", monthly: "ÊØéÊúà",
        sun: "Êó•", mon: "Êúà", tue: "ÁÅ´", wed: "Ê∞¥", thu: "Êú®", fri: "Èáë", sat: "Âúü",
        recurringPreview: "{date}„Åæ„Åß{n}‰ª∂„ÅÆ‰∫àÁ¥Ñ„Çí‰ΩúÊàê",
        // Settings translations
        settings: "Ë®≠ÂÆö", teeSheetSettings: "„ÉÜ„Ç£„Éº„Ç∑„Éº„ÉàË®≠ÂÆö", courseConfig: "„Ç≥„Éº„ÇπË®≠ÂÆö",
        pricing: "„Ç∞„É™„Éº„É≥„Éï„Ç£„Éº & ÊñôÈáë", services: "„Ç≠„É£„Éá„Ç£„Éº & „Ç´„Éº„Éà", packages: "„Éë„ÉÉ„Ç±„Éº„Ç∏ & „Éó„É≠„É¢„Éº„Ç∑„Éß„É≥",
        courseDetails: "„Ç≥„Éº„ÇπË©≥Á¥∞", operatingHours: "Âñ∂Ê•≠ÊôÇÈñì", firstTeeTime: "ÊúÄÂàù„ÅÆ„ÉÜ„Ç£„Éº„Çø„Ç§„É†",
        lastTeeTime: "ÊúÄÂæå„ÅÆ„ÉÜ„Ç£„Éº„Çø„Ç§„É†", roundDuration: "„É©„Ç¶„É≥„ÉâÊôÇÈñì (ÊôÇ)", weekdayPricing: "Âπ≥Êó•ÊñôÈáë (Êúà-Èáë)",
        weekendPricing: "ÈÄ±Êú´/Á•ùÊó•ÊñôÈáë (Âúü-Êó•)", peak: "„Éî„Éº„ÇØ", offPeak: "„Ç™„Éï„Éî„Éº„ÇØ", twilight: "„Éà„ÉØ„Ç§„É©„Ç§„Éà",
        addPeriod: "ÊôÇÈñìÂ∏Ø„ÇíËøΩÂä†", caddyFees: "„Ç≠„É£„Éá„Ç£„ÉºÊñôÈáë", caddyFee18: "18„Éõ„Éº„É´ „Ç≠„É£„Éá„Ç£„ÉºÊñôÈáë",
        caddyFee9: "9„Éõ„Éº„É´ „Ç≠„É£„Éá„Ç£„ÉºÊñôÈáë", caddyTip: "Êé®Â•®„Ç≠„É£„Éá„Ç£„Éº„ÉÅ„ÉÉ„Éó", cartFees: "„Ç´„Éº„ÉàÊñôÈáë",
        cartFee18: "18„Éõ„Éº„É´ „Ç´„Éº„ÉàÊñôÈáë", cartFee9: "9„Éõ„Éº„É´ „Ç´„Éº„ÉàÊñôÈáë", cartSharing: "„Ç´„Éº„ÉàÂÖ±Êúâ",
        otherServices: "„Åù„ÅÆ‰ªñ„Çµ„Éº„Éì„Çπ", clubRental: "„ÇØ„É©„Éñ„É¨„É≥„Çø„É´", shoeRental: "„Ç∑„É•„Éº„Ç∫„É¨„É≥„Çø„É´",
        rangeBalls: "Á∑¥ÁøíÁêÉ („Éê„Ç±„ÉÑ)", societyRates: "Âõ£‰ΩìÊñôÈáë", minGroupSize: "ÊúÄÂ∞è„Ç∞„É´„Éº„Éó„Çµ„Ç§„Ç∫",
        societyDiscount: "Ââ≤Âºï (%)", freeSlots: "„Ç∞„É´„Éº„ÉóÊØé„ÅÆÁÑ°Êñô„Çπ„É≠„ÉÉ„Éà", promotionalPackages: "„Éó„É≠„É¢„Éº„Ç∑„Éß„É≥„Éë„ÉÉ„Ç±„Éº„Ç∏",
        greenFee: "„Ç∞„É™„Éº„É≥„Éï„Ç£„Éº", includesCaddy: "„Ç≠„É£„Éá„Ç£„ÉºÂê´„ÇÄ", includesCart: "„Ç´„Éº„ÉàÂê´„ÇÄ",
        validDays: "ÊúâÂäπÊõúÊó•", validFrom: "ÈñãÂßã", validUntil: "ÁµÇ‰∫Ü", addPackage: "„Éë„ÉÉ„Ç±„Éº„Ç∏ËøΩÂä†",
        currentSettings: "ÁèæÂú®„ÅÆË®≠ÂÆöÊ¶ÇË¶Å", layout: "„É¨„Ç§„Ç¢„Ç¶„Éà", hours: "ÊôÇÈñì", saveSettings: "Ë®≠ÂÆö„Çí‰øùÂ≠ò",
        yes: "„ÅØ„ÅÑ", no: "„ÅÑ„ÅÑ„Åà", min: "ÂàÜ",
        // Additional settings translations
        singleRiderOnly: "„Ç∑„É≥„Ç∞„É´„É©„Ç§„ÉÄ„Éº„ÅÆ„Åø", sharedCart: "ÂÖ±ÊúâÔºà2‰∫∫Ôºâ", bothOptions: "‰∏°Êñπ",
        monFri: "Êúà-Èáë", satSun: "ÂúüÊó•", allDays: "ÊØéÊó•",
        packageName: "„Éë„ÉÉ„Ç±„Éº„Ç∏Âêç", weekdaySpecial: "Âπ≥Êó•„Çπ„Éö„Ç∑„É£„É´", twilightDeal: "„Éà„ÉØ„Ç§„É©„Ç§„Éà„Éá„Ç£„Éº„É´"
      }
    };

    let currentLang = localStorage.getItem('teesheet.lang') || 'en';

    function t(key) {
      return (translations[currentLang] && translations[currentLang][key]) || translations.en[key] || key;
    }

    function applyTranslations() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        el.textContent = t(el.dataset.i18n);
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        el.placeholder = t(el.dataset.i18nPlaceholder);
      });
    }

    // ==================== PARENT BRIDGE ====================
    // Bridge to parent window's CaddySystem and BookingManager
    const ParentBridge = {
      // Get reference to parent window (for iframe context)
      getParent() {
        try {
          return window.parent !== window ? window.parent : window;
        } catch (e) {
          return window;
        }
      },

      // Get CaddySystem from parent or current window
      getCaddySystem() {
        const parent = this.getParent();
        return parent.CaddySystem || window.CaddySystem || null;
      },

      // Get BookingManager from parent or current window
      getBookingManager() {
        const parent = this.getParent();
        return parent.BookingManager || window.BookingManager || null;
      },

      // Get SimpleCloudSync for Supabase sync
      getCloudSync() {
        const parent = this.getParent();
        return parent.SimpleCloudSync || window.SimpleCloudSync || null;
      },

      // Get all caddies, optionally filtered by course
      getAllCaddies(courseId = null) {
        const caddySystem = this.getCaddySystem();
        if (!caddySystem || !caddySystem.allCaddys) {
          console.warn('[TeeSheet] CaddySystem not found in parent window');
          return [];
        }

        let caddies = caddySystem.allCaddys;

        // Filter by course (homeClub) if specified
        if (courseId) {
          caddies = caddies.filter(c => c.homeClub === courseId);
        }

        // Map to expected format for dropdown
        return caddies.map(c => ({
          id: c.id,
          name: c.name,
          localName: c.localName || '',
          number: c.number,
          rating: c.rating || 4.5,
          language: Array.isArray(c.languages) ? c.languages.join('/') : (c.languages || 'TH/EN'),
          status: c.availability === 'booked' ? 'busy' : 'available',
          homeClub: c.homeClub
        }));
      },

      // Sync booking to parent BookingManager and cloud
      async syncBookingToParent(booking, action = 'new_booking') {
        const bookingManager = this.getBookingManager();
        const cloudSync = this.getCloudSync();

        if (bookingManager) {
          // Find if booking exists, update or add
          const existingIdx = bookingManager.bookings.findIndex(b => b.id === booking.id);

          if (existingIdx >= 0) {
            bookingManager.bookings[existingIdx] = booking;
          } else {
            bookingManager.bookings.push(booking);
          }

          // CRITICAL: Save to localStorage so Schedule tab can read it
          if (typeof bookingManager.saveToLocalStorage === 'function') {
            bookingManager.saveToLocalStorage();
            console.log('[TeeSheet] Saved to localStorage');
          }

          // Trigger cloud sync
          if (cloudSync && typeof cloudSync.saveToCloud === 'function') {
            try {
              await cloudSync.saveToCloud();
              console.log('[TeeSheet] Booking synced to cloud');
            } catch (e) {
              console.warn('[TeeSheet] Cloud sync failed:', e);
            }
          }

          // Trigger caddy notifications for booking changes
          await this.notifyCaddyBooking(booking, action);

          console.log('[TeeSheet] Booking synced to parent BookingManager');
          return true;
        } else {
          // No BookingManager (standalone mode) - save directly to localStorage
          try {
            const bookings = JSON.parse(localStorage.getItem('mcipro_bookings') || '[]');
            const existingIdx = bookings.findIndex(b => b.id === booking.id);

            if (existingIdx >= 0) {
              bookings[existingIdx] = booking;
            } else {
              bookings.push(booking);
            }

            localStorage.setItem('mcipro_bookings', JSON.stringify(bookings));
            console.log('[TeeSheet] Booking saved directly to localStorage (standalone mode)');

            // Trigger caddy notifications for booking changes
            await this.notifyCaddyBooking(booking, action);

            return true;
          } catch (e) {
            console.error('[TeeSheet] Failed to save booking to localStorage:', e);
            return false;
          }
        }
      },

      // Remove booking from parent BookingManager and sync to cloud
      async removeBookingFromParent(bookingId) {
        const bookingManager = this.getBookingManager();
        const cloudSync = this.getCloudSync();

        // Also remove with teesheet- prefix variant
        const teesheetId = bookingId.startsWith('teesheet-') ? bookingId : `teesheet-${bookingId}`;
        const rawId = bookingId.replace(/^teesheet-/, '');

        if (bookingManager) {
          // Find and remove booking (check both ID formats)
          const initialLength = bookingManager.bookings.length;
          bookingManager.bookings = bookingManager.bookings.filter(b =>
            b.id !== teesheetId && b.id !== rawId && b.id !== bookingId
          );

          const removed = initialLength - bookingManager.bookings.length;
          if (removed > 0) {
            console.log(`[TeeSheet] Removed ${removed} booking(s) from parent BookingManager`);

            // Save to localStorage
            if (typeof bookingManager.saveToLocalStorage === 'function') {
              bookingManager.saveToLocalStorage();
              console.log('[TeeSheet] Saved deletion to localStorage');
            }

            // Trigger cloud sync
            if (cloudSync && typeof cloudSync.saveToCloud === 'function') {
              try {
                await cloudSync.saveToCloud();
                console.log('[TeeSheet] Deletion synced to cloud');
              } catch (e) {
                console.warn('[TeeSheet] Cloud sync failed:', e);
              }
            }
          } else {
            console.log('[TeeSheet] Booking not found in parent (may have been local-only)');
          }

          return true;
        } else {
          // Standalone mode - remove from localStorage directly
          try {
            const bookings = JSON.parse(localStorage.getItem('mcipro_bookings') || '[]');
            const filtered = bookings.filter(b =>
              b.id !== teesheetId && b.id !== rawId && b.id !== bookingId
            );
            localStorage.setItem('mcipro_bookings', JSON.stringify(filtered));
            console.log('[TeeSheet] Booking removed from localStorage (standalone mode)');
            return true;
          } catch (e) {
            console.error('[TeeSheet] Failed to remove booking from localStorage:', e);
            return false;
          }
        }
      },

      // Send LINE notification to caddies for booking events
      async notifyCaddyBooking(booking, action) {
        const parent = this.getParent();
        const supabase = parent.SupabaseDB?.client;
        if (!supabase) {
          console.log('[TeeSheet] No Supabase client for notifications');
          return;
        }

        // Build notification payload from booking
        const caddyBookings = booking.caddyBookings || [];
        for (const cb of caddyBookings) {
          try {
            const { data, error } = await supabase.functions.invoke('notify-caddy-booking', {
              body: {
                action: action,
                bookingId: booking.id,
                caddyId: cb.caddyId,
                caddyName: cb.caddyName,
                golferId: booking.golferId,
                golferName: cb.golferName,
                course: booking.courseDisplay || booking.course,
                date: booking.date,
                time: booking.time
              }
            });
            if (error) {
              console.warn('[TeeSheet] Notification failed:', error);
            } else {
              console.log('[TeeSheet] Caddy notified:', cb.caddyName, action);
            }
          } catch (e) {
            console.warn('[TeeSheet] Notification error:', e);
          }
        }
      },

      // Add golfer to caddy waitlist
      async addToWaitlist(caddyId, caddyName, golferId, golferName, date, time, course) {
        const parent = this.getParent();
        const supabase = parent.SupabaseDB?.client;

        // Store waitlist entry
        const waitlistEntry = {
          id: 'waitlist-' + Date.now(),
          caddyId,
          caddyName,
          golferId,
          golferName,
          date,
          time,
          course,
          createdAt: new Date().toISOString(),
          status: 'waiting'
        };

        // Save to localStorage for now
        const waitlistKey = 'teesheet.waitlist.' + caddyId;
        let waitlist = [];
        try {
          waitlist = JSON.parse(localStorage.getItem(waitlistKey) || '[]');
        } catch {}
        waitlist.push(waitlistEntry);
        localStorage.setItem(waitlistKey, JSON.stringify(waitlist));

        // Notify golfer they're on waitlist
        if (supabase) {
          try {
            await supabase.functions.invoke('notify-caddy-booking', {
              body: {
                action: 'waitlist_added',
                caddyId,
                caddyName,
                golferId,
                golferName,
                date,
                time,
                course
              }
            });
          } catch (e) {
            console.warn('[TeeSheet] Waitlist notification failed:', e);
          }
        }

        console.log('[TeeSheet] Added to waitlist:', golferName, '->', caddyName);
        return waitlistEntry;
      },

      // Get waitlist for a caddy
      getWaitlist(caddyId) {
        const waitlistKey = 'teesheet.waitlist.' + caddyId;
        try {
          return JSON.parse(localStorage.getItem(waitlistKey) || '[]');
        } catch {
          return [];
        }
      },

      // Promote from waitlist when booking cancelled
      async promoteFromWaitlist(caddyId, date, time) {
        const waitlist = this.getWaitlist(caddyId);
        const matching = waitlist.find(w => w.date === date && w.time === time && w.status === 'waiting');

        if (matching) {
          const parent = this.getParent();
          const supabase = parent.SupabaseDB?.client;

          if (supabase) {
            try {
              await supabase.functions.invoke('notify-caddy-booking', {
                body: {
                  action: 'waitlist_promoted',
                  caddyId: matching.caddyId,
                  caddyName: matching.caddyName,
                  golferId: matching.golferId,
                  golferName: matching.golferName,
                  date: matching.date,
                  time: matching.time,
                  course: matching.course
                }
              });
              console.log('[TeeSheet] Waitlist promoted:', matching.golferName);
            } catch (e) {
              console.warn('[TeeSheet] Waitlist promotion notification failed:', e);
            }
          }

          // Update waitlist status
          matching.status = 'notified';
          const waitlistKey = 'teesheet.waitlist.' + caddyId;
          localStorage.setItem(waitlistKey, JSON.stringify(waitlist));

          return matching;
        }
        return null;
      },

      // Get bookings from parent BookingManager for a specific date and course
      getBookingsFromParent(date, courseId) {
        const bookingManager = this.getBookingManager();
        if (!bookingManager || !bookingManager.bookings) {
          return [];
        }

        // Filter bookings for this date and course
        return bookingManager.bookings.filter(b => {
          // Skip teesheet-originated bookings (we already have them in localStorage)
          if (b.source === 'teesheet') return false;

          // Match date (handle different date formats)
          const bookingDate = b.date || '';
          if (!bookingDate.startsWith(date)) return false;

          // Match course if specified
          if (courseId && b.course !== courseId) return false;

          return true;
        }).map(b => ({
          // Convert to tee sheet format
          id: `parent-${b.id}`,
          parentId: b.id,
          time: b.time || '08:00',
          type: b.bookingType || b.type || 'regular',
          course: 'A', // Default course slot
          tee: 1,
          col: 0,
          golfers: b.golfers || [{
            name: b.golferName || 'Guest',
            caddyId: b.caddyBookings?.[0]?.caddyId || null,
            caddyNumber: b.caddyBookings?.[0]?.caddyNumber || '',
            caddyName: b.caddyBookings?.[0]?.caddyName || '',
            caddyLocalName: b.caddyBookings?.[0]?.caddyLocalName || ''
          }],
          notes: b.notes || '',
          fromParent: true
        }));
      },

      // Log connection status
      logStatus() {
        console.log('[TeeSheet] Parent Bridge Status:', {
          caddySystem: !!this.getCaddySystem(),
          bookingManager: !!this.getBookingManager(),
          cloudSync: !!this.getCloudSync(),
          caddyCount: this.getAllCaddies().length,
          parentBookingsCount: this.getBookingManager()?.bookings?.length || 0
        });
      }
    };

    // Log bridge status on load
    setTimeout(() => ParentBridge.logStatus(), 500);

    // ==================== CADDY DATA ====================
    let allCaddies = [];

    // Map tee sheet course ID to database course name
    const courseIdToDbName = {
      'treasure-hill-golf': 'Treasure Hill Golf & Country Club',
      'phoenix-gold': 'Phoenix Gold Golf & Country Club',
      'greenwood': 'Greenwood Golf & Country Club',
      'pattana': 'Pattana Golf Club & Resort',
      'burapha-ac': 'Burapha Golf Club',
      'bangpakong': 'Bangpakong Riverside Country Club',
      'plutaluang': 'Plutaluang Royal Thai Navy Golf Course',
      'siam-country-club': 'Siam Country Club',
      'khao-kheow': 'Khao Kheow Country Club',
      'laem-chabang': 'Laem Chabang International Country Club'
    };

    // Fetch caddies from Supabase database
    async function fetchCaddiesFromDb(courseId) {
      if (!supabaseClient) return [];

      try {
        let query = supabaseClient
          .from('caddy_profiles')
          .select('id, name, caddy_number, course_name, rating, languages, photo_url, is_active, availability_status')
          .eq('is_active', true);

        // Filter by course name if specified
        if (courseId && courseIdToDbName[courseId]) {
          query = query.eq('course_name', courseIdToDbName[courseId]);
        }

        const { data, error } = await query;

        if (error) {
          console.error('[TeeSheet] Error fetching caddies from DB:', error);
          return [];
        }

        // Map to expected format
        return (data || []).map(c => ({
          id: c.id,
          name: c.name,
          localName: '',
          number: c.caddy_number,
          rating: c.rating || 4.5,
          language: Array.isArray(c.languages) ? c.languages.join('/') : 'TH/EN',
          status: c.availability_status === 'booked' ? 'busy' : 'available',
          photoUrl: c.photo_url,
          homeClub: courseId
        }));
      } catch (e) {
        console.error('[TeeSheet] Caddy fetch error:', e);
        return [];
      }
    }

    // Save caddy booking to Supabase database
    async function saveCaddyBookingToDb(booking, golfer, date, time) {
      if (!supabaseClient || !golfer.caddyId) return null;

      const courseId = el.courseSelect.value;
      const courseName = courseIdToDbName[courseId] || courseId;

      try {
        // Look up user by name to get their user_id (LINE ID)
        let userId = golfer.odoo_id || null; // May already have user ID from existing data

        if (!userId && golfer.name) {
          // Search for user by name (case-insensitive partial match)
          const { data: userProfile } = await supabaseClient
            .from('user_profiles')
            .select('line_user_id, name')
            .ilike('name', `%${golfer.name}%`)
            .limit(1)
            .single();

          if (userProfile) {
            userId = userProfile.line_user_id;
            console.log('[TeeSheet] Found user for golfer:', golfer.name, '‚Üí', userProfile.name, userId);
          }
        }

        // Check if booking already exists for this caddy/date/time
        const { data: existing } = await supabaseClient
          .from('caddy_bookings')
          .select('id')
          .eq('caddy_id', golfer.caddyId)
          .eq('booking_date', date)
          .eq('tee_time', time + ':00')
          .single();

        if (existing) {
          // Update existing booking with user_id if we found one
          if (userId) {
            await supabaseClient
              .from('caddy_bookings')
              .update({ user_id: userId })
              .eq('id', existing.id);
            console.log('[TeeSheet] Updated existing caddy booking with user_id:', existing.id);
          }
          return existing.id;
        }

        // Create new caddy booking with user_id for dashboard visibility
        const insertData = {
          caddy_id: golfer.caddyId,
          booking_date: date,
          tee_time: time + ':00',
          course_name: courseName,
          status: 'confirmed',
          booking_source: 'proshop_teesheet',
          golfer_name: golfer.name || 'Guest'
        };

        // Add user_id if we found the golfer in the system
        if (userId) {
          insertData.user_id = userId;
        }

        const { data, error } = await supabaseClient
          .from('caddy_bookings')
          .insert(insertData)
          .select('id')
          .single();

        if (error) {
          console.error('[TeeSheet] Error saving caddy booking:', error);
          return null;
        }

        console.log('[TeeSheet] Saved caddy booking to database:', data.id, userId ? `(linked to ${golfer.name})` : '(no user link)');
        return data.id;
      } catch (e) {
        console.error('[TeeSheet] Caddy booking save error:', e);
        return null;
      }
    }

    // Delete caddy booking from database
    async function deleteCaddyBookingFromDb(caddyId, date, time) {
      if (!supabaseClient || !caddyId) return;

      try {
        const { error } = await supabaseClient
          .from('caddy_bookings')
          .delete()
          .eq('caddy_id', caddyId)
          .eq('booking_date', date)
          .eq('tee_time', time + ':00');

        if (error) {
          console.error('[TeeSheet] Error deleting caddy booking:', error);
        } else {
          console.log('[TeeSheet] Deleted caddy booking from database');
        }
      } catch (e) {
        console.error('[TeeSheet] Caddy booking delete error:', e);
      }
    }

    // Cache for system users (golfers)
    let allSystemUsers = [];
    let usersLastFetchTime = 0;

    // Fetch all users from database for golfer autocomplete
    async function fetchSystemUsers() {
      if (!supabaseClient) return [];

      const now = Date.now();
      // Cache for 5 minutes
      if (allSystemUsers.length > 0 && (now - usersLastFetchTime) < 300000) {
        return allSystemUsers;
      }

      try {
        const { data, error } = await supabaseClient
          .from('user_profiles')
          .select('line_user_id, name, email')
          .order('name');

        if (error) {
          console.error('[TeeSheet] Error fetching users:', error);
          return allSystemUsers;
        }

        allSystemUsers = (data || []).map(u => ({
          id: u.line_user_id,
          name: u.name || u.email?.split('@')[0] || 'Unknown',
          email: u.email
        }));
        usersLastFetchTime = now;
        console.log('[TeeSheet] Loaded', allSystemUsers.length, 'system users');
        return allSystemUsers;
      } catch (e) {
        console.error('[TeeSheet] User fetch error:', e);
        return allSystemUsers;
      }
    }

    // Render user dropdown for golfer name autocomplete
    function renderUserDropdown(dropdown, input, query) {
      dropdown.innerHTML = '';
      query = (query || '').toLowerCase();

      // Filter users by query
      const matches = allSystemUsers.filter(u =>
        u.name.toLowerCase().includes(query) ||
        (u.email && u.email.toLowerCase().includes(query))
      ).slice(0, 8);

      if (matches.length === 0 && query.length > 0) {
        const noMatch = document.createElement('div');
        noMatch.className = 'caddy-option';
        noMatch.style.color = '#6b7280';
        noMatch.innerHTML = `<span>No matching users - will create as guest</span>`;
        dropdown.appendChild(noMatch);
        return;
      }

      matches.forEach(user => {
        const opt = document.createElement('div');
        opt.className = 'caddy-option';
        opt.innerHTML = `
          <span class="caddy-option-name">${user.name}</span>
          ${user.email ? `<span class="caddy-option-detail">${user.email}</span>` : ''}
        `;
        opt.addEventListener('mousedown', e => {
          e.preventDefault();
          input.value = user.name;
          input.dataset.userId = user.id;
          dropdown.classList.remove('show');
        });
        dropdown.appendChild(opt);
      });
    }

    // Get caddies from parent CaddySystem OR database, filtered by selected course
    async function refreshCaddies() {
      const courseId = el.courseSelect.value;

      // Try parent CaddySystem first
      const parentCaddies = ParentBridge.getAllCaddies(courseId);
      if (parentCaddies.length > 0) {
        allCaddies = parentCaddies;
        console.log('[TeeSheet] Loaded', allCaddies.length, 'caddies from parent for course:', courseId || 'all');
        return;
      }

      // Fallback: fetch from database
      allCaddies = await fetchCaddiesFromDb(courseId);
      console.log('[TeeSheet] Loaded', allCaddies.length, 'caddies from database for course:', courseId || 'all');
    }

    // Initial load - wait for DOM to be ready
    setTimeout(() => {
      refreshCaddies();
    }, 100);

    // ==================== DOM ====================
    const $ = id => document.getElementById(id);
    const el = {
      langSelect: $('lang-select'),
      courseSelect: $('course-select'),
      dateInput: $('date-input'),
      prevDay: $('prev-day'),
      nextDay: $('next-day'),
      todayBtn: $('today-btn'),
      complexSelect: $('complex-select'),
      startTime: $('start-time'),
      endTime: $('end-time'),
      intervalSelect: $('interval-select'),
      teesSelect: $('tees-select'),
      searchInput: $('search-input'),
      findBtn: $('find-btn'),
      nextBtn: $('next-btn'),
      clearBtn: $('clear-btn'),
      gridHeader: $('grid-header'),
      gridBody: $('grid-body'),
      legendC: $('legend-c'),
      legendD: $('legend-d'),
      dialog: $('booking-dialog'),
      closeDialog: $('close-dialog'),
      bookingId: $('booking-id'),
      bookingGroupId: $('booking-group-id'),
      bookingType: $('booking-type'),
      bookingCourse: $('booking-course'),
      bookingTee: $('booking-tee'),
      bookingTime: $('booking-time'),
      golfersList: $('golfers-list'),
      addGolfer: $('add-golfer'),
      bookingNotes: $('booking-notes'),
      deleteBooking: $('delete-booking'),
      cancelBooking: $('cancel-booking'),
      saveBooking: $('save-booking'),
      backToTop: $('back-to-top'),
      // Range booking elements
      rangeModeToggle: $('range-mode-toggle'),
      singleBookingRow: $('single-booking-row'),
      rangeTimeRow: $('range-time-row'),
      rangeGroupNameRow: $('range-group-name-row'),
      rangeStartTime: $('range-start-time'),
      rangeEndTime: $('range-end-time'),
      rangeCourse: $('range-course'),
      rangeTee: $('range-tee'),
      rangeType: $('range-type'),
      rangeInfo: $('range-info'),
      rangeGroupName: $('range-group-name'),
      singleGolfersSection: $('single-golfers-section'),
      rangeSlotsSection: $('range-slots-section'),
      rangeSlotsList: $('range-slots-list'),
      slotCountBadge: $('slot-count-badge'),
      // Recurring booking elements
      recurringToggle: $('recurring-toggle'),
      recurringOptions: $('recurring-options'),
      recurringFrequency: $('recurring-frequency'),
      recurringUntil: $('recurring-until'),
      recurringCount: $('recurring-count'),
      weekdaysRow: $('weekdays-row'),
      recurringPreview: $('recurring-preview')
    };

    // Current range slots data (for range booking mode)
    let rangeSlots = [];

    // ==================== HELPERS ====================
    const pad2 = n => String(n).padStart(2, '0');
    const minutes = hm => { const [h, m] = (hm || '').split(':').map(Number); return h * 60 + m; };
    const hhmm = m => `${pad2(Math.floor(m / 60))}:${pad2(m % 60)}`;
    const todayISO = () => { const d = new Date(); return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`; };
    const genId = () => crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).substr(2, 9);

    // ==================== CADDY AVAILABILITY CHECK ====================
    // Round duration in minutes - a caddy is unavailable for this long after their tee time
    const ROUND_DURATION_MINUTES = 270; // 4.5 hours = 270 minutes

    /**
     * Check if a time slot falls within a caddy's active round
     * A caddy booked at 10:00 is unavailable from 10:00 to ~14:30 (4.5 hours)
     * @param {string} bookedTime - The time the caddy was booked (HH:MM)
     * @param {string} checkTime - The time we're checking availability for (HH:MM)
     * @returns {boolean} True if checkTime falls within the caddy's active round
     */
    function isTimeWithinRound(bookedTime, checkTime) {
      const bookedM = minutes(bookedTime);
      const checkM = minutes(checkTime);
      const roundEndM = bookedM + ROUND_DURATION_MINUTES;

      // Check if the time we're booking falls within the existing round's window
      // A new booking at checkTime would mean the caddy starts at checkTime
      // They conflict if: checkTime falls within [bookedTime, bookedTime + duration)
      // OR if: bookedTime falls within [checkTime, checkTime + duration)
      const newRoundEndM = checkM + ROUND_DURATION_MINUTES;

      // Overlap check: two time ranges overlap if start1 < end2 AND start2 < end1
      return (checkM < roundEndM) && (bookedM < newRoundEndM);
    }

    /**
     * Get all caddies that are already booked for a specific date and time
     * Takes into account that a round takes ~4.5 hours
     * @param {string} date - The date to check (YYYY-MM-DD)
     * @param {string} time - The time to check (HH:MM)
     * @param {string} excludeBookingId - Optional booking ID to exclude (for editing existing booking)
     * @returns {Set} Set of booked caddy numbers
     */
    function getBookedCaddiesForSlot(date, time, excludeBookingId = null) {
      const bookings = getDay(date);
      const bookedCaddyNumbers = new Set();

      bookings.forEach(booking => {
        // Skip the booking we're currently editing
        if (excludeBookingId && booking.id === excludeBookingId) return;

        // Check if this booking's time window overlaps with the requested time
        if (isTimeWithinRound(booking.time, time)) {
          // Collect all caddies from this booking's golfers
          const golfers = booking.golfers || [];
          golfers.forEach(g => {
            if (g.caddyNumber) {
              bookedCaddyNumbers.add(g.caddyNumber);
            }
          });
          // Also check legacy caddyNumber field
          if (booking.caddyNumber) {
            bookedCaddyNumbers.add(booking.caddyNumber);
          }
        }
      });

      return bookedCaddyNumbers;
    }

    /**
     * Get all caddies booked for a time range (for range booking mode)
     * Takes into account round duration for each slot
     * @param {string} date - The date to check
     * @param {string} startTime - Start time of range
     * @param {string} endTime - End time of range
     * @param {string} excludeGroupId - Optional group ID to exclude
     * @returns {Map} Map of time -> Set of booked caddy numbers
     */
    function getBookedCaddiesForRange(date, startTime, endTime, excludeGroupId = null) {
      const bookings = getDay(date);
      const bookedByTime = new Map();
      const startM = minutes(startTime);
      const endM = minutes(endTime);
      const step = parseInt(el.intervalSelect.value) || 7;

      // Initialize map for each time slot in range
      for (let m = startM; m <= endM; m += step) {
        bookedByTime.set(hhmm(m), new Set());
      }

      // For each time slot in range, check which caddies are booked
      bookedByTime.forEach((caddySet, slotTime) => {
        bookings.forEach(booking => {
          // Skip bookings from the group we're editing
          if (excludeGroupId && booking.groupId === excludeGroupId) return;

          // Check if this booking's time window overlaps with the slot time
          if (isTimeWithinRound(booking.time, slotTime)) {
            const golfers = booking.golfers || [];
            golfers.forEach(g => {
              if (g.caddyNumber) caddySet.add(g.caddyNumber);
            });
            if (booking.caddyNumber) caddySet.add(booking.caddyNumber);
          }
        });
      });

      return bookedByTime;
    }

    // Current slot context for caddy dropdown
    let currentSlotTime = null;
    let currentEditingBookingId = null;

    // ==================== STORAGE ====================
    const storageKey = d => `teesheet.bookings.v2::${d}`;

    // Enhanced getDay - merges local bookings with caddy bookings from database
    const getDay = d => {
      // Get local tee sheet bookings
      let localBookings = [];
      try {
        localBookings = JSON.parse(localStorage.getItem(storageKey(d)) || '[]');
      } catch {
        localBookings = [];
      }

      // Get bookings from parent (caddy booking module, etc.)
      const courseId = el?.courseSelect?.value || '';
      const parentBookings = ParentBridge.getBookingsFromParent(d, courseId);

      // Get cached caddy bookings from database
      const dbBookings = caddyBookingsCache[d] || [];

      // Get cached society events from database (course-specific cache)
      const societyCacheKey = `${d}::${courseId}`;
      const societyEvents = societyEventsCache[societyCacheKey] || [];

      // Merge all sources (avoiding duplicates by id AND by caddy+time match)
      const allIds = new Set(localBookings.map(b => b.id));

      // Track local bookings by caddy+time for deduplication with DB bookings
      const localCaddyTimeKeys = new Set();
      localBookings.forEach(b => {
        if (b.golfers && b.golfers.length > 0) {
          b.golfers.forEach(g => {
            if (g.caddyId && b.time) {
              localCaddyTimeKeys.add(`${g.caddyId}::${b.time}`);
            }
          });
        }
      });

      const uniqueParent = parentBookings.filter(b => !allIds.has(b.parentId) && !allIds.has(b.id));
      uniqueParent.forEach(b => allIds.add(b.id));

      // Filter DB bookings - skip if already exists locally (by ID or by caddy+time match)
      const uniqueDb = dbBookings.filter(b => {
        if (allIds.has(b.id) || allIds.has(b.dbId)) return false;
        // Also skip if there's a local booking with same caddy at same time
        if (b.golfers && b.golfers.length > 0 && b.time) {
          for (const g of b.golfers) {
            if (g.caddyId && localCaddyTimeKeys.has(`${g.caddyId}::${b.time}`)) {
              return false; // Skip - local booking has this caddy at this time
            }
          }
        }
        return true;
      });
      uniqueDb.forEach(b => allIds.add(b.id));
      const uniqueSociety = societyEvents.filter(b => !allIds.has(b.id) && !allIds.has(b.eventId));

      return [...localBookings, ...uniqueParent, ...uniqueDb, ...uniqueSociety];
    };

    // Async version that fetches from database first
    const getDayAsync = async d => {
      // Fetch caddy bookings, society events, and event registrations in parallel
      await Promise.all([
        fetchCaddyBookings(d),
        fetchSocietyEvents(d),
        fetchEventRegistrations(d)
      ]);
      return getDay(d);
    };

    // Enhanced setDay - saves to localStorage AND syncs to parent BookingManager
    const setDay = (d, arr) => {
      // CRITICAL FIX: Only save LOCAL bookings to localStorage
      // Filter out bookings from external sources (DB, parent) to prevent duplicates
      const localOnlyBookings = (arr || []).filter(b => {
        // Skip DB-sourced caddy bookings
        if (b.source === 'caddy-booking-db') return false;
        if (b.id && b.id.startsWith('caddy-')) return false;
        // Skip parent-sourced bookings
        if (b.id && b.id.startsWith('parent-')) return false;
        // Skip society events from DB
        if (b.source === 'society-event-db') return false;
        if (b.id && b.id.startsWith('society-')) return false;
        return true;
      });
      localStorage.setItem(storageKey(d), JSON.stringify(localOnlyBookings));

      // Sync each booking to parent BookingManager for caddy booking integration
      const courseId = el.courseSelect.value;
      if (arr && arr.length > 0) {
        arr.forEach(booking => {
          // Build ISO teeTime for Schedule tab compatibility
          const teeTimeISO = `${d}T${booking.time}:00`;

          // Get first golfer name for filtering
          const firstGolfer = (booking.golfers && booking.golfers.length > 0) ? booking.golfers[0] : null;
          const golferName = firstGolfer?.name || '';

          // Convert tee sheet booking to BookingManager format
          const parentBooking = {
            id: `teesheet-${booking.id}`,
            type: 'tee_time',
            source: 'teesheet',
            course: courseId,
            courseDisplay: el.courseSelect.options[el.courseSelect.selectedIndex]?.text || courseId,
            date: d,
            time: booking.time,
            teeTime: teeTimeISO,  // ISO datetime for Schedule tab
            golferName: golferName,  // For golfer filtering
            status: 'confirmed',
            bookingType: booking.type || 'regular',
            groupId: booking.groupId || null,
            groupName: booking.groupName || null,
            notes: booking.notes || '',
            golfers: booking.golfers || [],
            caddyBookings: (booking.golfers || [])
              .filter(g => g.caddyNumber)
              .map(g => ({
                caddyId: g.caddyId,
                caddyNumber: g.caddyNumber,
                caddyName: g.caddyName,
                caddyLocalName: g.caddyLocalName || '',
                golferName: g.name,
                date: d,
                time: booking.time,
                course: courseId
              })),
            createdAt: booking.createdAt || new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };

          // Async sync to parent (don't await to avoid blocking)
          ParentBridge.syncBookingToParent(parentBooking);
        });
      }

      // Invalidate calendar cache so new bookings show in preview
      if (typeof CalendarNav !== 'undefined' && CalendarNav.monthCache) {
        const dateObj = new Date(d);
        const cacheKey = `${dateObj.getFullYear()}-${dateObj.getMonth()}`;
        delete CalendarNav.monthCache[cacheKey];
      }
    };

    // ==================== SOCIETY BOOKING SYNC ====================
    // Syncs pro shop tee sheet changes to society events and notifies members
    async function syncSocietyBookingChange(booking, changes) {
      const { oldTime, oldCourse, oldTee, newTime, newCourse, newTee, date } = changes;

      console.log('[TeeSheet] Society booking changed:', {
        bookingId: booking.id,
        groupId: booking.groupId,
        groupName: booking.groupName,
        oldTime, newTime,
        oldCourse, newCourse
      });

      // Build change description
      const changeDetails = [];
      if (oldTime !== newTime) changeDetails.push(`Time: ${oldTime} ‚Üí ${newTime}`);
      if (oldCourse !== newCourse) changeDetails.push(`Course: ${oldCourse} ‚Üí ${newCourse}`);
      if (oldTee !== newTee) changeDetails.push(`Tee: ${oldTee} ‚Üí ${newTee}`);
      const changeText = changeDetails.join(', ');

      // 1. Update parent BookingManager if available
      if (window.parent && window.parent.BookingManager) {
        const parentBookings = window.parent.BookingManager.bookings || [];
        const parentIdx = parentBookings.findIndex(b =>
          b.id === booking.id ||
          b.id === booking.parentId ||
          (b.groupId === booking.groupId && b.date === date && b.time === oldTime)
        );

        if (parentIdx >= 0) {
          parentBookings[parentIdx].time = newTime;
          parentBookings[parentIdx].course = newCourse;
          parentBookings[parentIdx].teeSheetCourse = newCourse;
          parentBookings[parentIdx].lastModifiedBy = 'proshop';
          parentBookings[parentIdx].lastModifiedAt = new Date().toISOString();
          parentBookings[parentIdx].changeHistory = parentBookings[parentIdx].changeHistory || [];
          parentBookings[parentIdx].changeHistory.push({
            changedAt: new Date().toISOString(),
            changedBy: 'Pro Shop',
            changes: changeText
          });
          window.parent.BookingManager.saveToLocalStorage();
          console.log('[TeeSheet] Updated parent BookingManager booking');
        }
      }

      // 2. Create notification for society organizers and members
      const notification = {
        id: `teesheet-change-${Date.now()}`,
        type: 'tee_time_change',
        priority: 'high',
        title: '‚õ≥ Tee Time Changed by Pro Shop',
        message: `${booking.groupName || 'Your booking'} on ${date} has been updated: ${changeText}`,
        bookingId: booking.id,
        groupId: booking.groupId,
        eventId: booking.eventId || booking.groupId,
        date: date,
        oldTime, newTime,
        oldCourse, newCourse,
        changedBy: 'Pro Shop',
        changedAt: new Date().toISOString(),
        read: false
      };

      // Store notification locally
      try {
        const notifKey = 'teesheet.notifications';
        let notifications = JSON.parse(localStorage.getItem(notifKey) || '[]');
        notifications.unshift(notification);
        // Keep last 100 notifications
        notifications = notifications.slice(0, 100);
        localStorage.setItem(notifKey, JSON.stringify(notifications));
      } catch (e) {
        console.warn('[TeeSheet] Failed to store notification locally:', e);
      }

      // 3. Sync to Supabase - update society_events to trigger Realtime notifications
      const supabase = window.parent?.SupabaseDB?.client || window.SupabaseManager?.client || supabaseClient;
      if (supabase) {
        try {
          // Extract raw event ID - strip 'society-' prefix if present
          let eventId = booking.eventId || booking.groupId;
          if (eventId && eventId.startsWith('society-')) {
            eventId = eventId.replace('society-', '');
          }
          console.log('[TeeSheet] Syncing society event change, eventId:', eventId);

          if (eventId) {
            // Get existing event data
            const { data: existingEvent } = await supabase
              .from('society_events')
              .select('change_log, notes')
              .eq('id', eventId)
              .single();

            // Build change log entry
            const changeLog = existingEvent?.change_log || [];
            changeLog.push({
              timestamp: new Date().toISOString(),
              changedBy: 'Pro Shop',
              bookingId: booking.id,
              changes: changeText,
              type: 'tee_time_change'
            });

            // Update society_events - this triggers Realtime subscription for all connected clients
            // The updated_at change will show badge notifications to golfers
            // CRITICAL: Also update start_time when time changes!
            const updateData = {
              change_log: changeLog,
              updated_at: new Date().toISOString(),
              updated_by: 'proshop',
              updated_by_name: 'Pro Shop',
              // Append to notes so it's visible in the event details
              notes: (existingEvent?.notes || '') +
                `\n[${new Date().toLocaleString()}] Pro Shop: ${changeText}`
            };

            // CRITICAL FIX: Update start_time when time changes
            if (oldTime !== newTime) {
              updateData.start_time = newTime + ':00';
              console.log('[TeeSheet] Updating society event start_time to:', newTime);
            }

            const { error: updateError } = await supabase
              .from('society_events')
              .update(updateData)
              .eq('id', eventId);

            if (updateError) {
              console.warn('[TeeSheet] Failed to update society event:', updateError);
            } else {
              console.log('[TeeSheet] Updated society_events - Realtime will notify connected clients');
            }

            // Also log how many registrations exist for this event
            const { data: registrations, count } = await supabase
              .from('event_registrations')
              .select('id', { count: 'exact' })
              .eq('event_id', eventId);

            console.log('[TeeSheet] Event has', count || 0, 'registered golfers who will see the update');
          }

        } catch (e) {
          console.warn('[TeeSheet] Supabase notification sync failed:', e);
        }
      }

      // 4. Show local confirmation
      const parentNotify = window.parent?.NotificationManager;
      if (parentNotify) {
        parentNotify.show(`Updated ${booking.groupName || 'society booking'}: ${changeText}`, 'info', 5000);
      }

      // Dispatch custom event for any listeners
      window.dispatchEvent(new CustomEvent('societyBookingChanged', {
        detail: { booking, changes, notification }
      }));
    }

    // Settings storage - persists course configuration
    const SETTINGS_KEY = 'teesheet.settings';
    function getSettings() {
      try {
        return JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {};
      } catch { return {}; }
    }
    function saveSettings() {
      const settings = {
        golfCourse: el.courseSelect.value,
        courseLayout: el.complexSelect.value,
        startTime: el.startTime.value,
        endTime: el.endTime.value,
        interval: el.intervalSelect.value,
        teesPerCourse: el.teesSelect.value
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      console.log('[TeeSheet] Settings saved:', settings);
    }

    // ==================== INIT ====================
    // Initialize time picker selects FIRST (before loading settings)
    TimePickerUtils.initAll();

    // Load saved settings
    const savedSettings = getSettings();
    if (savedSettings.golfCourse) el.courseSelect.value = savedSettings.golfCourse;
    if (savedSettings.courseLayout) el.complexSelect.value = savedSettings.courseLayout;
    if (savedSettings.startTime) el.startTime.value = savedSettings.startTime;
    if (savedSettings.endTime) el.endTime.value = savedSettings.endTime;
    if (savedSettings.interval) el.intervalSelect.value = savedSettings.interval;
    if (savedSettings.teesPerCourse) el.teesSelect.value = savedSettings.teesPerCourse;
    console.log('[TeeSheet] Loaded settings:', savedSettings);

    // Always start with today's date (fixes overnight stale date issue)
    el.dateInput.value = todayISO();
    el.langSelect.value = currentLang;

    // Auto-update date at midnight for golf courses that keep tee sheet open permanently
    let lastCheckedDate = todayISO();
    setInterval(() => {
      const currentToday = todayISO();
      if (currentToday !== lastCheckedDate) {
        console.log('[TeeSheet] Date changed from', lastCheckedDate, 'to', currentToday, '- auto-updating');
        lastCheckedDate = currentToday;
        el.dateInput.value = currentToday;
        updateHeaderDate();
        fetchAndRender();
      }
    }, 60000); // Check every minute

    // ==================== LAYOUT ====================
    function getCourses() {
      const v = el.complexSelect.value;
      if (v === '18') return ['A', 'B'];
      if (v === '27') return ['A', 'B', 'C'];
      return ['A', 'B', 'C', 'D'];
    }

    function getLayout() {
      const courses = getCourses();
      const teesPerCourse = parseInt(el.teesSelect.value) || 1;
      const cols = [];
      courses.forEach(c => {
        for (let i = 0; i < teesPerCourse; i++) cols.push({ course: c, tee: i + 1 });
      });
      return { courses, teesPerCourse, cols };
    }

    // ==================== RENDER ====================
    function render() {
      const layout = getLayout();
      const startM = minutes(el.startTime.value);
      const endM = minutes(el.endTime.value);
      const step = parseInt(el.intervalSelect.value) || 7;

      const currentDate = el.dateInput.value;
      let bookings = getDay(currentDate);

      // Get society events from bookings to identify blocked time ranges
      const societyEvents = bookings.filter(b =>
        b.bookingType === 'society' || b.type === 'society' || b.type === 'society_event' ||
        b.source === 'society-event-db' || (b.groupId && (b.groupName || b.societyName))
      );
      console.log('[TeeSheet] Found', societyEvents.length, 'society events for', currentDate);

      // Get event registrations from cache for caddy info enrichment
      const eventRegs = eventRegistrationsCache[currentDate] || [];

      // Filter out caddy bookings that fall within society event time ranges
      // They will be shown integrated into the society event instead
      const filteredBookings = bookings.filter(b => {
        // Keep all non-caddy bookings
        if (b.source !== 'caddy-booking-db') return true;

        // Check if this caddy booking falls within any society event's time range
        for (const evt of societyEvents) {
          const evtTime = evt.time || evt.startTime;
          // Society events typically block 1 hour (or use endTime if available)
          const evtEndMins = evt.endTime ? minutes(evt.endTime) : minutes(evtTime) + 60;

          if (b.time && evtTime) {
            const bookingMins = minutes(b.time);
            const evtStartMins = minutes(evtTime);

            // If booking is within society event's blocked range, exclude it
            if (bookingMins >= evtStartMins && bookingMins < evtEndMins) {
              console.log('[TeeSheet] Caddy booking', b.time, 'falls within society event', evt.groupName || evt.eventName, '- integrating');
              return false; // Don't show separately
            }
          }
        }

        // Also check against event registrations (for events from BookingManager)
        for (const evtReg of eventRegs) {
          const evtStartMins = minutes(evtReg.startTime);
          const evtEndMins = evtReg.endTime ? minutes(evtReg.endTime) : evtStartMins + 60;

          if (b.time) {
            const bookingMins = minutes(b.time);
            if (bookingMins >= evtStartMins && bookingMins < evtEndMins) {
              console.log('[TeeSheet] Caddy booking', b.time, 'falls within event', evtReg.eventTitle, '- integrating');
              return false;
            }
          }
        }

        return true; // Show standalone caddy bookings that don't match any event
      });

      // Enrich society events with registered members and caddy info
      filteredBookings.forEach(b => {
        if (b.bookingType === 'society' || b.type === 'society' || b.type === 'society_event' ||
            b.source === 'society-event-db' || (b.groupId && b.groupName)) {

          // Skip event registrations enrichment - caddy bookings are the actual slot assignments
          // Registered members who haven't booked caddies yet don't show on tee sheet
          // They will appear once they book a caddy (first-come-first-served)

          // Add caddy bookings to the slot that matches their exact tee_time
          // Multiple golfers can be in the same slot if they booked the same time
          const caddyBookings = caddyBookingsCache[currentDate] || [];
          const slotTime = b.time; // This slot's time (e.g., 11:40)
          const slotMins = minutes(slotTime);

          caddyBookings.forEach(cb => {
            if (!cb.time) return;
            const cbMins = minutes(cb.time);
            // Only add to slot if caddy booking time matches this slot's time
            if (cbMins !== slotMins) return;

            const golfer = cb.golfers?.[0];
            if (golfer) {
              // Check if golfer already in this slot
              const existingGolfer = (b.golfers || []).find(g =>
                g.name === golfer.name || g.odoo_id === golfer.odoo_id
              );

              if (!existingGolfer) {
                b.golfers = b.golfers || [];
                b.golfers.push({
                  name: golfer.name,
                  odoo_id: golfer.odoo_id,
                  caddyId: golfer.caddyId,
                  caddyName: golfer.caddyName,
                  caddyNumber: golfer.caddyNumber
                });
              }
            }
          });
        }
      });

      bookings = filteredBookings;

      // Update legends
      el.legendC.style.display = layout.courses.includes('C') ? '' : 'none';
      el.legendD.style.display = layout.courses.includes('D') ? '' : 'none';

      // Set CSS variable for columns
      document.documentElement.style.setProperty('--cols', layout.cols.length);

      // Render header
      el.gridHeader.innerHTML = '';
      el.gridHeader.innerHTML = `<div class="grid-header-cell time-header">${t('time')}</div>`;
      layout.cols.forEach(col => {
        el.gridHeader.innerHTML += `<div class="grid-header-cell course-${col.course.toLowerCase()}">${col.course}-${col.tee}</div>`;
      });

      // Render rows
      el.gridBody.innerHTML = '';
      for (let m = startM; m <= endM; m += step) {
        const timeStr = hhmm(m);

        let rowHtml = `<div class="grid-row" data-time="${timeStr}">`;
        rowHtml += `<div class="time-cell">${timeStr}</div>`;

        layout.cols.forEach((col, idx) => {
          // Match bookings by col index OR by course+tee (for db bookings)
          const slotBookings = bookings.filter(b => {
            if (!b.time) return false;
            // Exact time match only (no fuzzy matching that creates duplicates)
            const bookingMin = minutes(b.time);
            const slotMin = m;
            // Match if booking is within this slot's range (up to next slot)
            if (bookingMin < slotMin || bookingMin >= slotMin + step) return false;
            // For caddy bookings from DB, always show in first column (Course A, Tee 1)
            if (b.source === 'caddy-booking-db' && idx === 0) return true;
            // Match by col index (local bookings)
            if (b.col === idx) return true;
            // Match by course + tee (database bookings)
            if (b.course === col.course && b.tee === col.tee) return true;
            return false;
          });
          let pillsHtml = '';
          slotBookings.forEach(b => {
            const golfers = b.golfers || [];
            const isSociety = b.bookingType === 'society' || b.type === 'society' || b.type === 'society_event' || (b.groupId && b.groupName);

            // For society events, show members with caddy info
            let caddy = '';
            let memberInfo = '';
            if (isSociety && golfers.length > 0) {
              // Show golfers with caddies (up to 3)
              const golfersWithCaddy = golfers.filter(g => g.caddyName || g.caddyNumber);
              if (golfersWithCaddy.length > 0) {
                memberInfo = golfersWithCaddy.slice(0, 3).map(g => {
                  const caddyInfo = g.caddyNumber ? `C${g.caddyNumber}` : (g.caddyName || '');
                  return `${g.name} (${caddyInfo})`;
                }).join(', ');
                if (golfersWithCaddy.length > 3) {
                  memberInfo += ` +${golfersWithCaddy.length - 3}`;
                }
              }
            } else {
              // Regular booking - show first golfer's caddy
              if (golfers.length > 0 && golfers[0].caddyName) {
                caddy = golfers[0].caddyNumber ? `C${golfers[0].caddyNumber} ${golfers[0].caddyName}` : golfers[0].caddyName;
              } else if (golfers.length > 0 && golfers[0].caddyNumber) {
                caddy = `C${golfers[0].caddyNumber}`;
              }
            }

            const name = golfers.length > 0 ? golfers[0].name : (b.name || t('player'));
            const extra = !isSociety && golfers.length > 1 ? ` +${golfers.length - 1}` : '';

            // Determine group position class for visual styling
            let groupClass = '';
            if (b.groupId && b.groupTotal > 1) {
              groupClass = 'range-group ';
              if (b.groupIndex === 0) groupClass += 'range-start';
              else if (b.groupIndex === b.groupTotal - 1) groupClass += 'range-end';
              else groupClass += 'range-middle';
            }

            // Show group name for group bookings
            const displayName = b.groupName ? `${b.groupName}` : name;
            const groupInfo = b.groupId ? `<span style="opacity:0.7;font-size:10px;">[${b.groupIndex + 1}/${b.groupTotal}]</span> ` : '';

            // For society events, show member count if they have golfers
            const memberCount = isSociety && golfers.length > 0 ? ` (${golfers.length} members)` : extra;

            // Display info: for society show member info, for regular show caddy
            const pillInfoContent = memberInfo || caddy;

            pillsHtml += `<div class="pill ${b.bookingType || 'regular'} ${groupClass}" data-id="${b.id}" data-group-id="${b.groupId || ''}" data-event-id="${b.eventId || ''}" data-society-id="${b.societyId || ''}" draggable="true">
              <div class="pill-name">${groupInfo}${displayName}${memberCount}</div>
              <div class="pill-info">${pillInfoContent}</div>
            </div>`;
          });
          rowHtml += `<div class="slot course-${col.course.toLowerCase()}" data-time="${timeStr}" data-col="${idx}" data-course="${col.course}" data-tee="${col.tee}">${pillsHtml}</div>`;
        });

        rowHtml += `</div>`;
        el.gridBody.innerHTML += rowHtml;
      }

      // Attach slot click handlers
      document.querySelectorAll('.slot').forEach(slot => {
        slot.addEventListener('click', e => {
          if (e.target.closest('.pill')) return;
          openDialog({
            id: '', golfers: [], bookingType: 'regular',
            course: slot.dataset.course, tee: parseInt(slot.dataset.tee),
            time: slot.dataset.time, col: parseInt(slot.dataset.col), notes: ''
          });
        });
      });

      // Attach pill click handlers
      document.querySelectorAll('.pill').forEach(pill => {
        pill.addEventListener('click', e => {
          e.stopPropagation();
          const booking = bookings.find(b => b.id === pill.dataset.id);
          if (booking) openDialog(booking);
        });

        // Drag start
        pill.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/plain', pill.dataset.id);
          pill.style.opacity = '0.5';
        });

        pill.addEventListener('dragend', e => {
          pill.style.opacity = '1';
        });
      });

      // Attach slot drag/drop handlers
      document.querySelectorAll('.slot').forEach(slot => {
        slot.addEventListener('dragover', e => {
          e.preventDefault();
          slot.style.background = '#e0f2fe';
        });

        slot.addEventListener('dragleave', e => {
          slot.style.background = '';
        });

        slot.addEventListener('drop', async e => {
          e.preventDefault();
          slot.style.background = '';
          const bookingId = e.dataTransfer.getData('text/plain');
          if (!bookingId) return;

          const date = el.dateInput.value;
          const bookings = getDay(date);
          const bookingIdx = bookings.findIndex(b => b.id === bookingId);
          if (bookingIdx < 0) return;

          const booking = bookings[bookingIdx];

          // Capture old values for change notification
          const oldTime = booking.time;
          const oldCourse = booking.course;
          const oldTee = booking.tee;
          const newTime = slot.dataset.time;
          const newCourse = slot.dataset.course;
          const newTee = parseInt(slot.dataset.tee);

          // Check if actually changed
          if (oldTime === newTime && oldCourse === newCourse && oldTee === newTee) {
            return; // No change
          }

          // CRITICAL FIX: If booking came from parent BookingManager, remove the original
          // to prevent duplicates when dragging. The booking will be re-synced via setDay()
          if (booking.parentId) {
            console.log('[TeeSheet] Removing original parent booking:', booking.parentId);
            await ParentBridge.removeBookingFromParent(booking.parentId);
          }

          // Update booking with new slot info
          booking.time = newTime;
          booking.col = parseInt(slot.dataset.col);
          booking.course = newCourse;
          booking.tee = newTee;
          booking.lastModifiedBy = 'proshop';
          booking.lastModifiedAt = new Date().toISOString();

          setDay(date, bookings);
          render();

          // CRITICAL: Update caddy bookings in database when dragging
          // Delete old caddy bookings at old time, then create new at new time
          // Must await to prevent race conditions and duplicates
          const golfers = booking.golfers || [];
          for (const golfer of golfers) {
            if (golfer.caddyId) {
              try {
                // Delete old caddy booking first (await to ensure it completes)
                await deleteCaddyBookingFromDb(golfer.caddyId, date, oldTime);
                // Then create new caddy booking at new time
                await saveCaddyBookingToDb(booking, golfer, date, newTime);
                console.log('[TeeSheet] Moved caddy booking:', golfer.caddyName, 'from', oldTime, 'to', newTime);
              } catch (err) {
                console.error('[TeeSheet] Error moving caddy booking:', err);
              }
            }
          }
          // Clear caddy bookings cache to force refresh
          delete caddyBookingsCache[date];
          delete lastFetchTime[date];

          // If this is a society/group booking, sync to parent and send notifications
          if (booking.groupId || booking.eventId || booking.type === 'society' || booking.bookingType === 'society') {
            syncSocietyBookingChange(booking, {
              oldTime, oldCourse, oldTee,
              newTime, newCourse, newTee,
              date
            });
          }
        });
      });
    }

    // ==================== GOLFER ROWS ====================
    function createGolferRow(index, golfer = {}) {
      const row = document.createElement('div');
      row.className = 'golfer-row';
      const hasCaddy = golfer.caddyNumber ? true : false;
      row.innerHTML = `
        <div class="golfer-num">${index + 1}</div>
        <div class="golfer-fields">
          <div class="golfer-field">
            <label>${t('golferName')}</label>
            <div class="caddy-select-wrapper">
              <input type="text" class="golfer-name" placeholder="${t('golferName')}" value="${golfer.name || ''}"
                data-user-id="${golfer.odoo_id || ''}" autocomplete="off">
              <div class="user-dropdown caddy-dropdown"></div>
            </div>
          </div>
          <div class="golfer-field">
            <label>${t('caddy')}</label>
            <div class="caddy-select-wrapper" style="display:flex;gap:4px;">
              <div style="flex:1;position:relative;">
                <input type="text" class="caddy-input" placeholder="${t('searchCaddy')}" style="padding-right:32px;"
                  value="${golfer.caddyNumber ? '#' + golfer.caddyNumber + ' - ' + (golfer.caddyName || '') : ''}"
                  data-caddy-id="${golfer.caddyId || ''}" data-caddy-number="${golfer.caddyNumber || ''}" data-caddy-name="${golfer.caddyName || ''}">
                <button type="button" class="clear-caddy-btn" style="display:${hasCaddy ? 'flex' : 'none'};position:absolute;right:8px;top:50%;transform:translateY(-50%);width:20px;height:20px;border:none;background:#ef4444;color:#fff;border-radius:50%;font-size:14px;cursor:pointer;align-items:center;justify-content:center;line-height:1;">&times;</button>
                <div class="caddy-dropdown"></div>
              </div>
              <button type="button" class="open-picker-btn" title="Browse all caddies">
                <span class="material-icons" style="font-size:14px;margin-right:2px;">search</span>Browse
              </button>
            </div>
          </div>
        </div>
        ${index > 0 ? '<button type="button" class="remove-golfer">&times;</button>' : '<div style="width:32px"></div>'}
      `;

      const golferNameInput = row.querySelector('.golfer-name');
      const userDropdown = row.querySelector('.user-dropdown');
      const caddyInput = row.querySelector('.caddy-input');
      const dropdown = row.querySelector('.caddy-dropdown');
      const clearCaddyBtn = row.querySelector('.clear-caddy-btn');
      const removeBtn = row.querySelector('.remove-golfer');

      // Golfer name autocomplete
      golferNameInput.addEventListener('focus', async () => {
        await fetchSystemUsers(); // Ensure users are loaded
        renderUserDropdown(userDropdown, golferNameInput, '');
        userDropdown.classList.add('show');
      });
      golferNameInput.addEventListener('input', () => {
        renderUserDropdown(userDropdown, golferNameInput, golferNameInput.value);
        userDropdown.classList.add('show');
        // Clear user ID if manually typing (will be re-matched on save)
        golferNameInput.dataset.userId = '';
      });
      golferNameInput.addEventListener('blur', () => setTimeout(() => userDropdown.classList.remove('show'), 200));

      // Show/hide clear button based on caddy selection
      function updateClearBtn() {
        clearCaddyBtn.style.display = caddyInput.dataset.caddyNumber ? 'flex' : 'none';
      }

      caddyInput.addEventListener('focus', () => { renderCaddyDropdown(dropdown, caddyInput, ''); dropdown.classList.add('show'); });
      caddyInput.addEventListener('input', () => { renderCaddyDropdown(dropdown, caddyInput, caddyInput.value); dropdown.classList.add('show'); });
      caddyInput.addEventListener('blur', () => setTimeout(() => dropdown.classList.remove('show'), 200));

      // Clear caddy button
      clearCaddyBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        caddyInput.value = '';
        caddyInput.dataset.caddyId = '';
        caddyInput.dataset.caddyNumber = '';
        caddyInput.dataset.caddyName = '';
        updateClearBtn();
      });

      // Store updateClearBtn reference for external updates
      caddyInput._updateClearBtn = updateClearBtn;

      // Open caddy picker modal button
      const openPickerBtn = row.querySelector('.open-picker-btn');
      if (openPickerBtn) {
        openPickerBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          CaddyPicker.open(caddyInput);
        });
      }

      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          if (el.golfersList.children.length > 1) {
            row.remove();
            renumberGolfers();
          }
        });
      }

      return row;
    }

    function renderCaddyDropdown(dropdown, input, query) {
      dropdown.innerHTML = '';
      query = (query || '').toLowerCase();

      // Get booked caddies for current time slot (from other bookings)
      const currentTime = el.bookingTime.value;
      const bookedCaddies = getBookedCaddiesForSlot(el.dateInput.value, currentTime, currentEditingBookingId);

      // Also get caddies already assigned to OTHER golfers in THIS booking dialog
      const caddiesInThisGroup = new Set();
      const currentInputCaddyNumber = input.dataset.caddyNumber || '';
      Array.from(el.golfersList.children).forEach(row => {
        const caddyInput = row.querySelector('.caddy-input');
        if (caddyInput && caddyInput !== input) {
          const caddyNum = caddyInput.dataset.caddyNumber;
          if (caddyNum) caddiesInThisGroup.add(caddyNum);
        }
      });

      // Combine: external bookings + other golfers in same group
      const allUnavailable = new Set([...bookedCaddies, ...caddiesInThisGroup]);

      // No caddy option
      const noCaddyOpt = document.createElement('div');
      noCaddyOpt.className = 'caddy-option';
      noCaddyOpt.innerHTML = `<span class="caddy-option-name">${t('noCaddy')}</span>`;
      noCaddyOpt.addEventListener('mousedown', e => {
        e.preventDefault();
        input.value = '';
        input.dataset.caddyId = '';
        input.dataset.caddyNumber = '';
        input.dataset.caddyName = '';
      });
      dropdown.appendChild(noCaddyOpt);

      // Filter caddies - show all but mark booked/assigned ones (search includes local name for Thai/Korean/Japanese)
      allCaddies.filter(c => c.status === 'available' && (!query || (c.number + ' ' + c.name + ' ' + (c.localName || '')).toLowerCase().includes(query)))
        .slice(0, 10).forEach(caddy => {
          const isBookedExternal = bookedCaddies.has(caddy.number);
          const isInThisGroup = caddiesInThisGroup.has(caddy.number);
          const isUnavailable = isBookedExternal || isInThisGroup;
          const opt = document.createElement('div');
          opt.className = `caddy-option ${isUnavailable ? 'booked' : ''}`;
          opt.title = isUnavailable ? t('caddyAlreadyBooked') : '';
          const stars = '‚òÖ'.repeat(Math.floor(caddy.rating));
          const badgeText = isInThisGroup ? t('inGroup') : (isBookedExternal ? t('booked') : '');
          const bookedBadge = isUnavailable ? `<span class="caddy-booked-badge">${badgeText}</span>` : '';
          // Show local name based on current language
          const displayName = (currentLang !== 'en' && caddy.localName) ? `${caddy.localName} (${caddy.name})` : caddy.name;
          opt.innerHTML = `<span class="caddy-option-name">#${caddy.number} ${displayName}${bookedBadge}</span>
            <span class="caddy-option-rating">${stars} ${caddy.rating}</span>
            <div class="caddy-option-info">${caddy.language}</div>`;

          if (!isUnavailable) {
            opt.addEventListener('mousedown', e => {
              e.preventDefault();
              // Display local name if available and language is not English
              const displayName = (currentLang !== 'en' && caddy.localName) ? caddy.localName : caddy.name;
              input.value = `${caddy.number} - ${displayName}`;
              input.dataset.caddyId = caddy.id;
              input.dataset.caddyNumber = caddy.number;
              input.dataset.caddyName = caddy.name;
              input.dataset.caddyLocalName = caddy.localName || '';
              // Show the clear button
              if (input._updateClearBtn) input._updateClearBtn();
            });
          } else {
            opt.addEventListener('mousedown', e => {
              e.preventDefault();
              // Show alert that caddy is already booked/assigned
              alert(isInThisGroup ? t('caddyInGroup') : t('caddyAlreadyBooked'));
            });
          }
          dropdown.appendChild(opt);
        });
    }

    function renumberGolfers() {
      Array.from(el.golfersList.children).forEach((row, i) => {
        row.querySelector('.golfer-num').textContent = i + 1;
      });
    }

    // Caddy Picker Modal
    const CaddyPicker = {
      modal: null,
      grid: null,
      searchInput: null,
      statsEl: null,
      currentInput: null,  // The caddy input that triggered the picker
      bookedCaddies: new Set(),
      inGroupCaddies: new Set(),
      dailyBookings: {},  // Caddy ID -> array of booking times for the day

      init() {
        this.modal = $('caddy-picker-modal');
        this.grid = $('caddy-picker-grid');
        this.searchInput = $('caddy-picker-search');
        this.statsEl = $('caddy-picker-stats');

        // Close button
        $('caddy-picker-close')?.addEventListener('click', () => this.close());

        // Search input
        this.searchInput?.addEventListener('input', () => this.render());

        // Close on backdrop click
        this.modal?.addEventListener('click', e => {
          if (e.target === this.modal) this.close();
        });

        // ESC to close
        this.modal?.addEventListener('keydown', e => {
          if (e.key === 'Escape') this.close();
        });
      },

      async open(inputElement) {
        if (!this.modal) return;

        this.currentInput = inputElement;
        this.searchInput.value = '';

        // Get booked caddies for current time slot
        const currentTime = el.bookingTime.value;
        this.bookedCaddies = getBookedCaddiesForSlot(el.dateInput.value, currentTime, currentEditingBookingId);

        // Get caddies already in this booking group
        this.inGroupCaddies = new Set();
        const currentInputCaddyNumber = inputElement?.dataset?.caddyNumber || '';
        Array.from(el.golfersList.children).forEach(row => {
          const caddyInput = row.querySelector('.caddy-input');
          if (caddyInput && caddyInput !== inputElement) {
            const caddyNum = caddyInput.dataset.caddyNumber;
            if (caddyNum) this.inGroupCaddies.add(caddyNum);
          }
        });

        // Fetch all caddy bookings for this date
        await this.fetchDailyBookings();

        this.render();
        this.modal.showModal();
        this.searchInput.focus();
      },

      async fetchDailyBookings() {
        this.dailyBookings = {};
        const currentDate = el.dateInput.value;
        const courseId = el?.courseSelect?.value || '';
        const courseName = courseIdToDbName[courseId] || '';

        if (!supabaseClient) return;

        try {
          let query = supabaseClient
            .from('caddy_bookings')
            .select('caddy_id, tee_time, golfer_name, caddy_profiles(caddy_number)')
            .eq('booking_date', currentDate)
            .neq('status', 'cancelled');

          if (courseName) {
            query = query.eq('course_name', courseName);
          }

          const { data, error } = await query;

          if (error) {
            console.error('[CaddyPicker] Error fetching daily bookings:', error);
            return;
          }

          // Group by caddy number
          (data || []).forEach(b => {
            const caddyNum = b.caddy_profiles?.caddy_number;
            if (!caddyNum) return;
            if (!this.dailyBookings[caddyNum]) {
              this.dailyBookings[caddyNum] = [];
            }
            const time = b.tee_time ? b.tee_time.substring(0, 5) : '??:??';
            this.dailyBookings[caddyNum].push({
              time,
              golfer: b.golfer_name || 'Guest'
            });
          });

          // Sort each caddy's bookings by time
          Object.keys(this.dailyBookings).forEach(num => {
            this.dailyBookings[num].sort((a, b) => a.time.localeCompare(b.time));
          });

          console.log('[CaddyPicker] Loaded daily bookings for', Object.keys(this.dailyBookings).length, 'caddies');
        } catch (e) {
          console.error('[CaddyPicker] Fetch error:', e);
        }
      },

      close() {
        this.modal?.close();
        this.currentInput = null;
      },

      render() {
        if (!this.grid) return;

        const query = (this.searchInput?.value || '').toLowerCase();

        // Filter and sort caddies
        let filtered = allCaddies.filter(c => {
          if (c.status !== 'available') return false;
          if (!query) return true;
          const searchText = `${c.number} ${c.name} ${c.localName || ''} ${c.language || ''}`.toLowerCase();
          return searchText.includes(query);
        });

        // Sort by number
        filtered.sort((a, b) => parseInt(a.number) - parseInt(b.number));

        // Update stats
        const total = allCaddies.filter(c => c.status === 'available').length;
        const showing = filtered.length;
        const booked = this.bookedCaddies.size;
        this.statsEl.textContent = `Showing ${showing} of ${total} caddies ‚Ä¢ ${booked} already booked for this time`;

        // Render grid
        this.grid.innerHTML = '';

        // "No Caddy" option first
        const noCaddyCard = document.createElement('div');
        noCaddyCard.className = 'caddy-card';
        noCaddyCard.style.background = '#f8fafc';
        noCaddyCard.innerHTML = `
          <div class="caddy-card-photo" style="background:#e5e7eb;display:flex;align-items:center;justify-content:center;">
            <span class="material-icons" style="color:#9ca3af;font-size:24px;">person_off</span>
          </div>
          <div class="caddy-card-number" style="color:#6b7280;">‚Äî</div>
          <div class="caddy-card-name">${t('noCaddy')}</div>
        `;
        noCaddyCard.addEventListener('click', () => {
          this.selectCaddy(null);
        });
        this.grid.appendChild(noCaddyCard);

        // Render caddy cards
        filtered.forEach(caddy => {
          const isBookedExternal = this.bookedCaddies.has(caddy.number);
          const isInGroup = this.inGroupCaddies.has(caddy.number);
          const isUnavailable = isBookedExternal || isInGroup;

          const card = document.createElement('div');
          card.className = `caddy-card ${isUnavailable ? 'unavailable' : ''}`;

          const stars = '‚òÖ'.repeat(Math.floor(caddy.rating));
          const displayName = (currentLang !== 'en' && caddy.localName) ? caddy.localName : caddy.name;
          const photoUrl = caddy.photoUrl || caddy.photo_url || '';

          let statusBadge = '';
          if (isInGroup) {
            statusBadge = `<div class="caddy-card-status in-group">${t('inGroup')}</div>`;
          } else if (isBookedExternal) {
            statusBadge = `<div class="caddy-card-status booked">${t('booked')}</div>`;
          }

          // Get daily bookings for this caddy
          const dayBookings = this.dailyBookings[caddy.number] || [];
          let bookingsHtml = '';
          if (dayBookings.length > 0) {
            const bookingsList = dayBookings.map(b => `${b.time}`).join(', ');
            bookingsHtml = `<div class="caddy-card-bookings" style="font-size:10px;color:#6b7280;margin-top:4px;background:#f1f5f9;padding:3px 6px;border-radius:4px;">
              üìÖ ${dayBookings.length} today: ${bookingsList}
            </div>`;
          }

          card.innerHTML = `
            ${photoUrl ?
              `<img class="caddy-card-photo" src="${photoUrl}" alt="${caddy.name}" onerror="this.style.display='none'">` :
              `<div class="caddy-card-photo" style="display:flex;align-items:center;justify-content:center;">
                <span class="material-icons" style="color:#9ca3af;font-size:24px;">person</span>
              </div>`
            }
            <div class="caddy-card-number">#${caddy.number}</div>
            <div class="caddy-card-name">${displayName}</div>
            <div class="caddy-card-rating">${stars} ${caddy.rating.toFixed(1)}</div>
            ${caddy.language ? `<div class="caddy-card-lang">${caddy.language}</div>` : ''}
            ${statusBadge}
            ${bookingsHtml}
          `;

          if (!isUnavailable) {
            card.addEventListener('click', () => {
              this.selectCaddy(caddy);
            });
          } else {
            card.addEventListener('click', () => {
              alert(isInGroup ? t('caddyInGroup') : t('caddyAlreadyBooked'));
            });
          }

          this.grid.appendChild(card);
        });
      },

      selectCaddy(caddy) {
        if (!this.currentInput) return;

        if (caddy === null) {
          // Clear caddy selection
          this.currentInput.value = '';
          this.currentInput.dataset.caddyId = '';
          this.currentInput.dataset.caddyNumber = '';
          this.currentInput.dataset.caddyName = '';
          this.currentInput.dataset.caddyLocalName = '';
        } else {
          const displayName = (currentLang !== 'en' && caddy.localName) ? caddy.localName : caddy.name;
          this.currentInput.value = `${caddy.number} - ${displayName}`;
          this.currentInput.dataset.caddyId = caddy.id;
          this.currentInput.dataset.caddyNumber = caddy.number;
          this.currentInput.dataset.caddyName = caddy.name;
          this.currentInput.dataset.caddyLocalName = caddy.localName || '';
        }

        // Update clear button if available
        if (this.currentInput._updateClearBtn) {
          this.currentInput._updateClearBtn();
        }

        this.close();
      }
    };

    function getGolfersFromDialog() {
      return Array.from(el.golfersList.children).map(row => {
        const nameInput = row.querySelector('input.golfer-name');
        const caddyInput = row.querySelector('input.caddy-input');
        if (!nameInput) return null;
        return {
          name: nameInput.value.trim(),
          odoo_id: nameInput.dataset.userId || null, // User ID from autocomplete selection
          caddyId: caddyInput?.dataset.caddyId || null,
          caddyNumber: caddyInput?.dataset.caddyNumber || '',
          caddyName: caddyInput?.dataset.caddyName || '',
          caddyLocalName: caddyInput?.dataset.caddyLocalName || ''
        };
      }).filter(g => g && g.name);
    }

    function setGolfersInDialog(golfers) {
      el.golfersList.innerHTML = '';
      (golfers.length ? golfers : [{}]).forEach((g, i) => {
        el.golfersList.appendChild(createGolferRow(i, g));
      });
    }

    el.addGolfer.addEventListener('click', () => {
      if (el.golfersList.children.length < 4) {
        el.golfersList.appendChild(createGolferRow(el.golfersList.children.length, {}));
      }
    });

    // ==================== RANGE BOOKING MODE ====================
    function toggleRangeMode(enabled) {
      el.singleBookingRow.style.display = enabled ? 'none' : '';
      el.singleGolfersSection.style.display = enabled ? 'none' : '';
      el.rangeTimeRow.style.display = enabled ? '' : 'none';
      el.rangeGroupNameRow.style.display = enabled ? '' : 'none';
      el.rangeSlotsSection.style.display = enabled ? '' : 'none';

      if (enabled) {
        updateRangeSlots();
      }
    }

    function getTimeSlots(startTime, endTime) {
      const startM = minutes(startTime);
      const endM = minutes(endTime);
      const step = parseInt(el.intervalSelect.value) || 7;
      const slots = [];

      for (let m = startM; m <= endM; m += step) {
        slots.push(hhmm(m));
      }
      return slots;
    }

    function updateRangeSlots() {
      const startTime = el.rangeStartTime.value;
      const endTime = el.rangeEndTime.value;

      if (!startTime || !endTime || minutes(startTime) > minutes(endTime)) {
        el.rangeInfo.textContent = '';
        el.slotCountBadge.textContent = t('slotsCount').replace('{n}', '0');
        rangeSlots = [];
        renderRangeSlots();
        return;
      }

      const slots = getTimeSlots(startTime, endTime);
      el.rangeInfo.textContent = `${slots.length} ${t('timeSlots').toLowerCase()}`;
      el.slotCountBadge.textContent = t('slotsCount').replace('{n}', slots.length);

      // Preserve existing slot data when updating
      const existingSlotMap = {};
      rangeSlots.forEach(s => { existingSlotMap[s.time] = s; });

      rangeSlots = slots.map(time => {
        if (existingSlotMap[time]) {
          return existingSlotMap[time];
        }
        return {
          time,
          golfers: [{ name: '', caddyId: null, caddyNumber: '', caddyName: '' }],
          collapsed: true
        };
      });

      renderRangeSlots();
    }

    function renderRangeSlots() {
      el.rangeSlotsList.innerHTML = '';

      rangeSlots.forEach((slot, slotIdx) => {
        const card = document.createElement('div');
        card.className = `slot-card ${slot.collapsed ? 'collapsed' : ''}`;
        card.dataset.slotIdx = slotIdx;

        const golferNames = slot.golfers.filter(g => g.name).map(g => g.name).join(', ');
        const caddyNums = slot.golfers.filter(g => g.caddyNumber).map(g => `C${g.caddyNumber}`).join(', ');
        const summary = golferNames || t('noGolfers');

        card.innerHTML = `
          <div class="slot-header">
            <span class="slot-time-badge">${slot.time}</span>
            <div class="slot-summary">
              <span class="names">${summary}</span>
              ${caddyNums ? ` <span style="color:var(--muted)">‚Ä¢ ${caddyNums}</span>` : ''}
            </div>
            <span class="slot-expand-icon">‚ñº</span>
          </div>
          <div class="slot-body" id="slot-body-${slotIdx}"></div>
        `;

        const header = card.querySelector('.slot-header');
        header.addEventListener('click', () => {
          slot.collapsed = !slot.collapsed;
          card.classList.toggle('collapsed');
        });

        el.rangeSlotsList.appendChild(card);

        // Render golfer rows inside slot body
        const slotBody = card.querySelector(`#slot-body-${slotIdx}`);
        renderSlotGolfers(slotBody, slot, slotIdx);
      });
    }

    function renderSlotGolfers(container, slot, slotIdx) {
      container.innerHTML = '';

      slot.golfers.forEach((golfer, gIdx) => {
        const row = createSlotGolferRow(slotIdx, gIdx, golfer);
        container.appendChild(row);
      });

      // Add golfer button (max 4 per slot)
      if (slot.golfers.length < 4) {
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'add-golfer-btn';
        addBtn.textContent = t('addGolfer');
        addBtn.style.marginTop = '8px';
        addBtn.addEventListener('click', () => {
          slot.golfers.push({ name: '', caddyId: null, caddyNumber: '', caddyName: '' });
          renderSlotGolfers(container, slot, slotIdx);
          updateSlotCardSummary(slotIdx);
        });
        container.appendChild(addBtn);
      }
    }

    function createSlotGolferRow(slotIdx, gIdx, golfer) {
      const row = document.createElement('div');
      row.className = 'golfer-row';
      row.style.marginBottom = '8px';
      row.innerHTML = `
        <div class="golfer-num">${gIdx + 1}</div>
        <div class="golfer-fields">
          <div class="golfer-field">
            <label>${t('golferName')}</label>
            <input type="text" class="slot-golfer-name" placeholder="${t('golferName')}" value="${golfer.name || ''}"
              data-slot="${slotIdx}" data-golfer="${gIdx}">
          </div>
          <div class="golfer-field">
            <label>${t('caddy')}</label>
            <div class="caddy-select-wrapper">
              <input type="text" class="slot-caddy-input" placeholder="${t('searchCaddy')}"
                value="${golfer.caddyNumber ? '#' + golfer.caddyNumber + ' - ' + (golfer.caddyName || '') : ''}"
                data-caddy-id="${golfer.caddyId || ''}" data-caddy-number="${golfer.caddyNumber || ''}" data-caddy-name="${golfer.caddyName || ''}"
                data-slot="${slotIdx}" data-golfer="${gIdx}">
              <div class="caddy-dropdown"></div>
            </div>
          </div>
        </div>
        ${gIdx > 0 ? '<button type="button" class="remove-golfer">&times;</button>' : '<div style="width:32px"></div>'}
      `;

      // Name input handler
      const nameInput = row.querySelector('.slot-golfer-name');
      nameInput.addEventListener('input', () => {
        rangeSlots[slotIdx].golfers[gIdx].name = nameInput.value.trim();
        updateSlotCardSummary(slotIdx);
      });

      // Caddy input handler
      const caddyInput = row.querySelector('.slot-caddy-input');
      const dropdown = row.querySelector('.caddy-dropdown');

      caddyInput.addEventListener('focus', () => { renderCaddyDropdownForSlot(dropdown, caddyInput, '', slotIdx, gIdx); dropdown.classList.add('show'); });
      caddyInput.addEventListener('input', () => { renderCaddyDropdownForSlot(dropdown, caddyInput, caddyInput.value, slotIdx, gIdx); dropdown.classList.add('show'); });
      caddyInput.addEventListener('blur', () => setTimeout(() => dropdown.classList.remove('show'), 200));

      // Remove button
      const removeBtn = row.querySelector('.remove-golfer');
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          if (rangeSlots[slotIdx].golfers.length > 1) {
            rangeSlots[slotIdx].golfers.splice(gIdx, 1);
            const slotBody = document.getElementById(`slot-body-${slotIdx}`);
            if (slotBody) renderSlotGolfers(slotBody, rangeSlots[slotIdx], slotIdx);
            updateSlotCardSummary(slotIdx);
          }
        });
      }

      return row;
    }

    function renderCaddyDropdownForSlot(dropdown, input, query, slotIdx, gIdx) {
      dropdown.innerHTML = '';
      query = (query || '').toLowerCase();

      // Get the specific time for this slot
      const slotTime = rangeSlots[slotIdx]?.time;
      const editingGroupId = el.bookingGroupId.value || null;

      // Get booked caddies for this specific time slot
      const bookedCaddies = getBookedCaddiesForSlot(el.dateInput.value, slotTime, null);

      // Also check what caddies are already assigned in OTHER slots of the same group at THIS time
      // (Allow same caddy in different time slots of same group, but not same time)
      const currentGroupCaddiesAtTime = new Set();
      rangeSlots.forEach((slot, idx) => {
        if (slot.time === slotTime && idx !== slotIdx) {
          slot.golfers.forEach(g => {
            if (g.caddyNumber) currentGroupCaddiesAtTime.add(g.caddyNumber);
          });
        }
      });

      // Combine external bookings with current group assignments at same time
      const allBookedForTime = new Set([...bookedCaddies, ...currentGroupCaddiesAtTime]);

      const noCaddyOpt = document.createElement('div');
      noCaddyOpt.className = 'caddy-option';
      noCaddyOpt.innerHTML = `<span class="caddy-option-name">${t('noCaddy')}</span>`;
      noCaddyOpt.addEventListener('mousedown', e => {
        e.preventDefault();
        input.value = '';
        input.dataset.caddyId = '';
        input.dataset.caddyNumber = '';
        input.dataset.caddyName = '';
        rangeSlots[slotIdx].golfers[gIdx].caddyId = null;
        rangeSlots[slotIdx].golfers[gIdx].caddyNumber = '';
        rangeSlots[slotIdx].golfers[gIdx].caddyName = '';
        updateSlotCardSummary(slotIdx);
      });
      dropdown.appendChild(noCaddyOpt);

      allCaddies.filter(c => c.status === 'available' && (!query || (c.number + ' ' + c.name + ' ' + (c.localName || '')).toLowerCase().includes(query)))
        .slice(0, 10).forEach(caddy => {
          const isBooked = allBookedForTime.has(caddy.number);
          const opt = document.createElement('div');
          opt.className = `caddy-option ${isBooked ? 'booked' : ''}`;
          opt.title = isBooked ? t('caddyAlreadyBooked') : '';
          const stars = '‚òÖ'.repeat(Math.floor(caddy.rating));
          const bookedBadge = isBooked ? `<span class="caddy-booked-badge">${t('booked')}</span>` : '';
          // Show local name based on current language
          const displayName = (currentLang !== 'en' && caddy.localName) ? `${caddy.localName} (${caddy.name})` : caddy.name;
          opt.innerHTML = `<span class="caddy-option-name">#${caddy.number} ${displayName}${bookedBadge}</span>
            <span class="caddy-option-rating">${stars} ${caddy.rating}</span>
            <div class="caddy-option-info">${caddy.language}</div>`;

          if (!isBooked) {
            opt.addEventListener('mousedown', e => {
              e.preventDefault();
              // Display local name if available and language is not English
              const displayName = (currentLang !== 'en' && caddy.localName) ? caddy.localName : caddy.name;
              input.value = `${caddy.number} - ${displayName}`;
              input.dataset.caddyId = caddy.id;
              input.dataset.caddyNumber = caddy.number;
              input.dataset.caddyName = caddy.name;
              input.dataset.caddyLocalName = caddy.localName || '';
              rangeSlots[slotIdx].golfers[gIdx].caddyId = caddy.id;
              rangeSlots[slotIdx].golfers[gIdx].caddyNumber = caddy.number;
              rangeSlots[slotIdx].golfers[gIdx].caddyName = caddy.name;
              rangeSlots[slotIdx].golfers[gIdx].caddyLocalName = caddy.localName || '';
              updateSlotCardSummary(slotIdx);
            });
          } else {
            opt.addEventListener('mousedown', e => {
              e.preventDefault();
              alert(t('caddyAlreadyBooked'));
            });
          }
          dropdown.appendChild(opt);
        });
    }

    function updateSlotCardSummary(slotIdx) {
      const slot = rangeSlots[slotIdx];
      const card = document.querySelector(`.slot-card[data-slot-idx="${slotIdx}"]`);
      if (!card) return;

      const golferNames = slot.golfers.filter(g => g.name).map(g => g.name).join(', ');
      const caddyNums = slot.golfers.filter(g => g.caddyNumber).map(g => `C${g.caddyNumber}`).join(', ');
      const summary = golferNames || t('noGolfers');

      const summaryEl = card.querySelector('.slot-summary');
      if (summaryEl) {
        summaryEl.innerHTML = `<span class="names">${summary}</span>${caddyNums ? ` <span style="color:var(--muted)">‚Ä¢ ${caddyNums}</span>` : ''}`;
      }
    }

    // Range mode toggle handler
    el.rangeModeToggle.addEventListener('change', () => {
      toggleRangeMode(el.rangeModeToggle.checked);
    });

    // Range time change handlers
    el.rangeStartTime.addEventListener('change', updateRangeSlots);
    el.rangeEndTime.addEventListener('change', updateRangeSlots);

    // ==================== RECURRING BOOKING ====================
    el.recurringToggle?.addEventListener('change', () => {
      const show = el.recurringToggle.checked;
      el.recurringOptions.style.display = show ? 'block' : 'none';
      if (show) {
        // Set default end date to 3 months from now
        const defaultEnd = new Date(el.dateInput.value);
        defaultEnd.setMonth(defaultEnd.getMonth() + 3);
        el.recurringUntil.value = defaultEnd.toISOString().split('T')[0];
        // Default to current day of week checked
        const currentDow = new Date(el.dateInput.value).getDay();
        document.querySelectorAll('input[name="weekday"]').forEach(cb => {
          cb.checked = parseInt(cb.value) === currentDow;
        });
        updateRecurringPreview();
      }
    });

    el.recurringFrequency?.addEventListener('change', () => {
      const freq = el.recurringFrequency.value;
      // Show weekdays row only for weekly/biweekly
      el.weekdaysRow.style.display = (freq === 'weekly' || freq === 'biweekly') ? 'flex' : 'none';
      updateRecurringPreview();
    });

    el.recurringUntil?.addEventListener('change', updateRecurringPreview);
    el.recurringCount?.addEventListener('input', updateRecurringPreview);
    document.querySelectorAll('input[name="weekday"]').forEach(cb => {
      cb.addEventListener('change', updateRecurringPreview);
    });

    function getRecurringDates() {
      const startDate = new Date(el.dateInput.value + 'T00:00:00');
      const frequency = el.recurringFrequency.value;
      const untilDate = el.recurringUntil.value ? new Date(el.recurringUntil.value + 'T23:59:59') : null;
      const maxCount = parseInt(el.recurringCount.value) || 52;
      const selectedDays = Array.from(document.querySelectorAll('input[name="weekday"]:checked')).map(cb => parseInt(cb.value));

      const dates = [];
      let current = new Date(startDate);
      let count = 0;

      // Max iterations to prevent infinite loops
      const maxIterations = 365;
      let iterations = 0;

      while (iterations < maxIterations && count < maxCount && (!untilDate || current <= untilDate)) {
        if (frequency === 'daily') {
          dates.push(new Date(current));
          count++;
          current.setDate(current.getDate() + 1);
        } else if (frequency === 'weekly' || frequency === 'biweekly') {
          if (selectedDays.length === 0 || selectedDays.includes(current.getDay())) {
            dates.push(new Date(current));
            count++;
          }
          current.setDate(current.getDate() + 1);
          // For biweekly, skip to next week after completing one week
          if (frequency === 'biweekly' && current.getDay() === startDate.getDay()) {
            current.setDate(current.getDate() + 7);
          }
        } else if (frequency === 'monthly') {
          dates.push(new Date(current));
          count++;
          current.setMonth(current.getMonth() + 1);
        }
        iterations++;
      }

      return dates;
    }

    function updateRecurringPreview() {
      if (!el.recurringToggle?.checked) return;
      const dates = getRecurringDates();
      if (dates.length > 0) {
        const lastDate = dates[dates.length - 1];
        const dateStr = lastDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        el.recurringPreview.innerHTML = t('recurringPreview').replace('{n}', `<strong>${dates.length}</strong>`).replace('{date}', `<strong>${dateStr}</strong>`);
      } else {
        el.recurringPreview.innerHTML = t('noDatesSelected');
      }
    }

    function resetRecurringSection() {
      el.recurringToggle.checked = false;
      el.recurringOptions.style.display = 'none';
      el.recurringFrequency.value = 'weekly';
      el.recurringUntil.value = '';
      el.recurringCount.value = '';
      el.weekdaysRow.style.display = 'flex';
      document.querySelectorAll('input[name="weekday"]').forEach(cb => cb.checked = false);
      el.recurringPreview.innerHTML = '';
    }

    // ==================== DIALOG ====================
    async function openDialog(seed) {
      // Ensure caddies are loaded before opening dialog
      if (allCaddies.length === 0) {
        await refreshCaddies();
      }

      // Set the current editing booking ID for caddy availability check
      currentEditingBookingId = seed.id || null;

      el.bookingId.value = seed.id || '';
      el.bookingGroupId.value = seed.groupId || '';
      el.bookingType.value = seed.bookingType || 'regular';
      el.bookingNotes.value = seed.notes || '';

      // Populate time dropdowns with all available time slots
      const startM = minutes(el.startTime.value);
      const endM = minutes(el.endTime.value);
      const step = parseInt(el.intervalSelect.value) || 7;

      // Single booking time
      el.bookingTime.innerHTML = '';
      for (let m = startM; m <= endM; m += step) {
        const timeStr = hhmm(m);
        const opt = document.createElement('option');
        opt.value = timeStr;
        opt.textContent = timeStr;
        if (timeStr === seed.time) opt.selected = true;
        el.bookingTime.appendChild(opt);
      }

      // Range booking times
      el.rangeStartTime.innerHTML = '';
      el.rangeEndTime.innerHTML = '';
      for (let m = startM; m <= endM; m += step) {
        const timeStr = hhmm(m);
        const optStart = document.createElement('option');
        optStart.value = timeStr;
        optStart.textContent = timeStr;
        if (timeStr === seed.time) optStart.selected = true;
        el.rangeStartTime.appendChild(optStart);

        const optEnd = document.createElement('option');
        optEnd.value = timeStr;
        optEnd.textContent = timeStr;
        el.rangeEndTime.appendChild(optEnd);
      }

      // Set a default end time (1 hour after start)
      const defaultEndM = Math.min(minutes(seed.time) + 60, endM);
      el.rangeEndTime.value = hhmm(defaultEndM);

      // Populate course dropdowns
      const courses = getCourses();
      el.bookingCourse.innerHTML = '';
      el.rangeCourse.innerHTML = '';
      courses.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = t('course') + ' ' + c;
        if (c === seed.course) opt.selected = true;
        el.bookingCourse.appendChild(opt);

        const optRange = document.createElement('option');
        optRange.value = c;
        optRange.textContent = t('course') + ' ' + c;
        if (c === seed.course) optRange.selected = true;
        el.rangeCourse.appendChild(optRange);
      });

      el.bookingTee.value = seed.tee || 1;
      el.rangeTee.value = seed.tee || 1;

      // Reset range mode
      el.rangeModeToggle.checked = false;
      rangeSlots = [];
      el.rangeGroupName.value = '';
      toggleRangeMode(false);
      resetRecurringSection();

      // Check if this is part of a group booking - if so, open group edit mode
      if (seed.groupId) {
        const date = el.dateInput.value;
        const bookings = getDay(date);
        const groupBookings = bookings.filter(b => b.groupId === seed.groupId);

        if (groupBookings.length > 1) {
          el.rangeModeToggle.checked = true;
          el.rangeGroupName.value = seed.groupName || '';
          el.rangeType.value = seed.bookingType || 'society';

          // Sort by time and set range
          groupBookings.sort((a, b) => minutes(a.time) - minutes(b.time));
          el.rangeStartTime.value = groupBookings[0].time;
          el.rangeEndTime.value = groupBookings[groupBookings.length - 1].time;

          // Populate rangeSlots with existing data
          rangeSlots = groupBookings.map(b => ({
            time: b.time,
            golfers: b.golfers || [{ name: b.name || '', caddyNumber: b.caddyNumber || '', caddyId: null, caddyName: '' }],
            collapsed: true,
            id: b.id
          }));

          toggleRangeMode(true);
        }
      }

      let golfers = seed.golfers || [];
      if (!golfers.length && seed.name) golfers = [{ name: seed.name, caddyNumber: seed.caddyNumber || '' }];
      setGolfersInDialog(golfers);

      el.deleteBooking.style.display = seed.id ? '' : 'none';
      el.dialog.showModal();
    }

    el.closeDialog.addEventListener('click', () => el.dialog.close());
    el.cancelBooking.addEventListener('click', () => el.dialog.close());

    el.saveBooking.addEventListener('click', () => {
      const date = el.dateInput.value;
      let bookings = getDay(date);
      const layout = getLayout();

      // ==================== DOUBLE BOOKING VALIDATION ====================
      function validateNoDuplicateCaddies(golfersToSave, time, excludeBookingId = null) {
        const bookedCaddies = getBookedCaddiesForSlot(date, time, excludeBookingId);
        const conflicts = [];
        golfersToSave.forEach(g => {
          if (g.caddyNumber && bookedCaddies.has(g.caddyNumber)) {
            conflicts.push(`${g.caddyName || g.caddyNumber} @ ${time}`);
          }
        });
        return conflicts;
      }

      // Check if range mode is enabled
      if (el.rangeModeToggle.checked && rangeSlots.length > 0) {
        // Range booking mode - create/update multiple bookings
        const course = el.rangeCourse.value;
        const tee = parseInt(el.rangeTee.value);
        const colIndex = layout.cols.findIndex(c => c.course === course && c.tee === tee);
        const bookingType = el.rangeType.value;
        const groupName = el.rangeGroupName.value.trim();
        const notes = el.bookingNotes.value;

        // Use existing groupId or create new one
        const groupId = el.bookingGroupId.value || genId();

        // Remove existing group bookings if editing
        if (el.bookingGroupId.value) {
          bookings = bookings.filter(b => b.groupId !== el.bookingGroupId.value);
        }

        // Validate no double-booked caddies in range mode
        const allConflicts = [];
        rangeSlots.forEach(slot => {
          const golfers = slot.golfers.filter(g => g.name && g.caddyNumber);
          const conflicts = validateNoDuplicateCaddies(golfers, slot.time, slot.id);
          allConflicts.push(...conflicts);
        });

        if (allConflicts.length > 0) {
          alert(`${t('caddyAlreadyBooked')}:\n\n${allConflicts.join('\n')}`);
          return;
        }

        // Create bookings for each slot
        rangeSlots.forEach((slot, idx) => {
          const golfers = slot.golfers.filter(g => g.name);
          if (!golfers.length) golfers.push({ name: groupName || t('player'), caddyNumber: '', caddyId: null, caddyName: '' });

          const booking = {
            id: slot.id || genId(),
            groupId,
            groupName,
            groupIndex: idx,
            groupTotal: rangeSlots.length,
            bookingType,
            course, tee, col: colIndex,
            time: slot.time,
            golfers,
            notes,
            name: golfers[0]?.name || groupName || '',
            caddyNumber: golfers[0]?.caddyNumber || ''
          };

          bookings.push(booking);
        });

        console.log(`[TeeSheet] Saved group booking: ${rangeSlots.length} slots, groupId=${groupId}`);

      } else {
        // Single booking mode
        const course = el.bookingCourse.value;
        const tee = parseInt(el.bookingTee.value);
        const colIndex = layout.cols.findIndex(c => c.course === course && c.tee === tee);
        const golfers = getGolfersFromDialog();
        const bookingTime = el.bookingTime.value;

        if (!golfers.length) golfers.push({ name: t('player'), caddyNumber: '' });

        // Validate no double-booked caddies
        const golfersWithCaddies = golfers.filter(g => g.caddyNumber);
        const conflicts = validateNoDuplicateCaddies(golfersWithCaddies, bookingTime, el.bookingId.value);
        if (conflicts.length > 0) {
          alert(`${t('caddyAlreadyBooked')}:\n\n${conflicts.join('\n')}`);
          return;
        }

        const booking = {
          id: el.bookingId.value || genId(),
          bookingType: el.bookingType.value,
          course, tee, col: colIndex,
          time: bookingTime,
          golfers,
          notes: el.bookingNotes.value,
          name: golfers[0]?.name || '',
          caddyNumber: golfers[0]?.caddyNumber || ''
        };

        const idx = bookings.findIndex(b => b.id === booking.id);
        if (idx >= 0) bookings[idx] = booking;
        else bookings.push(booking);

        // Handle recurring bookings
        if (el.recurringToggle?.checked && !el.bookingId.value) {
          const recurringDates = getRecurringDates();
          // Skip the first date since we already created it above
          const futureDates = recurringDates.slice(1);

          if (futureDates.length > 0) {
            // Generate a recurring group ID to link all these bookings
            const recurringGroupId = 'rec_' + genId();
            booking.recurringGroupId = recurringGroupId;

            futureDates.forEach(futureDate => {
              const futureDateStr = futureDate.toISOString().split('T')[0];
              const futureDayBookings = getDay(futureDateStr);

              const recurringBooking = {
                id: genId(),
                bookingType: booking.bookingType,
                course: booking.course,
                tee: booking.tee,
                col: booking.col,
                time: booking.time,
                golfers: JSON.parse(JSON.stringify(booking.golfers)), // Deep copy
                notes: booking.notes,
                name: booking.name,
                caddyNumber: booking.caddyNumber,
                recurringGroupId: recurringGroupId
              };

              futureDayBookings.push(recurringBooking);
              setDay(futureDateStr, futureDayBookings);
            });

            console.log(`[TeeSheet] Created ${futureDates.length + 1} recurring bookings`);
          }
        }
      }

      setDay(date, bookings);

      // Sync caddy bookings to database for real-time visibility
      if (el.rangeModeToggle.checked && rangeSlots.length > 0) {
        // Range mode - sync all slots with caddies
        rangeSlots.forEach(slot => {
          (slot.golfers || []).forEach(g => {
            if (g.caddyId) {
              saveCaddyBookingToDb(null, g, date, slot.time);
            }
          });
        });
      } else {
        // Single booking mode
        const bookingTime = el.bookingTime.value;
        const golfers = getGolfersFromDialog();
        golfers.forEach(g => {
          if (g.caddyId) {
            saveCaddyBookingToDb(null, g, date, bookingTime);
          }
        });
      }

      el.dialog.close();
      render();

      // Refresh caddy bookings cache to show the new booking
      fetchCaddyBookings(date);
    });

    el.deleteBooking.addEventListener('click', async () => {
      const date = el.dateInput.value;
      let bookings = getDay(date);

      // Capture booking info for notifications before deleting
      const bookingId = el.bookingId.value;
      const deletedBooking = bookings.find(b => b.id === bookingId);

      // Check if this is a group booking
      const groupId = el.bookingGroupId.value;
      let deletedBookings = [];

      if (groupId) {
        deletedBookings = bookings.filter(b => b.groupId === groupId);
        const confirmMsg = t('confirmDeleteGroup').replace('{n}', deletedBookings.length);
        if (confirm(confirmMsg)) {
          bookings = bookings.filter(b => b.groupId !== groupId);
        } else {
          return; // User cancelled
        }
      } else {
        if (deletedBooking) deletedBookings = [deletedBooking];
        bookings = bookings.filter(b => b.id !== bookingId);
      }

      // Send cancellation notifications and check waitlists
      for (const booking of deletedBookings) {
        const golfers = booking.golfers || [];
        for (const g of golfers) {
          if (g.caddyId || g.caddyNumber) {
            // Notify caddy of cancellation
            const parent = ParentBridge.getParent();
            const supabase = parent.SupabaseDB?.client;
            if (supabase) {
              try {
                await supabase.functions.invoke('notify-caddy-booking', {
                  body: {
                    action: 'cancelled',
                    caddyId: g.caddyId,
                    caddyName: g.caddyName || g.caddyLocalName,
                    golferName: g.name,
                    date: date,
                    time: booking.time,
                    course: el.courseSelect.options[el.courseSelect.selectedIndex]?.text
                  }
                });
              } catch (e) {
                console.warn('[TeeSheet] Cancel notification failed:', e);
              }
            }

            // Check and promote from waitlist
            await ParentBridge.promoteFromWaitlist(g.caddyId || g.caddyNumber, date, booking.time);

            // Delete caddy booking from database
            if (g.caddyId) {
              await deleteCaddyBookingFromDb(g.caddyId, date, booking.time);
            }
          }
        }

        // CRITICAL: Remove booking from parent BookingManager and cloud
        await ParentBridge.removeBookingFromParent(booking.id);

        // CRITICAL FIX: If this is a society event, mark as CANCELLED instead of deleting
        // This allows golfers to see the cancellation notice and delete the card themselves
        if (booking.source === 'society-event-db' || booking.source === 'society-db' ||
            (booking.groupId && booking.groupId.startsWith('society-'))) {
          const societyEventId = booking.groupId ? booking.groupId.replace('society-', '') : null;
          if (societyEventId && supabaseClient) {
            console.log('[TeeSheet] Marking society event as CANCELLED:', societyEventId);
            try {
              const { error } = await supabaseClient
                .from('society_events')
                .update({
                  status: 'cancelled',
                  cancelled_at: new Date().toISOString(),
                  cancelled_by: 'proshop',
                  updated_at: new Date().toISOString(),
                  notes: (booking.notes || '') + `\n[${new Date().toLocaleString()}] CANCELLED by Pro Shop`
                })
                .eq('id', societyEventId);
              if (error) {
                console.error('[TeeSheet] Failed to mark society event as cancelled:', error);
              } else {
                console.log('[TeeSheet] Society event marked as cancelled in database');
              }
            } catch (e) {
              console.error('[TeeSheet] Error marking society event as cancelled:', e);
            }
          }
        }
      }

      // CRITICAL: Clear ALL caches BEFORE saving and rendering
      delete caddyBookingsCache[date];
      const courseId = el.courseSelect.value;
      delete societyEventsCache[`${date}::${courseId}`];
      delete eventRegistrationsCache[date];
      console.log('[TeeSheet] Cleared all caches for date:', date);

      setDay(date, bookings);
      el.dialog.close();
      render();

      // DON'T re-fetch immediately - let the caches stay empty so deleted items don't reappear
      // The next render() or date change will fetch fresh data
      console.log('[TeeSheet] Delete complete - caches cleared, not re-fetching');
    });

    // ==================== CONTROLS ====================
    // Async function to fetch data and render
    async function fetchAndRender() {
      const currentDate = el.dateInput.value;

      // Fetch society events first and render immediately
      await fetchSocietyEvents(currentDate);
      render();

      // Then fetch caddy bookings and re-render
      await Promise.all([
        fetchCaddyBookings(currentDate),
        fetchEventRegistrations(currentDate)
      ]);
      render();
    }

    el.prevDay.addEventListener('click', async () => {
      const d = new Date(el.dateInput.value);
      d.setDate(d.getDate() - 1);
      el.dateInput.value = d.toISOString().split('T')[0];
      await fetchAndRender();
    });

    el.nextDay.addEventListener('click', async () => {
      const d = new Date(el.dateInput.value);
      d.setDate(d.getDate() + 1);
      el.dateInput.value = d.toISOString().split('T')[0];
      await fetchAndRender();
    });

    el.todayBtn.addEventListener('click', async () => {
      el.dateInput.value = todayISO();
      updateHeaderDate();
      await fetchAndRender();
    });

    el.dateInput.addEventListener('change', fetchAndRender);

    // Settings controls - save on change
    el.courseSelect.addEventListener('change', async () => {
      saveSettings();
      await refreshCaddies(); // Reload caddies for new course
      render();
    });
    el.complexSelect.addEventListener('change', () => { saveSettings(); render(); });
    el.startTime.addEventListener('change', () => { saveSettings(); render(); });
    el.endTime.addEventListener('change', () => { saveSettings(); render(); });
    el.intervalSelect.addEventListener('change', () => { saveSettings(); render(); });
    el.teesSelect.addEventListener('change', () => { saveSettings(); render(); });

    el.clearBtn.addEventListener('click', () => {
      if (confirm(t('confirmClear'))) {
        setDay(el.dateInput.value, []);
        render();
      }
    });

    el.langSelect.addEventListener('change', () => {
      currentLang = el.langSelect.value;
      localStorage.setItem('teesheet.lang', currentLang);
      applyTranslations();
      render();
    });

    // ==================== SEARCH ====================
    let searchResults = [], searchIdx = 0;

    el.findBtn.addEventListener('click', async () => {
      const q = el.searchInput.value.toLowerCase().trim();
      if (!q) return;

      // Ensure caddy bookings are fetched before searching
      const currentDate = el.dateInput.value;
      await Promise.all([fetchCaddyBookings(currentDate), fetchSocietyEvents(currentDate)]);

      const bookings = getDay(currentDate);

      // Fuzzy match: flexible search that handles partial names and near-matches
      const fuzzyMatch = (text, query) => {
        if (!text) return false;
        const t = text.toLowerCase();
        // Direct substring match
        if (t.includes(query)) return true;
        // Split both into words
        const textWords = t.split(/\s+/);
        const queryWords = query.split(/\s+/);
        // Check for partial matches
        for (const tw of textWords) {
          for (const qw of queryWords) {
            // Either starts with the other
            if (tw.startsWith(qw) || qw.startsWith(tw)) return true;
            // Share first 3+ characters (handles pete/peter, jon/john etc)
            if (tw.length >= 3 && qw.length >= 3) {
              const minLen = Math.min(tw.length, qw.length);
              const matchLen = Math.max(3, Math.floor(minLen * 0.7));
              if (tw.substring(0, matchLen) === qw.substring(0, matchLen)) return true;
            }
          }
        }
        return false;
      };

      searchResults = bookings.filter(b => {
        // Search in ALL booking-level fields
        if (fuzzyMatch(b.name, q)) return true;
        if (fuzzyMatch(b.caddyNumber, q)) return true;
        if (fuzzyMatch(b.groupName, q)) return true;
        if (fuzzyMatch(b.societyName, q)) return true;
        if (fuzzyMatch(b.eventName, q)) return true;
        if (fuzzyMatch(b.notes, q)) return true;
        if (fuzzyMatch(b.bookingType, q)) return true;

        // Search in each golfer
        const golfers = b.golfers || [];
        return golfers.some(g => {
          if (fuzzyMatch(g.name, q)) return true;
          if (fuzzyMatch(g.caddyId, q)) return true;
          if (fuzzyMatch(String(g.caddyNumber || ''), q)) return true;
          if (fuzzyMatch(g.caddyName, q)) return true;
          if (fuzzyMatch(g.caddyLocalName, q)) return true;
          return false;
        });
      });
      searchIdx = 0;
      console.log('[TeeSheet] Search: found', searchResults.length, 'matches');
      if (searchResults.length) highlightBooking(searchResults[0]);
      else alert(t('noMatches'));
    });

    el.nextBtn.addEventListener('click', () => {
      if (!searchResults.length) { el.findBtn.click(); return; }
      searchIdx = (searchIdx + 1) % searchResults.length;
      highlightBooking(searchResults[searchIdx]);
    });

    function highlightBooking(booking) {
      // Try to find by exact ID first
      let pill = document.querySelector(`.pill[data-id="${booking.id}"]`);

      // If not found, try by event ID for society events
      if (!pill && booking.eventId) {
        pill = document.querySelector(`.pill[data-event-id="${booking.eventId}"]`);
      }

      // If not found, try by group ID
      if (!pill && booking.groupId) {
        pill = document.querySelector(`.pill[data-group-id="${booking.groupId}"]`);
      }

      // If still not found, find by time in grid row
      if (!pill && booking.time) {
        const gridRow = document.querySelector(`.grid-row[data-time="${booking.time}"]`);
        if (gridRow) {
          gridRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
          gridRow.style.outline = '3px solid #3b82f6';
          gridRow.style.background = '#fef3c7';
          setTimeout(() => { gridRow.style.outline = ''; gridRow.style.background = ''; }, 2000);
          return;
        }
      }

      if (pill) {
        pill.scrollIntoView({ behavior: 'smooth', block: 'center' });
        pill.style.outline = '3px solid #3b82f6';
        setTimeout(() => pill.style.outline = '', 1500);
      }
    }

    el.searchInput.addEventListener('keydown', e => { if (e.key === 'Enter') el.findBtn.click(); });

    // ==================== BACK TO TOP ====================
    // Back to top - listen on main-content since that's where scrolling happens
    const mainContent = document.querySelector('.main-content');
    mainContent?.addEventListener('scroll', () => {
      if (mainContent.scrollTop > 300) {
        el.backToTop.classList.add('show');
      } else {
        el.backToTop.classList.remove('show');
      }
    });

    el.backToTop.addEventListener('click', () => {
      mainContent?.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // ==================== SETTINGS MODAL ====================
    const settingsDialog = $('settings-dialog');
    const settingsBtn = $('settings-btn');
    const closeSettings = $('close-settings');
    const cancelSettings = $('cancel-settings');
    const saveSettingsBtn = $('save-settings');

    // Settings form elements
    const settingsEls = {
      course: $('settings-course'),
      layout: $('settings-layout'),
      tees: $('settings-tees'),
      start: $('settings-start'),
      end: $('settings-end'),
      interval: $('settings-interval'),
      roundDuration: $('settings-round-duration'),
      // Caddy & Cart
      caddyFee18: $('caddy-fee-18'),
      caddyFee9: $('caddy-fee-9'),
      caddyTip: $('caddy-tip'),
      cartFee18: $('cart-fee-18'),
      cartFee9: $('cart-fee-9'),
      cartSharing: $('cart-sharing'),
      clubRental: $('club-rental'),
      shoeRental: $('shoe-rental'),
      rangeBalls: $('range-balls'),
      // Society rates
      societyMinSize: $('society-min-size'),
      societyDiscount: $('society-discount'),
      societyFreeSlots: $('society-free-slots'),
      // Summary
      summaryCourse: $('summary-course'),
      summaryLayout: $('summary-layout'),
      summaryHours: $('summary-hours'),
      summaryInterval: $('summary-interval')
    };

    // Extended settings storage key
    const FULL_SETTINGS_KEY = 'teesheet.fullSettings';

    // Load full settings from localStorage
    function getFullSettings() {
      try {
        return JSON.parse(localStorage.getItem(FULL_SETTINGS_KEY)) || {};
      } catch { return {}; }
    }

    // Save full settings to localStorage
    function saveFullSettings(settings) {
      localStorage.setItem(FULL_SETTINGS_KEY, JSON.stringify(settings));
    }

    // Get pricing periods from DOM
    function getPricingPeriods(containerId) {
      const container = $(containerId);
      const periods = [];
      container.querySelectorAll('.time-period-row').forEach(row => {
        const labelEl = row.querySelector('.time-period-label');
        // Check if it's an input or a span
        const label = labelEl?.tagName === 'INPUT' ? labelEl.value : (labelEl?.textContent || 'Period');
        periods.push({
          label: label,
          start: row.querySelector('.period-start')?.value || '',
          end: row.querySelector('.period-end')?.value || '',
          price: parseInt(row.querySelector('.period-price')?.value) || 0
        });
      });
      return periods;
    }

    // Set pricing periods in DOM
    function setPricingPeriods(containerId, periods) {
      const container = $(containerId);
      // Clear existing rows
      container.innerHTML = '';
      (periods || []).forEach(period => {
        addPeriodRow(containerId, period.label, period.start, period.end, period.price);
      });
    }

    // Add a new time period row
    function addPeriodRow(containerId, label = 'Period', start = '', end = '', price = 0) {
      const container = $(containerId);
      const row = document.createElement('div');
      row.className = 'time-period-row';
      row.innerHTML = `
        <input type="text" class="time-period-label" value="${label}" style="width:80px;background:#f0f0f0;border:1px solid #ddd;padding:6px 8px;border-radius:4px;">
        <select class="period-start" data-time-picker data-default="${start || '06:00'}"></select>
        <select class="period-end" data-time-picker data-default="${end || '18:00'}"></select>
        <div class="currency-input">
          <input type="number" class="period-price" value="${price}" placeholder="Price">
        </div>
        <button class="remove-period-btn" title="Remove">&times;</button>
      `;
      row.querySelector('.remove-period-btn').addEventListener('click', () => row.remove());
      container.appendChild(row);
      // Initialize the time pickers
      TimePickerUtils.populateSelect(row.querySelector('.period-start'), { defaultValue: start || '06:00' });
      TimePickerUtils.populateSelect(row.querySelector('.period-end'), { defaultValue: end || '18:00' });
    }

    // Get packages from DOM
    function getPackages() {
      const container = $('packages-list');
      const packages = [];
      container.querySelectorAll('.package-card').forEach(card => {
        packages.push({
          name: card.querySelector('.package-name')?.value || '',
          greenFee: parseInt(card.querySelector('.pkg-green-fee')?.value) || 0,
          includesCaddy: card.querySelector('.pkg-includes-caddy')?.value || 'no',
          includesCart: card.querySelector('.pkg-includes-cart')?.value || 'no',
          validDays: card.querySelector('.pkg-valid-days')?.value || 'all',
          validFrom: card.querySelector('.pkg-valid-from')?.value || '',
          validUntil: card.querySelector('.pkg-valid-until')?.value || ''
        });
      });
      return packages;
    }

    // Set packages in DOM
    function setPackages(packages) {
      const container = $('packages-list');
      container.innerHTML = '';
      (packages || []).forEach(pkg => addPackageCard(pkg));
    }

    // Add a new package card
    function addPackageCard(pkg = {}) {
      const container = $('packages-list');
      const card = document.createElement('div');
      card.className = 'package-card';
      card.innerHTML = `
        <div class="package-header">
          <input type="text" class="package-name" value="${pkg.name || ''}" placeholder="${t('packageName')}">
          <button class="remove-period-btn remove-package">&times;</button>
        </div>
        <div class="package-fields">
          <div class="package-field">
            <label data-i18n="greenFee">Green Fee</label>
            <div class="currency-input">
              <input type="number" class="pkg-green-fee" value="${pkg.greenFee || 0}">
            </div>
          </div>
          <div class="package-field">
            <label data-i18n="includesCaddy">Includes Caddy</label>
            <select class="pkg-includes-caddy">
              <option value="yes" ${pkg.includesCaddy === 'yes' ? 'selected' : ''}>Yes</option>
              <option value="no" ${pkg.includesCaddy !== 'yes' ? 'selected' : ''}>No</option>
            </select>
          </div>
          <div class="package-field">
            <label data-i18n="includesCart">Includes Cart</label>
            <select class="pkg-includes-cart">
              <option value="yes" ${pkg.includesCart === 'yes' ? 'selected' : ''}>Yes</option>
              <option value="no" ${pkg.includesCart !== 'yes' ? 'selected' : ''}>No</option>
            </select>
          </div>
          <div class="package-field">
            <label data-i18n="validDays">Valid Days</label>
            <select class="pkg-valid-days">
              <option value="weekday" ${pkg.validDays === 'weekday' ? 'selected' : ''}>${t('monFri')}</option>
              <option value="weekend" ${pkg.validDays === 'weekend' ? 'selected' : ''}>${t('satSun')}</option>
              <option value="all" ${pkg.validDays === 'all' || !pkg.validDays ? 'selected' : ''}>${t('allDays')}</option>
            </select>
          </div>
          <div class="package-field">
            <label data-i18n="validFrom">Valid From</label>
            <select class="pkg-valid-from" data-time-picker data-default="${pkg.validFrom || '06:00'}"></select>
          </div>
          <div class="package-field">
            <label data-i18n="validUntil">Valid Until</label>
            <select class="pkg-valid-until" data-time-picker data-default="${pkg.validUntil || '18:00'}"></select>
          </div>
        </div>
      `;
      card.querySelector('.remove-package').addEventListener('click', () => card.remove());
      container.appendChild(card);
      // Initialize the time pickers
      TimePickerUtils.populateSelect(card.querySelector('.pkg-valid-from'), { defaultValue: pkg.validFrom || '06:00' });
      TimePickerUtils.populateSelect(card.querySelector('.pkg-valid-until'), { defaultValue: pkg.validUntil || '18:00' });
      applyTranslations();
    }

    // Load settings into modal
    function loadSettingsIntoModal() {
      const full = getFullSettings();
      const basic = getSettings();

      // Course config - sync from tee sheet controls
      settingsEls.course.value = basic.golfCourse || el.courseSelect.value || '';
      settingsEls.layout.value = basic.courseLayout || el.complexSelect.value || '18';
      settingsEls.tees.value = basic.teesPerCourse || el.teesSelect.value || '1';
      settingsEls.start.value = basic.startTime || el.startTime.value || '06:00';
      settingsEls.end.value = basic.endTime || el.endTime.value || '18:00';
      settingsEls.interval.value = basic.interval || el.intervalSelect.value || '7';
      settingsEls.roundDuration.value = full.roundDuration || '270';

      // Caddy & Cart fees
      settingsEls.caddyFee18.value = full.caddyFee18 || 400;
      settingsEls.caddyFee9.value = full.caddyFee9 || 250;
      settingsEls.caddyTip.value = full.caddyTip || 300;
      settingsEls.cartFee18.value = full.cartFee18 || 700;
      settingsEls.cartFee9.value = full.cartFee9 || 400;
      settingsEls.cartSharing.value = full.cartSharing || 'shared';
      settingsEls.clubRental.value = full.clubRental || 1500;
      settingsEls.shoeRental.value = full.shoeRental || 300;
      settingsEls.rangeBalls.value = full.rangeBalls || 100;

      // Society rates
      settingsEls.societyMinSize.value = full.societyMinSize || 12;
      settingsEls.societyDiscount.value = full.societyDiscount || 15;
      settingsEls.societyFreeSlots.value = full.societyFreeSlots || 1;

      // Pricing periods
      if (full.weekdayPeriods && full.weekdayPeriods.length > 0) {
        setPricingPeriods('weekday-periods', full.weekdayPeriods);
      }
      if (full.weekendPeriods && full.weekendPeriods.length > 0) {
        setPricingPeriods('weekend-periods', full.weekendPeriods);
      }

      // Packages
      if (full.packages && full.packages.length > 0) {
        setPackages(full.packages);
      }

      // Update summary
      updateSettingsSummary();
    }

    // Save settings from modal
    function saveSettingsFromModal() {
      // Basic settings (sync with tee sheet controls)
      const basicSettings = {
        golfCourse: settingsEls.course.value,
        courseLayout: settingsEls.layout.value,
        teesPerCourse: settingsEls.tees.value,
        startTime: settingsEls.start.value,
        endTime: settingsEls.end.value,
        interval: settingsEls.interval.value
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(basicSettings));

      // Full settings
      const fullSettings = {
        roundDuration: settingsEls.roundDuration.value,
        // Caddy & Cart
        caddyFee18: parseInt(settingsEls.caddyFee18.value) || 400,
        caddyFee9: parseInt(settingsEls.caddyFee9.value) || 250,
        caddyTip: parseInt(settingsEls.caddyTip.value) || 300,
        cartFee18: parseInt(settingsEls.cartFee18.value) || 700,
        cartFee9: parseInt(settingsEls.cartFee9.value) || 400,
        cartSharing: settingsEls.cartSharing.value,
        clubRental: parseInt(settingsEls.clubRental.value) || 1500,
        shoeRental: parseInt(settingsEls.shoeRental.value) || 300,
        rangeBalls: parseInt(settingsEls.rangeBalls.value) || 100,
        // Society
        societyMinSize: parseInt(settingsEls.societyMinSize.value) || 12,
        societyDiscount: parseInt(settingsEls.societyDiscount.value) || 15,
        societyFreeSlots: parseInt(settingsEls.societyFreeSlots.value) || 1,
        // Pricing
        weekdayPeriods: getPricingPeriods('weekday-periods'),
        weekendPeriods: getPricingPeriods('weekend-periods'),
        // Packages
        packages: getPackages()
      };
      saveFullSettings(fullSettings);

      // Sync with tee sheet controls
      el.courseSelect.value = basicSettings.golfCourse;
      el.complexSelect.value = basicSettings.courseLayout;
      el.teesSelect.value = basicSettings.teesPerCourse;
      el.startTime.value = basicSettings.startTime;
      el.endTime.value = basicSettings.endTime;
      el.intervalSelect.value = basicSettings.interval;

      console.log('[TeeSheet] Settings saved:', { basic: basicSettings, full: fullSettings });
    }

    // Update settings summary panel
    function updateSettingsSummary() {
      const courseOption = settingsEls.course.options[settingsEls.course.selectedIndex];
      settingsEls.summaryCourse.textContent = courseOption ? courseOption.text : '-';

      const layoutOption = settingsEls.layout.options[settingsEls.layout.selectedIndex];
      settingsEls.summaryLayout.textContent = layoutOption ? layoutOption.text : '-';

      settingsEls.summaryHours.textContent = `${settingsEls.start.value} - ${settingsEls.end.value}`;
      settingsEls.summaryInterval.textContent = `${settingsEls.interval.value} min`;
    }

    // Tab switching
    document.querySelectorAll('.settings-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active from all tabs and panels
        document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
        // Activate clicked tab and corresponding panel
        tab.classList.add('active');
        const panelId = 'panel-' + tab.dataset.tab;
        const panel = $(panelId);
        if (panel) panel.classList.add('active');
      });
    });

    // Add period buttons
    $('add-weekday-period')?.addEventListener('click', () => {
      addPeriodRow('weekday-periods', 'Custom', '12:00', '14:00', 1500);
    });

    $('add-weekend-period')?.addEventListener('click', () => {
      addPeriodRow('weekend-periods', 'Custom', '12:00', '14:00', 2500);
    });

    // Add package button
    $('add-package')?.addEventListener('click', () => {
      addPackageCard({
        name: 'New Package',
        greenFee: 2000,
        includesCaddy: 'no',
        includesCart: 'no',
        validDays: 'all',
        validFrom: '06:00',
        validUntil: '18:00'
      });
    });

    // Remove period buttons - attach to existing rows
    document.querySelectorAll('.time-period-row .remove-period-btn').forEach(btn => {
      btn.addEventListener('click', () => btn.closest('.time-period-row').remove());
    });

    // Remove package buttons - attach to existing cards
    document.querySelectorAll('.package-card .remove-package').forEach(btn => {
      btn.addEventListener('click', () => btn.closest('.package-card').remove());
    });

    // Open settings dialog (both header and controls buttons)
    settingsBtn?.addEventListener('click', () => {
      TimePickerUtils.initAll(settingsDialog); // Initialize time pickers in dialog first
      loadSettingsIntoModal();
      updateSettingsSummary(); // Update summary to match loaded settings
      settingsDialog.showModal();
    });

    // Close settings dialog
    closeSettings?.addEventListener('click', () => settingsDialog.close());
    cancelSettings?.addEventListener('click', () => settingsDialog.close());

    // Save settings
    saveSettingsBtn?.addEventListener('click', () => {
      saveSettingsFromModal();
      settingsDialog.close();
      updateHeaderCourseName(); // Update header to show new course name
      render();
    });

    // Update summary on input change in course config tab
    settingsEls.course?.addEventListener('change', updateSettingsSummary);
    settingsEls.layout?.addEventListener('change', updateSettingsSummary);
    settingsEls.start?.addEventListener('change', updateSettingsSummary);
    settingsEls.end?.addEventListener('change', updateSettingsSummary);
    settingsEls.interval?.addEventListener('change', updateSettingsSummary);

    // ==================== HEADER BAR FUNCTIONALITY ====================
    const courseNameDisplay = $('course-name-display');
    const dateDisplayLarge = $('date-display-large');
    const currentTimeDisplay = $('current-time-display');
    const headerPrevDay = $('header-prev-day');
    const headerNextDay = $('header-next-day');

    // Course name mapping for display
    const courseDisplayNames = {
      'bangpakong': 'Bangpakong Riverside CC',
      'bangpra-international': 'Bangpra International GC',
      'burapha-ac': 'Burapha Golf Club A+C',
      'burapha-cd': 'Burapha Golf Club C+D',
      'burapha-east': 'Burapha Golf Club East',
      'cheechan': 'Chee Chan Golf Resort',
      'crystal-bay': 'Crystal Bay Golf Club',
      'eastern-star': 'Eastern Star CC',
      'grand-prix': 'Grand Prix International GC',
      'greenwood': 'Greenwood Golf Club',
      'hermes': 'Hermes Golf Club',
      'khao-kheow': 'Khao Kheow Country Club',
      'laem-chabang': 'Laem Chabang International CC',
      'mountain-shadow': 'Mountain Shadow GC',
      'pattana-golf-resort': 'Pattana Golf Resort',
      'pattavia': 'Pattavia Century GC',
      'pattaya-golf': 'Pattaya Golf Club',
      'phoenix': 'Phoenix Gold Golf CC',
      'pleasant-valley': 'Pleasant Valley CC',
      'plutaluang': 'Plutaluang Navy GC',
      'royal-garden': 'Royal Garden Golf Club',
      'royal-lakeside': 'Royal Lakeside GC',
      'siam-cc-old': 'Siam CC Old Course',
      'siam-cc-plantation': 'Siam CC Plantation',
      'siam-cc-waterside': 'Siam CC Waterside',
      'siam-plantation': 'Siam Plantation GC',
      'st-andrews-2000': 'St. Andrews 2000 GC',
      'thai-country-club': 'Thai Country Club',
      'treasure-hill-golf': 'Treasure Hill Golf & Country Club'
    };

    // Update header course name when course changes
    function updateHeaderCourseName() {
      const courseId = el.courseSelect.value;
      if (courseId && courseDisplayNames[courseId]) {
        courseNameDisplay.textContent = courseDisplayNames[courseId];
      } else {
        courseNameDisplay.textContent = t('selectCourse');
      }
    }

    // Update header date display
    function updateHeaderDate() {
      const dateStr = el.dateInput.value;
      if (dateStr) {
        const d = new Date(dateStr + 'T00:00:00');
        const options = { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' };
        dateDisplayLarge.textContent = d.toLocaleDateString('en-US', options);
      }
    }

    // Real-time clock
    function updateClock() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      currentTimeDisplay.textContent = `${hours}:${minutes}:${seconds}`;
    }

    // Header date navigation
    headerPrevDay?.addEventListener('click', () => {
      const d = new Date(el.dateInput.value);
      d.setDate(d.getDate() - 1);
      el.dateInput.value = d.toISOString().split('T')[0];
      updateHeaderDate();
      render();
    });

    headerNextDay?.addEventListener('click', () => {
      const d = new Date(el.dateInput.value);
      d.setDate(d.getDate() + 1);
      el.dateInput.value = d.toISOString().split('T')[0];
      updateHeaderDate();
      render();
    });

    // Click on date display to show date picker
    dateDisplayLarge?.addEventListener('click', () => {
      el.dateInput.showPicker?.();
    });

    // Sync header when course or date changes
    el.courseSelect.addEventListener('change', updateHeaderCourseName);
    el.dateInput.addEventListener('change', updateHeaderDate);

    // URL parameter handling for course selection
    function handleUrlParams() {
      const params = new URLSearchParams(window.location.search);
      const courseParam = params.get('course');
      if (courseParam && el.courseSelect.querySelector(`option[value="${courseParam}"]`)) {
        el.courseSelect.value = courseParam;
        updateHeaderCourseName();
        saveSettings();
      }
    }

    // Start the clock
    setInterval(updateClock, 1000);
    updateClock();

    // ==================== CALENDAR NAVIGATOR ====================
    const CalendarNav = {
      currentYear: new Date().getFullYear(),
      currentMonth: new Date().getMonth(),
      selectedDate: null,
      monthCache: {},

      elements: {
        dialog: $('calendar-navigator'),
        monthTitle: $('cal-month-title'),
        grid: $('cal-grid'),
        prevMonth: $('cal-prev-month'),
        nextMonth: $('cal-next-month'),
        closeBtn: $('cal-close'),
        filterType: $('cal-filter-type'),
        detailDate: $('cal-detail-date'),
        detailContent: $('cal-detail-content'),
        detailSummary: $('cal-detail-summary'),
        goToDay: $('cal-go-to-day')
      },

      monthNames: ['January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December'],

      async open() {
        // Start with current tee sheet date
        const currentDate = new Date(el.dateInput.value);
        this.currentYear = currentDate.getFullYear();
        this.currentMonth = currentDate.getMonth();
        this.selectedDate = el.dateInput.value;
        this.elements.dialog.showModal();
        // Pre-fetch society events and caddy bookings for this month then render
        await Promise.all([
          this.fetchMonthSocietyEvents(this.currentYear, this.currentMonth),
          this.fetchMonthCaddyBookings(this.currentYear, this.currentMonth)
        ]);
        this.renderMonth();
      },

      // Fetch society events for all days in a month
      async fetchMonthSocietyEvents(year, month) {
        if (!supabaseClient) return;

        const courseId = el?.courseSelect?.value || '';
        const firstDay = `${year}-${String(month + 1).padStart(2, '0')}-01`;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const lastDay = `${year}-${String(month + 1).padStart(2, '0')}-${String(daysInMonth).padStart(2, '0')}`;

        try {
          console.log('[Calendar] Fetching society events for month:', firstDay, 'to', lastDay);

          // Fetch all society events for this month in one query
          const { data, error } = await supabaseClient
            .from('society_events')
            .select('id, title, event_date, start_time, end_time, course_name, society_id, status, organizer_name')
            .gte('event_date', firstDay)
            .lte('event_date', lastDay);

          if (error) {
            console.error('[Calendar] Error fetching society events:', error);
            return;
          }

          console.log('[Calendar] Found', data?.length || 0, 'society events for month');

          // Filter by selected course and group by date
          (data || []).forEach(evt => {
            const eventCourseId = matchCourseToId(evt.course_name);
            if (courseId && eventCourseId !== courseId) return;

            const dateStr = evt.event_date;
            const cacheKey = `${dateStr}::${courseId}`;

            // Convert to booking format for this date's cache
            if (!societyEventsCache[cacheKey]) {
              societyEventsCache[cacheKey] = [];
            }

            // Check if already cached
            if (societyEventsCache[cacheKey].find(e => e.eventId === evt.id)) return;

            const startTime = evt.start_time ? evt.start_time.substring(0, 5) : '08:00';
            const endTime = evt.end_time ? evt.end_time.substring(0, 5) : null;
            const endMins = endTime ? minutes(endTime) : minutes(startTime) + 60;

            // Create time slots for the event
            for (let m = minutes(startTime); m < endMins; m += 5) {
              societyEventsCache[cacheKey].push({
                id: `society-${evt.id}-${m}`,
                eventId: evt.id,
                groupId: `society-${evt.id}`,
                groupName: evt.title || 'Society Event',
                time: hhmm(m),
                course: 'A',
                tee: 1,
                bookingType: 'society',
                isSociety: true,
                status: evt.status,
                source: 'society-db'
              });
            }
          });
        } catch (e) {
          console.error('[Calendar] Society fetch error:', e);
        }
      },

      // Fetch caddy bookings for all days in a month
      async fetchMonthCaddyBookings(year, month) {
        if (!supabaseClient) return;

        const courseId = el?.courseSelect?.value || '';
        const courseName = courseIdToDbName[courseId] || '';
        const firstDay = `${year}-${String(month + 1).padStart(2, '0')}-01`;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const lastDay = `${year}-${String(month + 1).padStart(2, '0')}-${String(daysInMonth).padStart(2, '0')}`;

        try {
          console.log('[Calendar] Fetching caddy bookings for month:', firstDay, 'to', lastDay);

          // Fetch all caddy bookings for this month
          let query = supabaseClient
            .from('caddy_bookings')
            .select('id, user_id, caddy_id, booking_date, tee_time, status, golfer_name, caddy_profiles(name, caddy_number)')
            .gte('booking_date', firstDay)
            .lte('booking_date', lastDay)
            .neq('status', 'cancelled');

          if (courseName) {
            query = query.eq('course_name', courseName);
          }

          const { data, error } = await query;

          if (error) {
            console.error('[Calendar] Error fetching caddy bookings:', error);
            return;
          }

          console.log('[Calendar] Found', data?.length || 0, 'caddy bookings for month');

          // Get user profiles for names
          const userIds = [...new Set((data || []).map(b => b.user_id).filter(Boolean))];
          let userProfiles = {};
          if (userIds.length > 0) {
            const { data: profiles } = await supabaseClient
              .from('user_profiles')
              .select('line_user_id, name, email')
              .in('line_user_id', userIds);
            (profiles || []).forEach(p => { userProfiles[p.line_user_id] = p; });
          }

          // Group by date and add to cache
          (data || []).forEach(b => {
            const dateStr = b.booking_date;
            if (!caddyBookingsCache[dateStr]) {
              caddyBookingsCache[dateStr] = [];
            }

            // Check if already in cache
            if (caddyBookingsCache[dateStr].find(cb => cb.dbId === b.id)) return;

            const profile = userProfiles[b.user_id];
            const golferName = b.golfer_name || profile?.name || profile?.email?.split('@')[0] || 'Golfer';
            const teeTime = b.tee_time ? b.tee_time.substring(0, 5) : null;

            caddyBookingsCache[dateStr].push({
              id: `caddy-${b.id}`,
              dbId: b.id,
              time: teeTime,
              course: 'A',
              tee: 1,
              col: 0,
              bookingType: 'regular',
              source: 'caddy-booking-db',
              golfers: [{
                name: golferName,
                odoo_id: b.user_id,
                caddyId: b.caddy_id,
                caddyName: b.caddy_profiles?.name || 'Caddy',
                caddyNumber: b.caddy_profiles?.caddy_number || null
              }],
              golferName: golferName,
              status: b.status
            });
          });
        } catch (e) {
          console.error('[Calendar] Caddy bookings fetch error:', e);
        }
      },

      close() {
        this.elements.dialog.close();
      },

      renderMonth() {
        const year = this.currentYear;
        const month = this.currentMonth;

        // Update title
        this.elements.monthTitle.textContent = `${this.monthNames[month]} ${year}`;

        // Get first day of month and total days
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();

        // Get booking data for this month
        const bookingSummary = this.getMonthSummary(year, month);

        // Today's date for comparison
        const today = new Date().toISOString().split('T')[0];

        // Build grid HTML
        let html = '';

        // Previous month days
        for (let i = firstDay - 1; i >= 0; i--) {
          const day = daysInPrevMonth - i;
          const prevMonth = month === 0 ? 11 : month - 1;
          const prevYear = month === 0 ? year - 1 : year;
          const dateStr = `${prevYear}-${String(prevMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          html += this.renderDayCell(dateStr, day, bookingSummary[dateStr], true, today);
        }

        // Current month days
        for (let day = 1; day <= daysInMonth; day++) {
          const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          html += this.renderDayCell(dateStr, day, bookingSummary[dateStr], false, today);
        }

        // Next month days to fill grid
        const totalCells = Math.ceil((firstDay + daysInMonth) / 7) * 7;
        const nextMonthDays = totalCells - (firstDay + daysInMonth);
        for (let day = 1; day <= nextMonthDays; day++) {
          const nextMonth = month === 11 ? 0 : month + 1;
          const nextYear = month === 11 ? year + 1 : year;
          const dateStr = `${nextYear}-${String(nextMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          html += this.renderDayCell(dateStr, day, bookingSummary[dateStr], true, today);
        }

        this.elements.grid.innerHTML = html;

        // Add event listeners to day cells
        this.elements.grid.querySelectorAll('.cal-day').forEach(cell => {
          cell.addEventListener('click', () => this.selectDay(cell.dataset.date));
          cell.addEventListener('mouseenter', () => {
            // Show hover preview (temporary)
            this.hoverDay(cell.dataset.date, bookingSummary[cell.dataset.date]);
          });
          cell.addEventListener('mouseleave', () => {
            // Revert to selected date when mouse leaves
            this.revertToSelected();
          });
        });

        // Update selected day detail if one is selected
        if (this.selectedDate) {
          const selectedData = bookingSummary[this.selectedDate] || { total: 0, items: [] };
          this.showDayDetail(this.selectedDate, selectedData, true);
        }
      },

      renderDayCell(dateStr, dayNum, dayData, isOtherMonth, today) {
        const isToday = dateStr === today;
        const isSelected = dateStr === this.selectedDate;
        const hasBookings = dayData && dayData.total > 0;
        const filter = this.elements.filterType.value;

        let classes = 'cal-day';
        if (isOtherMonth) classes += ' other-month';
        if (isToday) classes += ' today';
        if (isSelected) classes += ' selected';
        if (hasBookings) classes += ' has-bookings';

        let preview = '';
        if (hasBookings) {
          // Get unique group/society names
          let items = dayData.items || [];
          if (filter) {
            items = items.filter(b => b.bookingType === filter);
          }
          const names = [...new Set(items.map(b => b.groupName || b.eventName || b.golferName || 'Booking').filter(Boolean))];
          const displayNames = names.slice(0, 2);
          preview = displayNames.map(name => {
            const item = items.find(b => (b.groupName || b.eventName || b.golferName) === name);
            const type = item?.bookingType || 'regular';
            return `<span class="preview-item ${type}">${name.substring(0, 12)}${name.length > 12 ? '...' : ''}</span>`;
          }).join('');
          if (names.length > 2) {
            preview += `<span class="more">+${names.length - 2} more</span>`;
          }
        }

        return `
          <div class="${classes}" data-date="${dateStr}">
            <div class="cal-day-num">${dayNum}</div>
            <div class="cal-day-preview">${preview}</div>
          </div>
        `;
      },

      getMonthSummary(year, month) {
        const cacheKey = `${year}-${month}`;
        if (this.monthCache[cacheKey]) {
          return this.monthCache[cacheKey];
        }

        const summary = {};
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        for (let day = 1; day <= daysInMonth; day++) {
          const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
          const bookings = this.getBookingsForDate(dateStr);

          if (bookings.length > 0) {
            summary[dateStr] = {
              total: bookings.length,
              byType: {
                regular: bookings.filter(b => b.bookingType === 'regular').length,
                vip: bookings.filter(b => b.bookingType === 'vip').length,
                society: bookings.filter(b => b.bookingType === 'society').length,
                tournament: bookings.filter(b => b.bookingType === 'tournament').length
              },
              items: bookings
            };
          }
        }

        this.monthCache[cacheKey] = summary;
        return summary;
      },

      getBookingsForDate(dateStr) {
        // Get from tee sheet localStorage
        const key = `teesheet.bookings.v2::${dateStr}`;
        const localBookings = JSON.parse(localStorage.getItem(key) || '[]');

        // Get from parent BookingManager
        let parentBookings = [];
        if (window.parent && window.parent.BookingManager) {
          parentBookings = (window.parent.BookingManager.bookings || []).filter(b => b.date === dateStr);
        }

        // Get society events from cache (fetched from Supabase)
        const courseId = el?.courseSelect?.value || '';
        const societyCacheKey = `${dateStr}::${courseId}`;
        const societyBookings = societyEventsCache[societyCacheKey] || [];

        // Merge and dedupe by id
        const allBookings = [...localBookings];
        parentBookings.forEach(pb => {
          if (!allBookings.find(b => b.id === pb.id)) {
            allBookings.push(pb);
          }
        });

        // Add society events (dedupe by groupId to avoid counting each slot separately)
        const seenGroups = new Set();
        societyBookings.forEach(sb => {
          const groupKey = sb.groupId || sb.id;
          if (!seenGroups.has(groupKey) && !allBookings.find(b => b.id === sb.id)) {
            seenGroups.add(groupKey);
            allBookings.push({
              id: sb.id,
              groupId: sb.groupId,
              groupName: sb.groupName,
              time: sb.time,
              bookingType: 'society',
              isSociety: true,
              title: sb.groupName
            });
          }
        });

        // Add caddy bookings from database cache
        const caddyBookings = caddyBookingsCache[dateStr] || [];
        caddyBookings.forEach(cb => {
          // Skip if already in allBookings (by id or by matching caddy+time)
          if (allBookings.find(b => b.id === cb.id || b.dbId === cb.dbId)) return;

          // Check for matching local booking by caddy+time
          const hasCaddyTimeMatch = allBookings.some(b => {
            if (!b.golfers || !b.time || b.time !== cb.time) return false;
            return b.golfers.some(g => g.caddyId && cb.golfers?.some(cg => cg.caddyId === g.caddyId));
          });
          if (hasCaddyTimeMatch) return;

          allBookings.push({
            id: cb.id,
            dbId: cb.dbId,
            time: cb.time,
            bookingType: cb.bookingType || 'regular',
            golferName: cb.golferName,
            golfers: cb.golfers
          });
        });

        return allBookings;
      },

      // Hover preview - temporary, doesn't change selection
      hoverDay(dateStr, dayData) {
        // Don't update if this is the selected date (no need to re-render)
        if (dateStr === this.selectedDate) return;

        // Show hover preview without changing selectedDate
        const bookings = dayData?.items || this.getBookingsForDate(dateStr);
        this.showDayDetail(dateStr, { total: bookings.length, items: bookings }, false);
      },

      // Revert to showing selected date's details
      revertToSelected() {
        if (!this.selectedDate) {
          // No date selected, show placeholder
          this.elements.detailDate.textContent = 'Select a day';
          this.elements.detailContent.innerHTML = '<p class="cal-detail-empty">Click a day to see bookings</p>';
          this.elements.detailSummary.textContent = '';
          this.elements.goToDay.disabled = true;
          this.elements.goToDay.textContent = 'Go to this day ‚Üí';
          return;
        }

        // Restore selected date's details
        const bookings = this.getBookingsForDate(this.selectedDate);
        this.showDayDetail(this.selectedDate, { total: bookings.length, items: bookings }, true);
      },

      selectDay(dateStr) {
        this.selectedDate = dateStr;
        // Update visual selection
        this.elements.grid.querySelectorAll('.cal-day').forEach(cell => {
          cell.classList.toggle('selected', cell.dataset.date === dateStr);
        });
        // Show detail (isSelected = true)
        const bookings = this.getBookingsForDate(dateStr);
        this.showDayDetail(dateStr, { total: bookings.length, items: bookings }, true);
      },

      showDayDetail(dateStr, dayData, isSelected = false) {
        // Format date for display
        const d = new Date(dateStr + 'T00:00:00');
        const options = { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' };
        this.elements.detailDate.textContent = d.toLocaleDateString('en-US', options);

        // Only update Go button for selected date (not hover)
        if (isSelected) {
          this.elements.goToDay.disabled = false;
          this.elements.goToDay.textContent = `Go to ${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} ‚Üí`;
        }

        if (!dayData || dayData.total === 0) {
          this.elements.detailContent.innerHTML = '<p class="cal-detail-empty">No bookings on this day</p>';
          this.elements.detailSummary.textContent = '';
          return;
        }

        const filter = this.elements.filterType.value;
        let items = dayData.items || [];
        if (filter) {
          items = items.filter(b => b.bookingType === filter);
        }

        // Group by groupName or eventName
        const groups = {};
        items.forEach(b => {
          const key = b.groupName || b.eventName || b.time || 'Other';
          if (!groups[key]) {
            groups[key] = { name: key, type: b.bookingType, times: [] };
          }
          groups[key].times.push(b);
        });

        let html = '';
        Object.values(groups).forEach(group => {
          const typeClass = group.type || 'regular';
          const times = group.times.map(t => {
            const players = t.golfers?.length || t.players || 1;
            return `<div class="cal-detail-time">${t.time} - ${players} player${players > 1 ? 's' : ''}</div>`;
          }).join('');
          html += `
            <div class="cal-detail-group ${typeClass}">
              <div class="cal-detail-group-name">${group.name}</div>
              ${times}
            </div>
          `;
        });

        this.elements.detailContent.innerHTML = html || '<p class="cal-detail-empty">No bookings match filter</p>';

        // Summary
        const total = items.length;
        const byType = {
          society: items.filter(b => b.bookingType === 'society').length,
          vip: items.filter(b => b.bookingType === 'vip').length,
          tournament: items.filter(b => b.bookingType === 'tournament').length,
          regular: items.filter(b => b.bookingType === 'regular' || !b.bookingType).length
        };
        const parts = [];
        if (byType.society) parts.push(`${byType.society} Society`);
        if (byType.vip) parts.push(`${byType.vip} VIP`);
        if (byType.tournament) parts.push(`${byType.tournament} Tournament`);
        if (byType.regular) parts.push(`${byType.regular} Regular`);
        this.elements.detailSummary.innerHTML = `<strong>${total} tee times</strong> ‚Ä¢ ${parts.join(' ‚Ä¢ ')}`;
      },

      navigateToDate() {
        if (!this.selectedDate) return;
        el.dateInput.value = this.selectedDate;
        updateHeaderDate();
        render();
        this.close();
      },

      async prevMonth() {
        this.currentMonth--;
        if (this.currentMonth < 0) {
          this.currentMonth = 11;
          this.currentYear--;
        }
        this.monthCache = {}; // Clear cache when changing month
        await Promise.all([
          this.fetchMonthSocietyEvents(this.currentYear, this.currentMonth),
          this.fetchMonthCaddyBookings(this.currentYear, this.currentMonth)
        ]);
        this.renderMonth();
      },

      async nextMonth() {
        this.currentMonth++;
        if (this.currentMonth > 11) {
          this.currentMonth = 0;
          this.currentYear++;
        }
        this.monthCache = {}; // Clear cache when changing month
        await Promise.all([
          this.fetchMonthSocietyEvents(this.currentYear, this.currentMonth),
          this.fetchMonthCaddyBookings(this.currentYear, this.currentMonth)
        ]);
        this.renderMonth();
      },

      init() {
        // Event listeners
        $('calendar-nav-btn')?.addEventListener('click', () => this.open());
        this.elements.closeBtn?.addEventListener('click', () => this.close());
        this.elements.prevMonth?.addEventListener('click', () => this.prevMonth());
        this.elements.nextMonth?.addEventListener('click', () => this.nextMonth());
        this.elements.goToDay?.addEventListener('click', () => this.navigateToDate());
        this.elements.filterType?.addEventListener('change', () => {
          this.monthCache = {};
          this.renderMonth();
        });

        // Close on backdrop click
        this.elements.dialog?.addEventListener('click', (e) => {
          if (e.target === this.elements.dialog) this.close();
        });

        console.log('[TeeSheet] Calendar Navigator initialized');
      }
    };

    // Initialize Calendar Navigator
    CalendarNav.init();

    // Initialize Caddy Picker
    CaddyPicker.init();

    // Listen for refresh messages from parent (caddy bookings, etc.)
    window.addEventListener('message', (event) => {
      if (event.data?.type === 'REFRESH_TEESHEET') {
        console.log('[TeeSheet] Received refresh message for date:', event.data.date);
        if (event.data.date && el.dateInput) {
          el.dateInput.value = event.data.date;
          updateHeaderDate();
        }
        // Clear cache to force re-fetch
        const date = event.data.date || el.dateInput.value;
        const courseId = el?.courseSelect?.value || '';
        const societyCacheKey = `${date}::${courseId}`;
        delete caddyBookingsCache[date];
        delete lastFetchTime[date];
        delete societyEventsCache[societyCacheKey];
        delete societyEventsLastFetchTime[societyCacheKey];
        delete eventRegistrationsCache[date];
        delete eventRegLastFetchTime[date];
        render();
      }
    });

    // Gentle auto-refresh every 60 seconds for society events, caddy bookings and event registrations
    setInterval(() => {
      const currentDate = el.dateInput.value;
      const courseId = el?.courseSelect?.value || '';
      const societyCacheKey = `${currentDate}::${courseId}`;
      // Clear cache to force re-fetch
      delete caddyBookingsCache[currentDate];
      delete lastFetchTime[currentDate];
      delete societyEventsCache[societyCacheKey];
      delete societyEventsLastFetchTime[societyCacheKey];
      delete eventRegistrationsCache[currentDate];
      delete eventRegLastFetchTime[currentDate];
      // Fetch new data in background
      Promise.all([
        fetchCaddyBookings(currentDate),
        fetchSocietyEvents(currentDate),
        fetchEventRegistrations(currentDate)
      ]).then(([caddyBookings, societyEvts, eventRegs]) => {
        const hasData = (caddyBookings && caddyBookings.length > 0) ||
                        (societyEvts && societyEvts.length > 0) ||
                        (eventRegs && eventRegs.length > 0);
        if (hasData) {
          console.log('[TeeSheet] Auto-refresh: found', caddyBookings?.length || 0, 'caddy bookings,',
                      societyEvts?.length || 0, 'society slots,', eventRegs?.length || 0, 'event regs');
          render();
        }
      }).catch(e => console.warn('[TeeSheet] Auto-refresh failed:', e));
    }, 30000); // 30 seconds

    // ==================== INIT ====================
    handleUrlParams();
    updateHeaderCourseName();
    updateHeaderDate();
    applyTranslations();
    // Helper to clear all caches for a date
    function clearAllCaches(date, courseId) {
      const cacheKey = `${date}::${courseId}`;
      delete caddyBookingsCache[date];
      delete lastFetchTime[date];
      delete societyEventsCache[cacheKey];
      delete societyEventsLastFetchTime[cacheKey];
      delete eventRegistrationsCache[date];
      delete eventRegLastFetchTime[date];
    }

    // Fetch data then render on initial load with retry
    (async function initialLoad() {
      await fetchAndRender();
      const currentDate = el.dateInput.value;
      const courseId = el?.courseSelect?.value || '';
      const cacheKey = `${currentDate}::${courseId}`;

      // Check if we got data
      const societyData = societyEventsCache[cacheKey] || [];
      const caddyData = caddyBookingsCache[currentDate] || [];

      // Retry if either is empty (could be slow connection)
      if (societyData.length === 0 || caddyData.length === 0) {
        setTimeout(async () => {
          clearAllCaches(currentDate, courseId);
          await fetchAndRender();

          // Final retry after 2 more seconds
          setTimeout(async () => {
            clearAllCaches(currentDate, courseId);
            await fetchAndRender();
          }, 2000);
        }, 1500);
      }
    })();
  })();
  </script>
</body>
</html>
