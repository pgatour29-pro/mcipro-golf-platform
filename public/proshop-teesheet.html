<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MciPro Tee Sheet</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<style id="timeslot-rowlines">
/* Draw a crisp line at the top of every slot cell */
[data-slot-id] { border-top: 2px solid rgba(71,85,105,.95); /* slate-600 */ }
/* Remove column gaps so borders connect without breaks */
[data-tee-grid-row] { column-gap: 0 !important; }
/* Make sure slot cells butt up with no inner padding that would break the line */
[data-slot-id] > div { margin-top: -1px; } /* pull content down so double lines don't appear */
</style>


<style id="modal-polish">
/* Modal polish: slightly larger headings, consistent padding, better contrast */
.modal-forced .modal-card,
.modal-card {
  border-radius: 12px !important;
  box-shadow: 0 10px 30px rgba(0,0,0,.25) !important;
  background: #ffffff !important;
}
.modal-forced h3, .modal-card h3 {
  font-size: 1.15rem !important;
  line-height: 1.3 !important;
  font-weight: 700 !important;
  color: #0f172a !important; /* slate-900 */
  margin: 0 0 10px 0 !important;
}
/* Inputs */
.modal-forced input[type="text"], .modal-forced textarea,
.modal-card input[type="text"], .modal-card textarea {
  border: 2px solid #cbd5e1 !important; /* slate-300 */
  border-radius: 8px !important;
  padding: 8px 10px !important;
}
/* Buttons */
.modal-forced .btn, .modal-card .btn,
.modal-forced button, .modal-card button {
  border-radius: 8px !important;
}
/* Backdrop */
.modal-backdrop, .backdrop-blur {
  backdrop-filter: blur(2px) saturate(120%) !important;
  background-color: rgba(2,6,23,.35) !important; /* slate-950 with alpha */
}
/* Caddy panel cap to keep it visible */
.modal-forced .caddy-panel {
  max-height: 280px !important;
  overflow-y: auto !important;
}
/* Golfer grid spacing */
.modal-forced .golfers-wrap { gap: 14px !important; }
.modal-forced .golfer-row { width: calc(50% - 14px) !important; }
</style>

</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo, useCallback, useRef, useEffect } = React;

        // ============= MCIPRO BRIDGE =============
        // Bridge to connect tee sheet with MciPro's data systems when running in iframe

        const MciProBridge = {
            isInMciPro: false,
            parent: null,

            init() {
                try {
                    // Check if we're in an iframe inside MciPro
                    if (window.parent && window.parent !== window && window.parent.CaddySystem) {
                        this.isInMciPro = true;
                        this.parent = window.parent;
                        console.log('[TeeSheet] Connected to MciPro - using live data');
                        return true;
                    }
                } catch (e) {
                    console.log('[TeeSheet] Not in MciPro iframe - using demo data');
                }
                return false;
            },

            // Get all courses with their lane configuration
            getCourses() {
                if (!this.isInMciPro) return null;

                // MciPro's 8 courses with lane configuration
                return [
                    { courseId: 'pattana-golf-resort', label: 'Pattana Resort', labelEn: 'Pattana Resort', labelTh: 'à¸žà¸±à¸—à¸™à¸² à¸£à¸µà¸ªà¸­à¸£à¹Œà¸—', labelKo: 'íŒŒíƒ€ë‚˜ ë¦¬ì¡°íŠ¸', color: '#86efac', lanes: ['A', 'B', 'C'] }, // 27 holes
                    { courseId: 'pattaya-golf', label: 'Pattaya Golf', labelEn: 'Pattaya Golf', labelTh: 'à¸žà¸±à¸—à¸¢à¸² à¸à¸­à¸¥à¹Œà¸Ÿ', labelKo: 'íŒŒíƒ€ì•¼ ê³¨í”„', color: '#7dd3fc', lanes: null },
                    { courseId: 'thai-country-club', label: 'Thai Country', labelEn: 'Thai Country Club', labelTh: 'à¹„à¸—à¸¢ à¸„à¸±à¸™à¸—à¸£à¸µ à¸„à¸¥à¸±à¸š', labelKo: 'íƒ€ì´ ì»¨íŠ¸ë¦¬ í´ëŸ½', color: '#fde047', lanes: null },
                    { courseId: 'siam-plantation', label: 'Siam Plantation', labelEn: 'Siam Plantation', labelTh: 'à¸ªà¸¢à¸²à¸¡ à¹à¸žà¸¥à¸™à¹€à¸—à¸Šà¸±à¹ˆà¸™', labelKo: 'ì‹œì•” í”Œëžœí…Œì´ì…˜', color: '#c4b5fd', lanes: null },
                    { courseId: 'royal-garden', label: 'Royal Garden', labelEn: 'Royal Garden', labelTh: 'à¸£à¸­à¸¢à¸±à¸¥ à¸à¸²à¸£à¹Œà¹€à¸”à¹‰à¸™', labelKo: 'ë¡œì—´ ê°€ë“ ', color: '#fca5a5', lanes: null },
                    { courseId: 'bangpra-international', label: 'Bangpra Intl', labelEn: 'Bangpra International', labelTh: 'à¸šà¸²à¸‡à¸žà¸£à¸° à¸­à¸´à¸™à¹€à¸•à¸­à¸£à¹Œ', labelKo: 'ë°©í”„ë¼ ì¸í„°ë‚´ì…”ë„', color: '#a5b4fc', lanes: null },
                    { courseId: 'crystal-bay', label: 'Crystal Bay', labelEn: 'Crystal Bay', labelTh: 'à¸„à¸£à¸´à¸ªà¸•à¸±à¸¥ à¹€à¸šà¸¢à¹Œ', labelKo: 'í¬ë¦¬ìŠ¤íƒˆ ë² ì´', color: '#99f6e4', lanes: null },
                    { courseId: 'cheechan', label: 'Chee Chan', labelEn: 'Chee Chan', labelTh: 'à¸Šà¸µà¸ˆà¸±à¸™', labelKo: 'ì¹˜ì°¬', color: '#fcd34d', lanes: null }
                ];
            },

            // Get caddies from MciPro's CaddySystem, mapped to tee sheet format
            getCaddies(courseId = null) {
                if (!this.isInMciPro || !this.parent.CaddySystem) return null;

                try {
                    let caddies = this.parent.CaddySystem.allCaddys || [];

                    // Filter by course if specified
                    if (courseId) {
                        caddies = caddies.filter(c => c.homeClub === courseId);
                    }

                    // Map to tee sheet format
                    return caddies.map(c => ({
                        id: c.id,
                        number: c.number || c.id.replace(/[^0-9]/g, '').padStart(3, '0'),
                        name: c.name,
                        nameEn: c.name,
                        nameTh: c.name, // MciPro doesn't have Thai names yet
                        nameKo: c.name, // MciPro doesn't have Korean names yet
                        rating: c.rating || 4.5,
                        languages: c.languages || ['Thai', 'English'],
                        status: c.availability || 'available',
                        photo: c.photo,
                        specialty: c.specialty,
                        homeClub: c.homeClub
                    }));
                } catch (e) {
                    console.error('[TeeSheet] Error getting caddies:', e);
                    return null;
                }
            },

            // Get bookings from MciPro's BookingManager for a specific date and course
            getBookings(date, courseId = null) {
                if (!this.isInMciPro || !this.parent.BookingManager) return null;

                try {
                    let bookings = this.parent.BookingManager.bookings || [];

                    // Filter by date
                    if (date) {
                        bookings = bookings.filter(b => b.date === date);
                    }

                    // Filter by course if specified
                    if (courseId) {
                        bookings = bookings.filter(b => b.course === courseId || b.courseId === courseId);
                    }

                    // Map to tee sheet format
                    return bookings.map(b => ({
                        id: b.id,
                        golfers: b.players ? [{ id: 'g1', name: b.golferName, handicap: 0 }] :
                                 (b.golfers || [{ id: 'g1', name: b.golferName || 'Guest', handicap: 0 }]),
                        notes: b.notes || '',
                        bookingType: b.type || b.bookingType || 'regular',
                        status: b.status || 'confirmed',
                        caddyBookings: b.caddyBookings || [],
                        time: b.time,
                        courseId: b.courseId || b.course
                    }));
                } catch (e) {
                    console.error('[TeeSheet] Error getting bookings:', e);
                    return null;
                }
            },

            // Save a booking to MciPro's BookingManager
            async saveBooking(booking, slot) {
                if (!this.isInMciPro || !this.parent.BookingManager) {
                    console.log('[TeeSheet] Demo mode - booking not saved to MciPro');
                    return { success: true, demoMode: true };
                }

                try {
                    // Convert to MciPro booking format
                    const mciProBooking = {
                        id: booking.id || `tee-${Date.now()}`,
                        type: 'tee_time',
                        golferName: booking.golfers?.[0]?.name || 'Guest',
                        course: slot.courseId,
                        courseId: slot.courseId,
                        date: slot.time.split('T')[0] || new Date().toISOString().split('T')[0],
                        time: slot.time,
                        players: booking.golfers?.length || 1,
                        status: booking.status || 'confirmed',
                        notes: booking.notes,
                        bookingType: booking.bookingType || 'regular',
                        caddyBookings: booking.caddyBookings || [],
                        golfers: booking.golfers,
                        createdAt: new Date(),
                        source: 'proshop-teesheet'
                    };

                    // Add to BookingManager
                    if (this.parent.BookingManager.addBooking) {
                        this.parent.BookingManager.addBooking(mciProBooking);
                    } else {
                        this.parent.BookingManager.bookings.push(mciProBooking);
                        this.parent.BookingManager.saveToLocalStorage?.();
                    }

                    // Sync to cloud if SimpleCloudSync is available
                    if (this.parent.SimpleCloudSync?.saveToCloud) {
                        await this.parent.SimpleCloudSync.saveToCloud();
                    }

                    console.log('[TeeSheet] Booking saved to MciPro:', mciProBooking.id);
                    return { success: true, bookingId: mciProBooking.id };
                } catch (e) {
                    console.error('[TeeSheet] Error saving booking:', e);
                    return { success: false, error: e.message };
                }
            },

            // Update caddy status in MciPro
            updateCaddyStatus(caddyId, status) {
                if (!this.isInMciPro || !this.parent.CaddySystem) return false;

                try {
                    const caddy = this.parent.CaddySystem.allCaddys.find(c => c.id === caddyId);
                    if (caddy) {
                        caddy.availability = status;
                        return true;
                    }
                } catch (e) {
                    console.error('[TeeSheet] Error updating caddy status:', e);
                }
                return false;
            }
        };

        // Initialize bridge
        MciProBridge.init();

        // ============= ENHANCED SCHEDULE SYNC INTERFACES =============

        class ScheduleSyncManager {
          static instance = null;
          
          constructor() {
            this.golferProfiles = new Map();
            this.caddySchedules = new Map();
            this.activeBookings = new Map();
          }

          static getInstance() {
            if (!ScheduleSyncManager.instance) {
              ScheduleSyncManager.instance = new ScheduleSyncManager();
            }
            return ScheduleSyncManager.instance;
          }

          // Validate booking against existing schedules
          validateBooking(booking, slot) {
            const conflicts = [];
            const date = slot.time.split('T')[0] || new Date().toISOString().split('T')[0];
            const startTime = slot.time;
            
            // Check caddy availability conflicts
            booking.caddyBookings?.forEach(caddyBooking => {
              const caddySchedule = this.caddySchedules.get(caddyBooking.caddyId);
              if (caddySchedule) {
                const conflictingShift = caddySchedule.shifts.find(shift => 
                  shift.status === 'booked' && 
                  this.timeOverlaps(startTime, shift.startTime, shift.endTime)
                );
                
                if (conflictingShift) {
                  conflicts.push({
                    type: 'caddy_unavailable',
                    message: `Caddy ${caddyBooking.caddyName} is already booked from ${conflictingShift.startTime} to ${conflictingShift.endTime}`,
                    conflictingBookingId: conflictingShift.bookingId,
                    suggestedAlternatives: this.findAlternativeCaddies(caddyBooking.caddyId, startTime, slot.availableCaddies || [])
                  });
                }
              }
            });

            // Check golfer double booking conflicts
            booking.golfers.forEach(golfer => {
              const existingBookings = Array.from(this.activeBookings.values()).filter(
                b => b.golfers.some(g => g.id === golfer.id) && 
                b.id !== booking.id &&
                this.isSameDay(b, date)
              );
              
              existingBookings.forEach(existingBooking => {
                if (this.timeOverlaps(startTime, existingBooking.actualStartTime || '', existingBooking.actualEndTime || '')) {
                  conflicts.push({
                    type: 'golfer_double_booking',
                    message: `Golfer ${golfer.name} already has a booking at this time`,
                    conflictingBookingId: existingBooking.id
                  });
                }
              });
            });

            return conflicts;
          }

          // Sync booking to schedules
          async syncBookingToSchedules(booking, slot) {
            const conflicts = this.validateBooking(booking, slot);
            
            if (conflicts.length > 0) {
              return {
                success: false,
                conflicts,
                updatedSchedules: { caddies: [], golfers: [] }
              };
            }

            const updatedCaddies = [];
            const updatedGolfers = [];
            const warnings = [];

            try {
              // Update caddy schedules
              booking.caddyBookings?.forEach(caddyBooking => {
                const updated = this.updateCaddySchedule(
                  caddyBooking.caddyId, 
                  slot.time, 
                  booking.id,
                  120 // default 2 hour booking
                );
                if (updated) {
                  updatedCaddies.push(caddyBooking.caddyId);
                } else {
                  warnings.push(`Failed to update schedule for caddy ${caddyBooking.caddyName}`);
                }
              });

              // Update golfer profiles
              booking.golfers.forEach(golfer => {
                const updated = this.updateGolferProfile(golfer.id, booking.id);
                if (updated) {
                  updatedGolfers.push(golfer.id);
                } else {
                  warnings.push(`Failed to update profile for golfer ${golfer.name}`);
                }
              });

              // Store enhanced booking
              const enhancedBooking = {
                ...booking,
                syncStatus: 'synced',
                lastSyncAttempt: new Date(),
                estimatedDuration: 120
              };
              this.activeBookings.set(booking.id, enhancedBooking);

              return {
                success: true,
                updatedSchedules: { caddies: updatedCaddies, golfers: updatedGolfers },
                warnings: warnings.length > 0 ? warnings : undefined
              };

            } catch (error) {
              return {
                success: false,
                conflicts: [{
                  type: 'time_overlap',
                  message: `Sync failed: ${error instanceof Error ? error.message : 'Unknown error'}`
                }],
                updatedSchedules: { caddies: [], golfers: [] }
              };
            }
          }

          // Helper functions
          timeOverlaps(time1, startTime2, endTime2) {
            const t1 = new Date(`2000-01-01 ${time1}`);
            const start2 = new Date(`2000-01-01 ${startTime2}`);
            const end2 = new Date(`2000-01-01 ${endTime2}`);
            return t1 >= start2 && t1 < end2;
          }

          isSameDay(booking, date) {
            return true; // Simplified for demo
          }

          findAlternativeCaddies(excludeCaddyId, time, availableCaddies) {
            return availableCaddies
              .filter(caddy => caddy.id !== excludeCaddyId && caddy.status === 'available')
              .slice(0, 3)
              .map(caddy => ({
                caddyId: caddy.id,
                reason: `Alternative: ${caddy.name} (Rating: ${caddy.rating})`
              }));
          }

          updateCaddySchedule(caddyId, time, bookingId, duration) {
            let schedule = this.caddySchedules.get(caddyId);
            if (!schedule) {
              schedule = {
                id: caddyId,
                date: new Date().toISOString().split('T')[0],
                shifts: []
              };
              this.caddySchedules.set(caddyId, schedule);
            }

            const startTime = time;
            const endTime = this.addMinutes(time, duration);
            
            schedule.shifts.push({
              startTime,
              endTime,
              status: 'booked',
              bookingId,
              notes: 'Tee time booking'
            });

            return true;
          }

          updateGolferProfile(golferId, bookingId) {
            let profile = this.golferProfiles.get(golferId);
            if (!profile) {
              profile = {
                id: golferId,
                name: `Golfer ${golferId}`,
                membershipType: 'regular',
                preferredLanguage: 'en',
                bookingHistory: [],
                createdAt: new Date(),
                totalRounds: 0
              };
              this.golferProfiles.set(golferId, profile);
            }

            profile.bookingHistory.push(bookingId);
            profile.totalRounds += 1;
            profile.lastPlayed = new Date();

            return true;
          }

          addMinutes(time, minutes) {
            const date = new Date(`2000-01-01 ${time}`);
            date.setMinutes(date.getMinutes() + minutes);
            return date.toTimeString().slice(0, 5);
          }

          getCaddySchedule(caddyId, date) {
            return this.caddySchedules.get(caddyId);
          }

          getGolferProfile(golferId) {
            return this.golferProfiles.get(golferId);
          }

          async cancelBooking(bookingId) {
            const booking = this.activeBookings.get(bookingId);
            if (!booking) {
              return {
                success: false,
                conflicts: [{ type: 'time_overlap', message: 'Booking not found' }],
                updatedSchedules: { caddies: [], golfers: [] }
              };
            }

            const updatedCaddies = [];
            
            booking.caddyBookings?.forEach(caddyBooking => {
              const schedule = this.caddySchedules.get(caddyBooking.caddyId);
              if (schedule) {
                schedule.shifts = schedule.shifts.filter(shift => shift.bookingId !== bookingId);
                updatedCaddies.push(caddyBooking.caddyId);
              }
            });

            this.activeBookings.delete(bookingId);

            return {
              success: true,
              updatedSchedules: { caddies: updatedCaddies, golfers: [] }
            };
          }
        }

        const MultiLangInput = ({
          value,
          onChange,
          placeholder,
          inputLang = 'en',
          onLangChange,
          type = 'text',
          rows = 1,
          style = {},
          showLangSelector = true,
          disabled = false,
          autoComplete = 'off',
          maxLength,
          modalLanguage = 'en'
        }) => {
          const getLocalizedPlaceholder = () => {
            if (placeholder) {
              const patterns = {
                golferName: /^(Golfer Name|ê³¨í¼ ì´ë¦„|à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™)\s*(\d+)?$/i,
                searchCaddy: /^(Search caddy|à¸„à¹‰à¸™à¸«à¸²à¹à¸„à¸”à¸”à¸µà¹‰|ìºë”” ê²€ìƒ‰)/i,
                bookingNotes: /^(Booking notes|à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸à¸à¸²à¸£à¸ˆà¸­à¸‡|ì˜ˆì•½ ë©”ëª¨)/i,
                searchGolfer: /^(Search golfer|à¸„à¹‰à¸™à¸«à¸²à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™|ê³¨í¼ ì´ë¦„)/i
              };

              const golferMatch = placeholder.match(patterns.golferName);
              if (golferMatch) {
                const index = golferMatch[2] || '1';
                switch (modalLanguage) {
                  case 'ko': return `ê³¨í¼ ì´ë¦„ ${index}`;
                  case 'th': return `à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ ${index}`;
                  default: return `Golfer Name ${index}`;
                }
              }

              if (patterns.searchCaddy.test(placeholder)) {
                switch (modalLanguage) {
                  case 'ko': return 'ì´ë¦„ì´ë‚˜ ë²ˆí˜¸ë¡œ ìºë”” ê²€ìƒ‰';
                  case 'th': return 'à¸„à¹‰à¸™à¸«à¸²à¹à¸„à¸”à¸”à¸µà¹‰à¸”à¹‰à¸§à¸¢à¸Šà¸·à¹ˆà¸­à¸«à¸£à¸·à¸­à¹€à¸¥à¸‚à¸—à¸µà¹ˆ';
                  case 'ja': return 'åå‰ã¾ãŸã¯ç•ªå·ã§ã‚­ãƒ£ãƒ‡ã‚£æ¤œç´¢';
                  default: return 'Search caddy by name or number';
                }
              }

              if (patterns.bookingNotes.test(placeholder)) {
                switch (modalLanguage) {
                  case 'ko': return 'ì˜ˆì•½ ë©”ëª¨ (ì„ íƒì‚¬í•­)';
                  case 'th': return 'à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸à¸à¸²à¸£à¸ˆà¸­à¸‡ (à¹„à¸¡à¹ˆà¸šà¸±à¸‡à¸„à¸±à¸š)';
                  case 'ja': return 'äºˆç´„ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰';
                  default: return 'Booking notes (optional)';
                }
              }

              if (patterns.searchGolfer.test(placeholder)) {
                switch (modalLanguage) {
                  case 'ko': return 'ê³¨í¼ ì´ë¦„ ë˜ëŠ” ìºë”” ë²ˆí˜¸ ê²€ìƒ‰';
                  case 'th': return 'à¸„à¹‰à¸™à¸«à¸²à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¸«à¸£à¸·à¸­à¸«à¸¡à¸²à¸¢à¹€à¸¥à¸‚à¹à¸„à¸”à¸”à¸µà¹‰';
                  case 'ja': return 'ã‚´ãƒ«ãƒ•ã‚¡ãƒ¼åã¾ãŸã¯ã‚­ãƒ£ãƒ‡ã‚£ç•ªå·ã§æ¤œç´¢';
                  default: return 'Search golfer name or caddy number';
                }
              }

              return placeholder;
            }
            
            switch (modalLanguage) {
              case 'ko': 
                return type === 'search' ? 'ê²€ìƒ‰í•˜ì„¸ìš”' : 
                       type === 'textarea' ? 'ë©”ëª¨ë¥¼ ìž…ë ¥í•˜ì„¸ìš”' : 'í•œêµ­ì–´ë¡œ ìž…ë ¥í•˜ì„¸ìš”';
              case 'th': 
                return type === 'search' ? 'à¸„à¹‰à¸™à¸«à¸²' : 
                       type === 'textarea' ? 'à¸à¸£à¸­à¸à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸' : 'à¸žà¸´à¸¡à¸žà¹Œà¹€à¸›à¹‡à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢';
              case 'ja': 
                return type === 'search' ? 'æ¤œç´¢â€¦' : 
                       type === 'textarea' ? 'ãƒ¡ãƒ¢ã‚’å…¥åŠ›' : 'æ—¥æœ¬èªžã§å…¥åŠ›';
              default: 
                return type === 'search' ? 'Search...' : 
                       type === 'textarea' ? 'Enter notes...' : 'Type in English';
            }
          };

          const containerStyle = {
            position: 'relative',
            width: '100%',
            ...style
          };

          const inputStyle = {
            width: '100%',
            padding: type === 'search' ? '10px 12px' : '8px 12px',
            paddingRight: showLangSelector ? '55px' : '12px',
            border: '2px solid #d1d5db',
            borderRadius: type === 'search' ? '8px' : '6px',
            fontSize: '0.875rem',
            resize: type === 'textarea' ? 'vertical' : undefined,
            outline: 'none',
            transition: 'border-color 0.2s ease',
            fontFamily: inputLang === 'th' ? 'system-ui, "Noto Sans Thai", sans-serif' :
                        inputLang === 'ko' ? 'system-ui, "Noto Sans KR", sans-serif' :
                        'system-ui, sans-serif'
          };

          const focusStyle = {
            borderColor: '#3b82f6',
            boxShadow: '0 0 0 3px rgba(59, 130, 246, 0.1)'
          };

          const selectorStyle = {
            position: 'absolute',
            right: '3px',
            top: type === 'textarea' ? '3px' : '3px',
            width: '48px',
            height: type === 'textarea' ? '30px' : type === 'search' ? '38px' : '34px',
            border: '1px solid #e5e7eb',
            backgroundColor: 'rgba(255,255,255,0.95)',
            fontSize: '0.7rem',
            cursor: 'pointer',
            borderRadius: '4px',
            color: '#6b7280',
            fontWeight: '500',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
          };

          return React.createElement('div', { style: containerStyle },
            type === 'textarea' 
              ? React.createElement('textarea', {
                  value,
                  onChange: (e) => onChange(e.target.value),
                  placeholder: getLocalizedPlaceholder(),
                  rows,
                  style: inputStyle,
                  disabled,
                  maxLength,
                  onFocus: (e) => Object.assign(e.target.style, focusStyle),
                  onKeyDown: (e) => { if (e.key === 'Enter' && window.__performSearch) window.__performSearch(); },
                  onBlur: (e) => {
                    e.target.style.borderColor = '#d1d5db';
                    e.target.style.boxShadow = 'none';
                  }
                })
              : React.createElement('input', {
                  type: 'text',
                  value,
                  onChange: (e) => onChange(e.target.value),
                  placeholder: getLocalizedPlaceholder(),
                  style: inputStyle,
                  disabled,
                  autoComplete,
                  maxLength,
                  onFocus: (e) => Object.assign(e.target.style, focusStyle),
                  onKeyDown: (e) => { if (e.key === 'Enter' && window.__performSearch) window.__performSearch(); },
                  onBlur: (e) => {
                    e.target.style.borderColor = '#d1d5db';
                    e.target.style.boxShadow = 'none';
                  }
                }),
            showLangSelector && onLangChange && !disabled && 
              null
          );
        };

        const LanguageBulkControl = ({
          onSetAll,
          label,
          currentDistribution,
          modalLanguage = 'en'
        }) => {
          const getLocalizedLabel = () => {
            if (label) return label;
            
            switch (modalLanguage) {
              case 'ko': return 'ëª¨ë“  ì–¸ì–´ ì„¤ì •';
              case 'th': return 'à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸ à¸²à¸©à¸²à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”';
              default: return 'Set All Languages';
            }
          };

          const getLocalizedOptions = () => {
            switch (modalLanguage) {
              case 'ko':
                return {
                  allEn: 'ðŸ‡ºðŸ‡¸ ëª¨ë‘ ì˜ì–´ë¡œ',
                  allTh: 'ðŸ‡¹ðŸ‡­ ëª¨ë‘ íƒœêµ­ì–´ë¡œ (à¹„à¸—à¸¢)',
                  allKo: 'ðŸ‡°ðŸ‡· ëª¨ë‘ í•œêµ­ì–´ë¡œ'
                };
              case 'th':
                return {
                  allEn: 'ðŸ‡ºðŸ‡¸ à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹€à¸›à¹‡à¸™à¸ à¸²à¸©à¸²à¸­à¸±à¸‡à¸à¸¤à¸©',
                  allTh: 'ðŸ‡¹ðŸ‡­ à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹€à¸›à¹‡à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢',
                  allKo: 'ðŸ‡°ðŸ‡· à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹€à¸›à¹‡à¸™à¸ à¸²à¸©à¸²à¹€à¸à¸²à¸«à¸¥à¸µ (í•œêµ­ì–´)'
                };
              case 'ja':
                return {
                  allEn: 'ðŸ‡ºðŸ‡¸ ã™ã¹ã¦è‹±èªž',
                  allTh: 'ðŸ‡¹ðŸ‡­ ã™ã¹ã¦ã‚¿ã‚¤èªž',
                  allKo: 'ðŸ‡°ðŸ‡· ã™ã¹ã¦éŸ“å›½èªž'
                };
              default:
                return {
                  allEn: 'ðŸ‡ºðŸ‡¸ All English',
                  allTh: 'ðŸ‡¹ðŸ‡­ All Thai (à¹„à¸—à¸¢)',
                  allKo: 'ðŸ‡°ðŸ‡· All Korean (í•œêµ­ì–´)'
                };
            }
          };

          const options = getLocalizedOptions();

          return React.createElement('div', { 
            style: { display: 'flex', flexDirection: 'column', gap: '4px' }
          },
            React.createElement('select', {
              value: '',
              onChange: (e) => {
                if (e.target.value) {
                  onSetAll(e.target.value);
                }
              },
              style: {
                padding: '6px 10px',
                border: '1px solid #d1d5db',
                borderRadius: '6px',
                fontSize: '0.75rem',
                backgroundColor: '#f8fafc',
                color: '#374151',
                fontWeight: '500'
              },
              title: 'Bulk change input language for all fields'
            },
              React.createElement('option', { value: '' }, getLocalizedLabel()),
              React.createElement('option', { value: 'en' }, options.allEn),
              React.createElement('option', { value: 'th' }, options.allTh),
              React.createElement('option', { value: 'ko' }, options.allKo),
              React.createElement('option', { value: 'ja' }, 'ðŸ‡¯ðŸ‡µ å…¨ã¦æ—¥æœ¬èªž')
            ),
            
            currentDistribution && React.createElement('div', { 
              style: { 
                fontSize: '0.7rem', 
                color: '#6b7280',
                display: 'flex',
                gap: '8px'
              }
            },
              React.createElement('span', null, `EN: ${currentDistribution.en}`),
              React.createElement('span', null, `TH: ${currentDistribution.th}`),
              React.createElement('span', null, `KO: ${currentDistribution.ko}`)
            )
          );
        };

        const detectLanguage = (text) => {
          const thaiRegex = /[\u0E00-\u0E7F]/;
          const koreanRegex = /[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]/;
          const englishRegex = /[a-zA-Z]/;
          const japaneseRegex = /[\u3040-\u30FF\u4E00-\u9FFF]/;
          
          const hasThai = thaiRegex.test(text);
          const hasKorean = koreanRegex.test(text);
          const hasEnglish = englishRegex.test(text);
          const hasJapanese = japaneseRegex.test(text);
          
          const count = [hasThai, hasKorean, hasEnglish, hasJapanese].filter(Boolean).length;
          
          if (count > 1) return 'mixed';
          if (hasThai) return 'th';
          if (hasKorean) return 'ko';
          if (hasJapanese) return 'ja';
          if (hasEnglish) return 'en';
          return 'en';
        };

        function buildTimes(from, to, stepMinutes = 5) {
          const toMinutes = (hhmm) => {
            const [h, m] = hhmm.split(":").map(Number);
            return h * 60 + m;
          };
          const pad = (n) => String(n).padStart(2, "0");
          const out = [];
          for (let t = toMinutes(from); t <= toMinutes(to); t += stepMinutes) {
            const h = Math.floor(t / 60);
            const m = t % 60;
            out.push(`${pad(h)}:${pad(m)}`);
          }
          return out;
        }

        const translations = {
          en: {
            teeSheet: "Tee Sheet",
            complex: "Complex",
            date: "Date",
            start: "Start", 
            end: "End",
            interval: "Interval",
            teesPerCourse: "Tees per Course",
            totalTees: "Total Tees",
            golferName: "Golfer Name",
            find: "Find",
            next: "Next",
            matches: "Matches",
            clearDay: "Clear Day",
            time: "Time",
            course: "Course",
            bookTeeTime: "Book Tee Time",
            editBooking: "Edit Booking",
            bookingType: "Booking Type",
            regular: "Regular",
            vip: "VIP",
            tournament: "Tournament", 
            society: "Society",
            golfers: "Golfers",
            addGolfer: "Add Golfer",
            handicap: "Handicap",
            assignCaddies: "Assign Caddies",
            selectCaddy: "Select Caddy",
            realTimeAvailability: "Real-time Availability",
            caddyAvailabilityStatus: "Caddy Availability Status",
            available: "Available",
            booked: "Booked",
            notes: "Notes",
            bookingNotes: "Booking notes (optional)",
            cancel: "Cancel",
            saveBooking: "Save Booking",
            updateBooking: "Update Booking",
            deleteBooking: "Delete Booking",
            confirmDeleteBooking: "Are you sure you want to delete this booking?",
            searchCaddyByNameOrNumber: "Search caddy by name or number",
            searchHint: "Type caddy number (#123) or name to find specific caddy",
            caddyDetails: "Caddy Details & Availability",
            availableNow: "Available Now",
            canBookImmediately: "Ready for immediate booking",
            currentlyBooked: "Currently Booked",
            bookedBy: "Booked by",
            currentTeeTime: "Current tee time",
            availableAfter: "Available after",
            onCourse: "On Course",
            currentRound: "Current round",
            estimatedFinish: "Estimated finish",
            nextAvailable: "Next available",
            onBreak: "On Break",
            backAt: "Back at",
            dayOff: "Day Off",
            notAvailableToday: "Not available today",
            caddyAvailabilityOverview: "Caddy Availability Overview",
            searchGolferOrCaddy: "Search golfer name or caddy number",
            languages: "Languages",
            rating: "Rating",
            inputLanguage: "Input Language",
            detectLanguage: "Auto-detect",
            bulkLanguageChange: "Bulk Language Change",
            languageSettings: "Language Settings"
          },
          th: {
            teeSheet: "à¸•à¸²à¸£à¸²à¸‡à¸—à¸µà¸­à¸­à¸Ÿ",
            complex: "à¸„à¸­à¸¡à¹€à¸žà¸¥à¹‡à¸à¸‹à¹Œ", 
            date: "à¸§à¸±à¸™à¸—à¸µà¹ˆ",
            start: "à¹€à¸£à¸´à¹ˆà¸¡",
            end: "à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”", 
            interval: "à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²",
            teesPerCourse: "à¸—à¸µà¸•à¹ˆà¸­à¸ªà¸™à¸²à¸¡",
            totalTees: "à¸—à¸µà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
            golferName: "à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™",
            find: "à¸«à¸²",
            next: "à¸–à¸±à¸”à¹„à¸›", 
            matches: "à¸žà¸š",
            clearDay: "à¸¥à¸šà¸—à¸±à¹‰à¸‡à¸§à¸±à¸™",
            time: "à¹€à¸§à¸¥à¸²",
            course: "à¸ªà¸™à¸²à¸¡",
            bookTeeTime: "à¸ˆà¸­à¸‡à¹€à¸§à¸¥à¸²à¹€à¸¥à¹ˆà¸™",
            editBooking: "à¹à¸à¹‰à¹„à¸‚à¸à¸²à¸£à¸ˆà¸­à¸‡",
            bookingType: "à¸›à¸£à¸°à¹€à¸ à¸—à¸à¸²à¸£à¸ˆà¸­à¸‡",
            regular: "à¸—à¸±à¹ˆà¸§à¹„à¸›",
            vip: "à¸§à¸µà¹„à¸­à¸žà¸µ",
            tournament: "à¸—à¸±à¸§à¸£à¹Œà¸™à¸²à¹€à¸¡à¸™à¸•à¹Œ",
            society: "à¸ªà¸¡à¸²à¸„à¸¡", 
            golfers: "à¸™à¸±à¸à¸à¸­à¸¥à¹Œà¸Ÿ",
            addGolfer: "à¹€à¸žà¸´à¹ˆà¸¡à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™",
            handicap: "à¹à¸®à¸™à¸”à¸´à¹à¸„à¸›",
            assignCaddies: "à¸¡à¸­à¸šà¸«à¸¡à¸²à¸¢à¹à¸„à¸”à¸”à¸µà¹‰",
            selectCaddy: "à¹€à¸¥à¸·à¸­à¸à¹à¸„à¸”à¸”à¸µà¹‰",
            realTimeAvailability: "à¸„à¸§à¸²à¸¡à¸žà¸£à¹‰à¸­à¸¡à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¡à¹Œ",
            caddyAvailabilityStatus: "à¸ªà¸–à¸²à¸™à¸°à¸„à¸§à¸²à¸¡à¸žà¸£à¹‰à¸­à¸¡à¸‚à¸­à¸‡à¹à¸„à¸”à¸”à¸µà¹‰",
            available: "à¸§à¹ˆà¸²à¸‡",
            booked: "à¸ˆà¸­à¸‡à¹à¸¥à¹‰à¸§",
            notes: "à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸",
            bookingNotes: "à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸à¸à¸²à¸£à¸ˆà¸­à¸‡ (à¹„à¸¡à¹ˆà¸šà¸±à¸‡à¸„à¸±à¸š)",
            cancel: "à¸¢à¸à¹€à¸¥à¸´à¸",
            saveBooking: "à¸šà¸±à¸™à¸—à¸¶à¸à¸à¸²à¸£à¸ˆà¸­à¸‡",
            updateBooking: "à¸­à¸±à¸žà¹€à¸”à¸—à¸à¸²à¸£à¸ˆà¸­à¸‡",
            deleteBooking: "à¸¥à¸šà¸à¸²à¸£à¸ˆà¸­à¸‡",
            confirmDeleteBooking: "à¸„à¸¸à¸“à¹à¸™à¹ˆà¹ƒà¸ˆà¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆà¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¸à¸²à¸£à¸ˆà¸­à¸‡à¸™à¸µà¹‰?",
            searchCaddyByNameOrNumber: "à¸„à¹‰à¸™à¸«à¸²à¹à¸„à¸”à¸”à¸µà¹‰à¸”à¹‰à¸§à¸¢à¸Šà¸·à¹ˆà¸­à¸«à¸£à¸·à¸­à¹€à¸¥à¸‚à¸—à¸µà¹ˆ",
            searchHint: "à¸žà¸´à¸¡à¸žà¹Œà¸«à¸¡à¸²à¸¢à¹€à¸¥à¸‚à¹à¸„à¸”à¸”à¸µà¹‰ (#123) à¸«à¸£à¸·à¸­à¸Šà¸·à¹ˆà¸­à¹€à¸žà¸·à¹ˆà¸­à¸„à¹‰à¸™à¸«à¸²à¹à¸„à¸”à¸”à¸µà¹‰à¹€à¸‰à¸žà¸²à¸°",
            caddyDetails: "à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”à¹à¸„à¸”à¸”à¸µà¹‰à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¸žà¸£à¹‰à¸­à¸¡",
            availableNow: "à¸žà¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸•à¸­à¸™à¸™à¸µà¹‰",
            canBookImmediately: "à¸žà¸£à¹‰à¸­à¸¡à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸ˆà¸­à¸‡à¸—à¸±à¸™à¸—à¸µ",
            currentlyBooked: "à¸–à¸¹à¸à¸ˆà¸­à¸‡à¹ƒà¸™à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™",
            bookedBy: "à¸ˆà¸­à¸‡à¹‚à¸”à¸¢",
            currentTeeTime: "à¹€à¸§à¸¥à¸²à¸—à¸µà¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™",
            availableAfter: "à¸žà¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸«à¸¥à¸±à¸‡",
            onCourse: "à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸ªà¸™à¸²à¸¡",
            currentRound: "à¸£à¸­à¸šà¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™",
            estimatedFinish: "à¸„à¸²à¸”à¸à¸²à¸£à¸“à¹Œà¸ˆà¸š",
            nextAvailable: "à¸žà¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸„à¸£à¸±à¹‰à¸‡à¸–à¸±à¸”à¹„à¸›",
            onBreak: "à¸žà¸±à¸à¸œà¹ˆà¸­à¸™",
            backAt: "à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ",
            dayOff: "à¸§à¸±à¸™à¸«à¸¢à¸¸à¸”",
            notAvailableToday: "à¹„à¸¡à¹ˆà¸žà¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸§à¸±à¸™à¸™à¸µà¹‰",
            caddyAvailabilityOverview: "à¸ à¸²à¸žà¸£à¸§à¸¡à¸„à¸§à¸²à¸¡à¸žà¸£à¹‰à¸­à¸¡à¸‚à¸­à¸‡à¹à¸„à¸”à¸”à¸µà¹‰",
            searchGolferOrCaddy: "à¸„à¹‰à¸™à¸«à¸²à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¸«à¸£à¸·à¸­à¸«à¸¡à¸²à¸¢à¹€à¸¥à¸‚à¹à¸„à¸”à¸”à¸µà¹‰",
            languages: "à¸ à¸²à¸©à¸²",
            rating: "à¸„à¸°à¹à¸™à¸™",
            inputLanguage: "à¸ à¸²à¸©à¸²à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸›à¹‰à¸­à¸™",
            detectLanguage: "à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´",
            bulkLanguageChange: "à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ à¸²à¸©à¸²à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
            languageSettings: "à¸à¸²à¸£à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸ à¸²à¸©à¸²"
          },
          ko: {
            teeSheet: "í‹° ì‹œíŠ¸",
            complex: "ì»´í”Œë ‰ìŠ¤",
            date: "ë‚ ì§œ",
            start: "ì‹œìž‘",
            end: "ë",
            interval: "ê°„ê²©",
            teesPerCourse: "ì½”ìŠ¤ë‹¹ í‹°",
            totalTees: "ì´ í‹°",
            golferName: "ê³¨í¼ ì´ë¦„",
            find: "ì°¾ê¸°",
            next: "ë‹¤ìŒ",
            matches: "ì¼ì¹˜",
            clearDay: "í•˜ë£¨ ì§€ìš°ê¸°",
            time: "ì‹œê°„",
            course: "ì½”ìŠ¤",
            bookTeeTime: "í‹°íƒ€ìž„ ì˜ˆì•½",
            editBooking: "ì˜ˆì•½ íŽ¸ì§‘",
            bookingType: "ì˜ˆì•½ ìœ í˜•",
            regular: "ì¼ë°˜",
            vip: "VIP",
            tournament: "í† ë„ˆë¨¼íŠ¸",
            society: "ì†Œì‚¬ì´ì–´í‹°",
            golfers: "ê³¨í¼ë“¤",
            addGolfer: "ê³¨í¼ ì¶”ê°€",
            handicap: "í•¸ë””ìº¡",
            assignCaddies: "ìºë”” ë°°ì •",
            selectCaddy: "ìºë”” ì„ íƒ",
            realTimeAvailability: "ì‹¤ì‹œê°„ ê°€ìš©ì„±",
            caddyAvailabilityStatus: "ìºë”” ê°€ìš©ì„± ìƒíƒœ",
            available: "ì´ìš© ê°€ëŠ¥",
            booked: "ì˜ˆì•½ë¨",
            notes: "ë©”ëª¨",
            bookingNotes: "ì˜ˆì•½ ë©”ëª¨ (ì„ íƒì‚¬í•­)",
            cancel: "ì·¨ì†Œ",
            saveBooking: "ì˜ˆì•½ ì €ìž¥",
            updateBooking: "ì˜ˆì•½ ì—…ë°ì´íŠ¸",
            deleteBooking: "ì˜ˆì•½ ì‚­ì œ",
            confirmDeleteBooking: "ì´ ì˜ˆì•½ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            searchCaddyByNameOrNumber: "ì´ë¦„ì´ë‚˜ ë²ˆí˜¸ë¡œ ìºë”” ê²€ìƒ‰",
            searchHint: "ìºë”” ë²ˆí˜¸ (#123) ë˜ëŠ” ì´ë¦„ì„ ìž…ë ¥í•˜ì—¬ íŠ¹ì • ìºë”” ì°¾ê¸°",
            caddyDetails: "ìºë”” ì„¸ë¶€ì •ë³´ ë° ê°€ìš©ì„±",
            availableNow: "ì§€ê¸ˆ ì´ìš© ê°€ëŠ¥",
            canBookImmediately: "ì¦‰ì‹œ ì˜ˆì•½ ê°€ëŠ¥",
            currentlyBooked: "í˜„ìž¬ ì˜ˆì•½ë¨",
            bookedBy: "ì˜ˆì•½ìž",
            currentTeeTime: "í˜„ìž¬ í‹°íƒ€ìž„",
            availableAfter: "ì´í›„ ì´ìš© ê°€ëŠ¥",
            onCourse: "ì½”ìŠ¤ ì¤‘",
            currentRound: "í˜„ìž¬ ë¼ìš´ë“œ",
            estimatedFinish: "ì˜ˆìƒ ì¢…ë£Œ",
            nextAvailable: "ë‹¤ìŒ ì´ìš© ê°€ëŠ¥",
            onBreak: "íœ´ì‹ ì¤‘",
            backAt: "ë³µê·€ ì‹œê°„",
            dayOff: "íœ´ë¬´ì¼",
            notAvailableToday: "ì˜¤ëŠ˜ ì´ìš© ë¶ˆê°€",
            caddyAvailabilityOverview: "ìºë”” ê°€ìš©ì„± ê°œìš”",
            searchGolferOrCaddy: "ê³¨í¼ ì´ë¦„ ë˜ëŠ” ìºë”” ë²ˆí˜¸ ê²€ìƒ‰",
            languages: "ì–¸ì–´",
            rating: "í‰ì ",
            inputLanguage: "ìž…ë ¥ ì–¸ì–´",
            detectLanguage: "ìžë™ ê°ì§€",
            bulkLanguageChange: "ì „ì²´ ì–¸ì–´ ë³€ê²½",
            languageSettings: "ì–¸ì–´ ì„¤ì •"
          }
        
  ,
  ja: {
    teeSheet: "ãƒ†ã‚£ãƒ¼ã‚·ãƒ¼ãƒˆ",
    complex: "ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚¯ã‚¹",
    date: "æ—¥ä»˜",
    start: "é–‹å§‹",
    end: "çµ‚äº†",
    interval: "é–“éš”",
    teesPerCourse: "ã‚³ãƒ¼ã‚¹æ¯Žã®ãƒ†ã‚£ãƒ¼",
    totalTees: "ç·ãƒ†ã‚£ãƒ¼æ•°",
    golferName: "ã‚´ãƒ«ãƒ•ã‚¡ãƒ¼å",
    find: "æ¤œç´¢",
    next: "æ¬¡ã¸",
    matches: "ä»¶",
    clearDay: "å½“æ—¥ã‚’ã‚¯ãƒªã‚¢",
    time: "æ™‚é–“",
    course: "ã‚³ãƒ¼ã‚¹",
    bookTeeTime: "ãƒ†ã‚£ãƒ¼ã‚¿ã‚¤ãƒ ã‚’äºˆç´„",
    editBooking: "äºˆç´„ã‚’ç·¨é›†",
    bookingType: "äºˆç´„ã‚¿ã‚¤ãƒ—",
    regular: "é€šå¸¸",
    vip: "VIP",
    tournament: "ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆ",
    society: "ã‚½ã‚µã‚¨ãƒ†ã‚£",
    golfers: "ã‚´ãƒ«ãƒ•ã‚¡ãƒ¼",
    addGolfer: "ã‚´ãƒ«ãƒ•ã‚¡ãƒ¼è¿½åŠ ",
    handicap: "ãƒãƒ³ãƒ‡ã‚£",
    assignCaddies: "ã‚­ãƒ£ãƒ‡ã‚£ã‚’å‰²å½“",
    selectCaddy: "ã‚­ãƒ£ãƒ‡ã‚£ã‚’é¸æŠž",
    realTimeAvailability: "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç©ºãçŠ¶æ³",
    caddyAvailabilityStatus: "ã‚­ãƒ£ãƒ‡ã‚£ç©ºãçŠ¶æ³",
    available: "ç©ºã",
    booked: "äºˆç´„æ¸ˆã¿",
    notes: "ãƒ¡ãƒ¢",
    bookingNotes: "äºˆç´„ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰",
    cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
    saveBooking: "äºˆç´„ã‚’ä¿å­˜",
    updateBooking: "äºˆç´„ã‚’æ›´æ–°",
    deleteBooking: "äºˆç´„ã‚’å‰Šé™¤",
    confirmDeleteBooking: "ã“ã®äºˆç´„ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
    searchCaddyByNameOrNumber: "ã‚­ãƒ£ãƒ‡ã‚£åã¾ãŸã¯ç•ªå·ã§æ¤œç´¢",
    searchHint: "ã‚­ãƒ£ãƒ‡ã‚£ç•ªå·ï¼ˆ#123ï¼‰ã¾ãŸã¯åå‰ã§æ¤œç´¢",
    caddyDetails: "ã‚­ãƒ£ãƒ‡ã‚£è©³ç´°ã¨ç©ºãçŠ¶æ³",
    availableNow: "ç¾åœ¨ç©ºãã‚ã‚Š",
    canBookImmediately: "ã™ãã«äºˆç´„å¯èƒ½",
    currentlyBooked: "ç¾åœ¨äºˆç´„ä¸­",
    bookedBy: "äºˆç´„è€…",
    currentTeeTime: "ç¾åœ¨ã®ãƒ†ã‚£ãƒ¼ã‚¿ã‚¤ãƒ ",
    availableAfter: "æ¬¡ã®ç©ºã",
    onCourse: "ã‚³ãƒ¼ã‚¹ä¸Š",
    currentRound: "ç¾åœ¨ã®ãƒ©ã‚¦ãƒ³ãƒ‰",
    estimatedFinish: "çµ‚äº†è¦‹è¾¼ã¿",
    nextAvailable: "æ¬¡ã®ç©ºãæ™‚é–“",
    onBreak: "ä¼‘æ†©ä¸­",
    backAt: "å¾©å¸°äºˆå®š",
    dayOff: "ä¼‘æš‡",
    notAvailableToday: "æœ¬æ—¥ã¯åˆ©ç”¨ä¸å¯",
    caddyAvailabilityOverview: "ã‚­ãƒ£ãƒ‡ã‚£ç©ºãçŠ¶æ³ã®æ¦‚è¦",
    searchGolferOrCaddy: "ã‚´ãƒ«ãƒ•ã‚¡ãƒ¼åã¾ãŸã¯ã‚­ãƒ£ãƒ‡ã‚£ç•ªå·ã§æ¤œç´¢",
    languages: "è¨€èªž",
    rating: "è©•ä¾¡",
    inputLanguage: "å…¥åŠ›è¨€èªž",
    detectLanguage: "è‡ªå‹•åˆ¤å®š",
    bulkLanguageChange: "ä¸€æ‹¬è¨€èªžå¤‰æ›´",
    languageSettings: "è¨€èªžè¨­å®š"
  }
};

        function useI18n() {
          const [language, setLanguage] = useState('en');
          
          const t = useCallback((key) => {
            return translations[language][key] || key;
          }, [language]);

          return { t, language, setLanguage };
        }

        function getCaddyStatusColor(status) {
          switch (status) {
            case 'available': return '#10b981';
            case 'booked': return '#f59e0b';
            case 'on-course': return '#3b82f6';
            case 'on-break': return '#8b5cf6';
            case 'day-off': return '#6b7280';
            default: return '#6b7280';
          }
        }

        function getBookingTypeColor(type) {
          switch (type) {
            case 'vip': return '#8b5cf6';
            case 'tournament': return '#ef4444';
            case 'society': return '#f59e0b';
            case 'regular': return '#3b82f6';
            default: return '#6b7280';
          }
        }

        const BookingModal = ({ isOpen, slot, onClose, onSaveBooking, language = 'en' }) => {
  // ---- Robust Caddy Population: never show an empty list ----
  // Seed set used if no runtime data is provided
  var __seedCaddies = [
    { id:'c001', number:'001', name:'Somchai', status:'available' },
    { id:'c003', number:'003', name:'Niran',   status:'available' },
    { id:'c007', number:'007', name:'Mali',    status:'available' },
    { id:'c012', number:'012', name:'Porn',    status:'available' },
    { id:'c015', number:'015', name:'Nok',     status:'available' },
    { id:'c021', number:'021', name:'Kanya',   status:'available' }
  ];

  // Pull global list if present; otherwise seed
  var __allCaddies = (typeof window !== 'undefined' && Array.isArray(window.availableCaddies) && window.availableCaddies.length)
    ? window.availableCaddies : __seedCaddies;

  // If slot-scoped caddies exist, prefer those; else use global
  var __slotCaddies = (slot && Array.isArray(slot.availableCaddies) && slot.availableCaddies.length)
    ? slot.availableCaddies : __allCaddies;

  // Build filtered list based on current search term if present
  var __searchTerm = (typeof caddySearchTerm !== 'undefined' && caddySearchTerm) ? String(caddySearchTerm).trim().toLowerCase() : '';
  var __filteredBySearch = __slotCaddies.filter(function(cd){
    if (!__searchTerm) return true;
    return (String(cd.number||'').toLowerCase().indexOf(__searchTerm) !== -1) ||
           (String(cd.name||'').toLowerCase().indexOf(__searchTerm) !== -1);
  });

  // Final list used by the UI; guarantee non-empty by falling back to global or seed
  var __caddiesFinal = __filteredBySearch.length ? __filteredBySearch
                    : (__slotCaddies.length ? __slotCaddies
                    : (__allCaddies.length ? __allCaddies : __seedCaddies));
  // ---- End robust caddy population ----

          const t = useCallback((key) => {
            return translations[language][key] || key;
          }, [language]);
          
          const [golfers, setGolfers] = useState([
            { id: 'g1', name: '', handicap: undefined, inputLang: language }
          ]);
          const [notes, setNotes] = useState('');
          const [notesInputLang, setNotesInputLang] = useState(language);
          const [bookingType, setBookingType] = useState('regular');
          const [selectedCaddies, setSelectedCaddies] = useState({});
          const [isEditing, setIsEditing] = useState(false);
          const [caddySearchTerm, setCaddySearchTerm] = useState('');
          const [caddySearchLang, setCaddySearchLang] = useState(language);

          useEffect(() => {
            setNotesInputLang(language);
            setCaddySearchLang(language);
            setGolfers(prev => prev.map(g => ({ ...g, inputLang: g.inputLang || language })));
          }, [language]);

          useEffect(() => {
            if (isOpen && slot) {
              if (slot.booking) {
                setIsEditing(true);
                setGolfers(slot.booking.golfers.map(g => ({...g, inputLang: g.inputLang || language})));
                setNotes(slot.booking.notes || '');
                setNotesInputLang(slot.booking.notesLang || language);
                setBookingType(slot.booking.bookingType);
                
                const caddyMap = {};
                slot.booking.caddyBookings?.forEach(cb => {
                  caddyMap[cb.golferId] = cb.caddyId;
                });
                setSelectedCaddies(caddyMap);
              } else {
                setIsEditing(false);
                setGolfers([{ id: 'g1', name: '', handicap: undefined, inputLang: language }]);
                setNotes('');
                setNotesInputLang(language);
                setBookingType('regular');
                setSelectedCaddies({});
              }
              setCaddySearchTerm('');
              setCaddySearchLang(language);
            }
          }, [isOpen, slot]);

          if (!isOpen || !slot) return null;

          const availableCaddies = slot.availableCaddies || [];

          const filteredCaddies = availableCaddies.filter(caddy => {
            if (!caddySearchTerm) return true;
            const searchLower = caddySearchTerm.toLowerCase();
            
            if (caddy.number.includes(searchLower.replace('#', ''))) return true;
            
            const searchInName = (name) => name.toLowerCase().includes(searchLower);
            
            if (caddySearchLang === 'th' && caddy.nameTh) {
              return searchInName(caddy.nameTh);
            } else if (caddySearchLang === 'ko' && caddy.nameKo) {
              return searchInName(caddy.nameKo);
            } else if (caddySearchLang === 'en' && caddy.nameEn) {
              return searchInName(caddy.nameEn);
            }
            
            return searchInName(caddy.name);
          });

          const addGolfer = () => {
            if (golfers.length < 4) {
              setGolfers([...golfers, { 
                id: `g${golfers.length + 1}`, 
                name: '', 
                handicap: undefined,
                inputLang: language 
              }]);
            }
          };

          const removeGolfer = (index) => {
            if (golfers.length > 1) {
              const removedGolfer = golfers[index];
              const newGolfers = golfers.filter((_, i) => i !== index);
              setGolfers(newGolfers);
              
              const newSelectedCaddies = { ...selectedCaddies };
              delete newSelectedCaddies[removedGolfer.id];
              setSelectedCaddies(newSelectedCaddies);
            }
          };

          const updateGolfer = (index, field, value) => {
            const newGolfers = [...golfers];
            if (field === 'handicap') {
              newGolfers[index].handicap = value === '' ? undefined : Number(value);
            } else {
              newGolfers[index].name = value;
              if (value) {
                const detectedLang = detectLanguage(value);
                if (detectedLang !== 'mixed') {
                  newGolfers[index].inputLang = detectedLang;
                }
              }
            }
            setGolfers(newGolfers);
          };

          const handleBulkLanguageChange = (lang) => {
            setGolfers(golfers.map(g => ({ ...g, inputLang: lang })));
            setNotesInputLang(lang);
            setCaddySearchLang(lang);
          };

          const getLanguageDistribution = () => {
            const dist = { en: 0, th: 0, ko: 0, ja: 0 };
            golfers.forEach(g => {
              if (g.inputLang) dist[g.inputLang]++;
            });
            if (notesInputLang) dist[notesInputLang]++;
            return dist;
          };

          const handleSave = async () => {
            const validGolfers = golfers.filter(g => g.name.trim());
            if (validGolfers.length === 0) {
              const alertMessage = language === 'th' 
                ? 'à¸à¸£à¸¸à¸“à¸²à¹€à¸žà¸´à¹ˆà¸¡à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 1 à¸„à¸™' 
                : language === 'ko' 
                ? 'ìµœì†Œ 1ëª…ì˜ ê³¨í¼ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”'
                : 'Please add at least one golfer';
              alert(alertMessage);
              return;
            }

            const caddyBookings = Object.entries(selectedCaddies).map(([golferId, caddySelection]) => {
              const golfer = validGolfers.find(g => g.id === golferId);
              const isWaitlisted = caddySelection.includes('-waitlist');
              const caddyId = caddySelection.replace('-waitlist', '');
              const caddy = availableCaddies.find(c => c.id === caddyId);
              
              return {
                golferId,
                caddyId,
                golferName: golfer?.name || '',
                caddyName: caddy?.name || '',
                caddyNumber: caddy?.number || '000',
                status: isWaitlisted ? 'waitlisted' : 'confirmed',
                isWaitlisted
              };
            }).filter(booking => booking.caddyId);

            const booking = {
              id: slot.booking?.id || `booking-${Date.now()}`,
              golfers: validGolfers,
              notes,
              notesLang: notesInputLang,
              bookingType,
              status: 'confirmed',
              caddyBookings
            };

            const syncManager = ScheduleSyncManager.getInstance();
            
            try {
              const conflicts = syncManager.validateBooking(booking, slot);
              
              if (conflicts.length > 0) {
                const conflictMessages = conflicts.map(c => c.message).join('\n');
                const confirmMessage = language === 'th' 
                  ? `à¸žà¸šà¸‚à¹‰à¸­à¸‚à¸±à¸”à¹à¸¢à¹‰à¸‡à¹ƒà¸™à¸•à¸²à¸£à¸²à¸‡à¹€à¸§à¸¥à¸²:\n${conflictMessages}\n\nà¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸—à¸³à¸à¸²à¸£à¸ˆà¸­à¸‡à¸•à¹ˆà¸­à¹„à¸›à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ?`
                  : language === 'ko'
                  ? `ì¼ì • ì¶©ëŒì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤:\n${conflictMessages}\n\nê³„ì† ì˜ˆì•½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
                  : `Schedule conflicts detected:\n${conflictMessages}\n\nDo you want to proceed anyway?`;
                
                if (!confirm(confirmMessage)) {
                  return;
                }
              }

              const syncResult = await syncManager.syncBookingToSchedules(booking, slot);
              
              if (!syncResult.success) {
                const errorMessage = language === 'th' 
                  ? 'à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸‹à¸´à¸‡à¸„à¹Œà¸•à¸²à¸£à¸²à¸‡à¹€à¸§à¸¥à¸²à¹„à¸”à¹‰ à¸à¸£à¸¸à¸“à¸²à¸¥à¸­à¸‡à¹ƒà¸«à¸¡à¹ˆà¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡'
                  : language === 'ko'
                  ? 'ì¼ì • ë™ê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
                  : 'Failed to sync schedules. Please try again.';
                alert(errorMessage);
                return;
              }

              if (syncResult.warnings && syncResult.warnings.length > 0) {
                const warningMessage = language === 'th' 
                  ? `à¸à¸²à¸£à¸ˆà¸­à¸‡à¸ªà¸³à¹€à¸£à¹‡à¸ˆ à¹à¸•à¹ˆà¸¡à¸µà¸„à¸³à¹€à¸•à¸·à¸­à¸™:\n${syncResult.warnings.join('\n')}`
                  : language === 'ko'
                  ? `ì˜ˆì•½ì´ ì„±ê³µí–ˆì§€ë§Œ ê²½ê³ ì‚¬í•­ì´ ìžˆìŠµë‹ˆë‹¤:\n${syncResult.warnings.join('\n')}`
                  : `Booking successful with warnings:\n${syncResult.warnings.join('\n')}`;
                alert(warningMessage);
              }

              onSaveBooking(slot, booking);
              onClose();

            } catch (error) {
              const errorMessage = language === 'th' 
                ? `à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”: ${error instanceof Error ? error.message : 'à¹„à¸¡à¹ˆà¸—à¸£à¸²à¸šà¸ªà¸²à¹€à¸«à¸•à¸¸'}`
                : language === 'ko'
                ? `ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`
                : `Error occurred: ${error instanceof Error ? error.message : 'Unknown error'}`;
              alert(errorMessage);
            }
          };

          return React.createElement('div', {
            style: {
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0,0,0,0.6)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 10000
            }
          },
            React.createElement('div', { className: 'modal-card modal-forced', 
              style: {
                backgroundColor: 'white',
                borderRadius: '12px',
                padding: '24px',
                maxWidth: '800px',
                maxHeight: '90vh',
                overflowY: 'auto',
                boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',
                border: '1px solid #e5e7eb'
              }
            },
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }
              },
                React.createElement('h3', {
                  style: { margin: 0, fontSize: '1.25rem', fontWeight: '600', color: '#1f2937' }
                }, `${isEditing ? t('editBooking') : t('bookTeeTime')} - ${slot.time}`),
                React.createElement('button', {
                  onClick: onClose,
                  style: {
                    background: 'none',
                    border: 'none',
                    fontSize: '24px',
                    cursor: 'pointer',
                    color: '#6b7280'
                  }
                }, 'Ã—')
              ),

              React.createElement('div', { style: { marginBottom: '20px' } },
                React.createElement('label', {
                  style: { display: 'block', marginBottom: '8px', fontSize: '0.875rem', fontWeight: '500', color: '#374151' }
                }, t('assignCaddies')),
                React.createElement('div', {
                  style: { marginBottom: '12px' }
                },
                  React.createElement(MultiLangInput, {
                    type: 'search',
                    value: caddySearchTerm,
                    onChange: setCaddySearchTerm,
                    placeholder: 'Search caddy by name or number',
                    inputLang: caddySearchLang,
                    onLangChange: setCaddySearchLang,
                    modalLanguage: language
                  })
                ),
                React.createElement('div', {
                  style: {
                    maxHeight: '200px',
                    overflowY: 'auto',
                    border: '1px solid #e5e7eb',
                    borderRadius: '6px',
                    padding: '8px'
                  }
                },
                  filteredCaddies.length === 0 ? 
                    React.createElement('div', {
                      style: { textAlign: 'center', color: '#6b7280', fontSize: '0.8rem', padding: '20px' }
                    }, 'No caddies found') :
                    filteredCaddies.slice(0, 10).map(caddy => {
                      const caddyName = caddySearchLang === 'th' && caddy.nameTh ? caddy.nameTh :
                                       caddySearchLang === 'ko' && caddy.nameKo ? caddy.nameKo :
                                       caddySearchLang === 'ja' && caddy.nameJa ? caddy.nameJa :
                                       caddy.nameEn || caddy.name;
                      
                      return React.createElement('div', {
                        key: caddy.id,
                        style: {
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          padding: '8px',
                          marginBottom: '4px',
                          backgroundColor: '#f8fafc',
                          borderRadius: '4px',
                          border: '1px solid #e5e7eb',
                          cursor: 'pointer',
                          transition: 'all 0.2s ease'
                        },
                        onClick: () => {
                          // Quick assign to first available golfer without caddy
                          const availableGolfer = golfers.find(g => g.name.trim() && !selectedCaddies[g.id]);
                          if (availableGolfer) {
                            const newSelectedCaddies = { ...selectedCaddies };
                            if (caddy.status === 'available') {
                              newSelectedCaddies[availableGolfer.id] = caddy.id;
                            } else {
                              newSelectedCaddies[availableGolfer.id] = `${caddy.id}-waitlist`;
                            }
                            setSelectedCaddies(newSelectedCaddies);
                          }
                        },
                        onMouseEnter: (e) => {
                          e.currentTarget.style.backgroundColor = '#e5e7eb';
                          e.currentTarget.style.transform = 'scale(1.02)';
                        },
                        onMouseLeave: (e) => {
                          e.currentTarget.style.backgroundColor = '#f8fafc';
                          e.currentTarget.style.transform = 'scale(1)';
                        }
                      },
                        React.createElement('div', {
                          style: { display: 'flex', alignItems: 'center', gap: '8px' }
                        },
                          React.createElement('div', {
                            style: {
                              fontSize: '0.7rem',
                              fontWeight: '600',
                              color: 'white',
                              backgroundColor: getCaddyStatusColor(caddy.status),
                              padding: '4px 8px',
                              borderRadius: '4px',
                              minWidth: '40px',
                              textAlign: 'center'
                            }
                          }, `#${caddy.number}`),
                          React.createElement('div', null,
                            React.createElement('div', {
                              style: { fontSize: '0.8rem', fontWeight: '500' }
                            }, caddyName),
                            React.createElement('div', {
                              style: { fontSize: '0.7rem', color: '#6b7280' }
                            }, `â­ ${caddy.rating} | ${caddy.languages.join(', ')}`)
                          )
                        ),
                        React.createElement('div', {
                          style: { 
                            fontSize: '0.7rem', 
                            fontWeight: '500',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'flex-end',
                            gap: '2px'
                          }
                        }, 
                          React.createElement('span', {
                            style: { color: getCaddyStatusColor(caddy.status) }
                          }, caddy.status === 'available' ? 'âœ… Available' : `ðŸ”„ ${caddy.status}`),
                          caddy.status !== 'available' && React.createElement('span', {
                            style: { 
                              fontSize: '0.6rem', 
                              color: '#d97706',
                              fontStyle: 'italic'
                            }
                          }, 'Click for Waitlist'),
                          caddy.status === 'available' && React.createElement('span', {
                            style: { 
                              fontSize: '0.6rem', 
                              color: '#059669',
                              fontStyle: 'italic'
                            }
                          }, 'Click to Assign')
                        )
                      );
                    })
                ),
                golfers.length > 0 && React.createElement('div', {
                  style: { 
                    marginTop: '16px', 
                    padding: '12px',
                    backgroundColor: '#f0f9ff',
                    borderRadius: '6px',
                    border: '1px solid #bae6fd'
                  }
                },
                  React.createElement('div', {
                    style: { fontSize: '0.8rem', fontWeight: '600', color: '#0c4a6e', marginBottom: '8px' }
                  }, 'ðŸ‘¥ Current Assignments:'),
                  ...golfers.map((golfer, index) => {
                    if (!golfer.name.trim()) return null;
                    const assignment = selectedCaddies[golfer.id];
                    const isWaitlisted = assignment?.includes('-waitlist');
                    const caddyId = assignment?.replace('-waitlist', '');
                    const assignedCaddy = caddyId ? demoCaddies.find(c => c.id === caddyId) : null;
                    
                    return React.createElement('div', {
                      key: golfer.id,
                      style: {
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        padding: '6px 8px',
                        marginBottom: '4px',
                        backgroundColor: assignment ? (isWaitlisted ? '#fef3c7' : '#dcfce7') : '#f3f4f6',
                        borderRadius: '4px',
                        border: `1px solid ${assignment ? (isWaitlisted ? '#f59e0b' : '#16a34a') : '#d1d5db'}`
                      }
                    },
                      React.createElement('span', {
                        style: { fontSize: '0.8rem', fontWeight: '500' }
                      }, golfer.name),
                      React.createElement('div', {
                        style: { fontSize: '0.7rem', display: 'flex', alignItems: 'center', gap: '4px' }
                      },
                        assignment ? (
                          React.createElement('span', {
                            style: { 
                              color: isWaitlisted ? '#d97706' : '#16a34a',
                              fontWeight: '500'
                            }
                          }, `${isWaitlisted ? 'ðŸ“‹' : 'âœ…'} #${assignedCaddy?.number} ${assignedCaddy?.name}${isWaitlisted ? ' (Waitlist)' : ''}`)
                        ) : (
                          React.createElement('span', {
                            style: { color: '#6b7280', fontStyle: 'italic' }
                          }, 'No caddy assigned')
                        ),
                        assignment && React.createElement('button', {
                          onClick: () => {
                            const newSelectedCaddies = { ...selectedCaddies };
                            delete newSelectedCaddies[golfer.id];
                            setSelectedCaddies(newSelectedCaddies);
                          },
                          style: {
                            background: 'none',
                            border: 'none',
                            color: '#ef4444',
                            cursor: 'pointer',
                            fontSize: '0.8rem',
                            padding: '2px',
                            marginLeft: '4px'
                          }
                        }, 'âœ–')
                      )
                    );
                  }).filter(Boolean)
                )
              ),

              React.createElement('div', {
                style: {
                  backgroundColor: '#f8fafc',
                  border: '1px solid #e5e7eb',
                  borderRadius: '8px',
                  padding: '12px',
                  marginBottom: '20px'
                }
              },
                React.createElement('div', {
                  style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }
                },
                  React.createElement('span', {
                    style: { fontSize: '0.875rem', fontWeight: '500', color: '#374151' }
                  }, t('languageSettings')),
                  React.createElement(LanguageBulkControl, {
                    onSetAll: handleBulkLanguageChange,
                    currentDistribution: getLanguageDistribution(),
                    modalLanguage: language
                  })
                )
              ),

              React.createElement('div', { style: { marginBottom: '20px' } },
                React.createElement('label', {
                  style: { display: 'block', marginBottom: '8px', fontSize: '0.875rem', fontWeight: '500', color: '#374151' }
                }, t('bookingType')),
                React.createElement('select', {
                  value: bookingType,
                  onChange: (e) => setBookingType(e.target.value),
                  style: {
                    width: '100%',
                    padding: '8px 12px',
                    border: '2px solid #d1d5db',
                    borderRadius: '6px',
                    fontSize: '0.875rem'
                  }
                },
                  React.createElement('option', { value: 'regular' }, t('regular')),
                  React.createElement('option', { value: 'vip' }, t('vip')),
                  React.createElement('option', { value: 'tournament' }, t('tournament')),
                  React.createElement('option', { value: 'society' }, t('society'))
                )
              ),

              React.createElement('div', { style: { marginBottom: '20px' } },
                React.createElement('div', {
                  style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }
                },
                  React.createElement('label', {
                    style: { fontSize: '0.875rem', fontWeight: '500', color: '#374151' }
                  }, `${t('golfers')} (${golfers.length}/4)`),
                  React.createElement('button', {
                    onClick: addGolfer,
                    disabled: golfers.length >= 4,
                    style: {
                      padding: '6px 12px',
                      backgroundColor: golfers.length >= 4 ? '#d1d5db' : '#3b82f6',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      fontSize: '0.8rem',
                      cursor: golfers.length >= 4 ? 'not-allowed' : 'pointer'
                    }
                  }, `+ ${t('addGolfer')}`)
                ),
                
                ...golfers.map((golfer, index) =>
                  React.createElement('div', {
                    key: golfer.id,
                    style: { 
                      display: 'grid', 
                      gridTemplateColumns: '1fr 100px 40px', 
                      gap: '8px', 
                      marginBottom: '8px',
                      alignItems: 'center'
                    }
                  },
                    React.createElement(MultiLangInput, {
                      value: golfer.name,
                      onChange: (value) => updateGolfer(index, 'name', value),
                      placeholder: `Golfer Name ${index + 1}`,
                      inputLang: golfer.inputLang || language,
                      onLangChange: (lang) => {
                        const newGolfers = [...golfers];
                        newGolfers[index].inputLang = lang;
                        setGolfers(newGolfers);
                      },
                      modalLanguage: language
                    }),
                    React.createElement('input', {
                      type: 'number',
                      placeholder: 'HCP',
                      value: golfer.handicap || '',
                      onChange: (e) => updateGolfer(index, 'handicap', e.target.value),
                      style: {
                        padding: '8px 12px',
                        border: '2px solid #d1d5db',
                        borderRadius: '6px',
                        fontSize: '0.875rem'
                      }
                    }),
                    React.createElement('button', {
                      onClick: () => removeGolfer(index),
                      disabled: golfers.length <= 1,
                      style: {
                        padding: '8px',
                        backgroundColor: golfers.length <= 1 ? '#d1d5db' : '#ef4444',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: golfers.length <= 1 ? 'not-allowed' : 'pointer'
                      }
                    }, '-')
                  )
                )
              ),

              React.createElement('div', { style: { marginBottom: '20px' } },
                React.createElement('label', {
                  style: { display: 'block', marginBottom: '8px', fontSize: '0.875rem', fontWeight: '500', color: '#374151' }
                }, t('notes')),
                React.createElement(MultiLangInput, {
                  type: 'textarea',
                  rows: 3,
                  value: notes,
                  onChange: setNotes,
                  inputLang: notesInputLang,
                  onLangChange: setNotesInputLang,
                  placeholder: 'Booking notes (optional)',
                  maxLength: 500,
                  modalLanguage: language
                }),
                React.createElement('div', { 
                  style: { 
                    fontSize: '0.7rem', 
                    color: '#6b7280', 
                    marginTop: '4px',
                    textAlign: 'right'
                  }
                }, `${notes.length}/500 ${notes ? `â€¢ ${detectLanguage(notes)} detected` : ''}`)
              ),

              React.createElement('div', {
                style: { display: 'flex', gap: '12px', justifyContent: 'flex-end' }
              },
                React.createElement('button', {
                  onClick: onClose,
                  style: {
                    padding: '10px 20px',
                    border: '2px solid #d1d5db',
                    borderRadius: '8px',
                    background: 'white',
                    cursor: 'pointer',
                    fontSize: '0.875rem',
                    fontWeight: '500'
                  }
                }, t('cancel')),
                isEditing && React.createElement('button', {
                  onClick: () => {
                    const confirmMessage = language === 'th' 
                      ? 'à¸„à¸¸à¸“à¹à¸™à¹ˆà¹ƒà¸ˆà¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆà¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¸à¸²à¸£à¸ˆà¸­à¸‡à¸™à¸µà¹‰?'
                      : language === 'ko'
                      ? 'ì´ ì˜ˆì•½ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?'
                      : t('confirmDeleteBooking');
                    
                    if (confirm(confirmMessage)) {
                      onSaveBooking(slot, { ...slot.booking, status: 'cancelled' });
                      onClose();
                    }
                  },
                  style: {
                    padding: '10px 20px',
                    border: 'none',
                    borderRadius: '8px',
                    background: '#ef4444',
                    color: 'white',
                    cursor: 'pointer',
                    fontSize: '0.875rem',
                    fontWeight: '500'
                  }
                }, t('deleteBooking')),
                React.createElement('button', {
                  onClick: handleSave,
                  disabled: golfers.filter(g => g.name.trim()).length === 0,
                  style: {
                    padding: '10px 20px',
                    border: 'none',
                    borderRadius: '8px',
                    background: golfers.filter(g => g.name.trim()).length === 0 ? '#d1d5db' : '#3b82f6',
                    color: 'white',
                    cursor: golfers.filter(g => g.name.trim()).length === 0 ? 'not-allowed' : 'pointer',
                    fontSize: '0.875rem',
                    fontWeight: '500'
                  }
                }, isEditing ? t('updateBooking') : t('saveBooking'))
              )
            )
          );
        };

        const TeeSheet = (props) => {
          const { 
            date, lanes, rows, filters, totalTees = 4, matches = 0,
            onSelectSlot, onRangeChange, onRefresh, onFindNext, onClearDay, onMoveBooking, onLanguageChange, onToggleLock 
          } = props;
          
          const { t, language, setLanguage } = useI18n();
          const [localFilters, setLocalFilters] = useState(filters || {});
          const [dragOverSlot, setDragOverSlot] = useState(null);
          const [searchResults, setSearchResults] = useState([]);
          const [currentSearchIndex, setCurrentSearchIndex] = useState(0);
          const [highlightedSlot, setHighlightedSlot] = useState(null);
          const [searchInputLang, setSearchInputLang] = useState(language);

          useEffect(() => {
            if (onLanguageChange) {
              onLanguageChange(language);
            }
          }, [language, onLanguageChange]);

          useEffect(() => {
            setSearchInputLang(language);
          }, [language]);

          const timeSlots = useMemo(() => {
            const intervalMinutes = parseInt(localFilters.interval?.replace(/\D/g, '') || '10');
            return buildTimes(
              localFilters.startTime || '08:00', 
              localFilters.endTime || '12:00', 
              intervalMinutes
            );
          }, [localFilters.startTime, localFilters.endTime, localFilters.interval]);

          const headerCols = useMemo(() => {
            const cols = [];
            
            const complexText = localFilters.complex || '36 holes (A/B/C/D)';
            let activeCourses = [];
            
            if (complexText.includes('(A/B/C/D)')) {
              activeCourses = ['A', 'B', 'C', 'D'];
            } else if (complexText.includes('(A/B/C)')) {
              activeCourses = ['A', 'B', 'C'];
            } else if (complexText.includes('(A/B)')) {
              activeCourses = ['A', 'B'];
            } else {
              activeCourses = ['A', 'B', 'C', 'D'];
            }

            const activeLanes = lanes.filter(lane => {
              const courseLetters = lane.label.match(/Course ([A-D])/);
              return courseLetters && activeCourses.includes(courseLetters[1]);
            });

            activeLanes.forEach((lane, laneIndex) => {
              let label = lane.label;
              if (language === 'th' && lane.labelTh) {
                label = lane.labelTh;
              } else if (language === 'ko' && lane.labelKo) {
                label = lane.labelKo;
              } else if (lane.labelEn) {
                label = lane.labelEn;
              }

              const teesCount = localFilters.teesPerCourse || 2;
              
              for (let i = 1; i <= teesCount; i++) {
                let nine;
                if (teesCount === 1) {
                  // For single tee, alternate by course
                  nine = laneIndex % 2 === 0 ? 'front' : 'back';
                } else {
                  // For multiple tees, first half are front, second half are back
                  nine = i <= Math.ceil(teesCount / 2) ? 'front' : 'back';
                }
                
                cols.push({ 
                  key: `${lane.courseId}-${i}`, 
                  label: `${label.replace('Course ', '')}${teesCount > 1 ? `-${i}` : ''}`,
                  color: lane.color || '#e5e7eb',
                  nine,
                  courseId: lane.courseId
                });
              }
            });
            return cols;
          }, [lanes, language, localFilters.teesPerCourse, localFilters.complex]);

          useEffect(() => {
            if (filters && JSON.stringify(filters) !== JSON.stringify(localFilters)) {
              setLocalFilters(filters);
            }
          }, [filters]);

          const updateFilters = (newFilters) => {
            const updatedFilters = { ...localFilters, ...newFilters };
            setLocalFilters(updatedFilters);
            
            if (onRangeChange && (newFilters.startTime || newFilters.endTime)) {
              onRangeChange(
                updatedFilters.startTime || '08:00',
                updatedFilters.endTime || '12:00'
              );
            }
          };

          const enhancedRows = useMemo(() => {
            return timeSlots.map(time => {
              const existingRow = rows.find(r => r.time === time);
              return {
                time,
                slots: headerCols.map(col => {
                  const slotId = `${time}-${col.key}`;
                  const existingSlot = existingRow?.slots.find(s => s.id === slotId);
                  return existingSlot || {
                    id: slotId,
                    courseId: col.key.split('-')[0],
                    time,
                    players: 0,
                    capacity: 4
                  };
                })
              };
            });
          }, [timeSlots, rows, headerCols]);

          const performSearch = () => {

            const searchTerm = localFilters.golferName?.trim().toLowerCase();
            if (!searchTerm) {
              setSearchResults([]);
              setHighlightedSlot(null);
              return;
            }

            const results = [];
            
            enhancedRows.forEach(row => {
              row.slots.forEach(slot => {
                if (slot.booking) {
                  const golferMatch = slot.booking.golfers.some(golfer => 
                    golfer.name.toLowerCase().includes(searchTerm)
                  );
                  
                  const caddyMatch = slot.booking.caddyBookings?.some(caddyBooking => {
                    const caddyNumber = caddyBooking.caddyNumber || '000';
                    const caddyName = caddyBooking.caddyName.toLowerCase();
                    return caddyNumber.includes(searchTerm.replace('#', '')) || 
                           caddyName.includes(searchTerm);
                  });

                  if (golferMatch || caddyMatch) {
                    let matchInfo = '';
                    if (golferMatch) {
                      const matchedGolfer = slot.booking.golfers.find(g => 
                        g.name.toLowerCase().includes(searchTerm)
                      );
                      matchInfo = `Golfer: ${matchedGolfer?.name}`;
                    }
                    if (caddyMatch) {
                      const matchedCaddy = slot.booking.caddyBookings?.find(cb => {
                        const caddyNumber = cb.caddyNumber || '000';
                        return caddyNumber.includes(searchTerm.replace('#', '')) || 
                               cb.caddyName.toLowerCase().includes(searchTerm);
                      });
                      matchInfo += matchInfo ? ` | Caddy: #${matchedCaddy?.caddyNumber} ${matchedCaddy?.caddyName}` 
                                           : `Caddy: #${matchedCaddy?.caddyNumber} ${matchedCaddy?.caddyName}`;
                    }
                    
                    results.push({
                      slotId: slot.id,
                      time: slot.time,
                      info: matchInfo
                    });
                  }
                }
              });
            });

            setSearchResults(results);
            setCurrentSearchIndex(0);
            
            if (results.length > 0) {
              jumpToSlot(results[0].slotId);
            }
          }
            // expose search for Enter key in inputs
            try { window.__performSearch = performSearch; } catch (e) {}
;

          const jumpToNext = () => {
            if (searchResults.length === 0) return;
            
            const nextIndex = (currentSearchIndex + 1) % searchResults.length;
            setCurrentSearchIndex(nextIndex);
            jumpToSlot(searchResults[nextIndex].slotId);
          };

          const jumpToSlot = (slotId) => {
            setHighlightedSlot(slotId);
            
            const element = document.querySelector(`[data-slot-id="${slotId}"]`);
            if (element) {
              element.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center',
                inline: 'center'
              });
            }
            
            setTimeout(() => {
              setHighlightedSlot(null);
            }, 3000);
          };

          return React.createElement('div', {
            style: { 
              fontFamily: 'system-ui, sans-serif', 
              padding: '8px',
              backgroundColor: '#f8fafc',
              minHeight: '100vh',
              width: '100%',
              boxSizing: 'border-box',
              overflow: 'hidden'
            }
          },
            React.createElement('div', {
              style: { 
                backgroundColor: 'white',
                borderRadius: '6px',
                padding: '8px',
                marginBottom: '8px',
                border: '1px solid #e5e7eb',
                boxShadow: '0 1px 2px rgba(0,0,0,0.05)',
                width: '100%',
                boxSizing: 'border-box'
              }
            },
              React.createElement('div', {
                style: {
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '8px',
                  fontSize: '0.8rem'
                }
              },
                React.createElement('div', {
                  style: { display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '10px' }
                },
                  React.createElement('label', {
                    style: { fontWeight: '500', color: '#374151', minWidth: '70px' }
                  }, t('golferName')),
                  React.createElement('div', {
                    style: { flex: '1', minWidth: '220px', maxWidth: '420px' }
                  },
                    React.createElement(MultiLangInput, {
                      type: 'search',
                      value: localFilters.golferName || '',
                      onChange: (value) => setLocalFilters({...localFilters, golferName: value}),
                      placeholder: 'Search golfer name or caddy number',
                      inputLang: searchInputLang,
                      onLangChange: setSearchInputLang,
                      modalLanguage: language
                    })
                  ),
                  React.createElement('button', {
                    onClick: performSearch,
                    style: {
                      padding: '6px 12px',
                      backgroundColor: '#3b82f6',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      fontSize: '0.75rem',
                      cursor: 'pointer',
                      fontWeight: '500'
                    }
                  }, t('find')),
                  React.createElement('button', {
                    onClick: jumpToNext,
                    disabled: searchResults.length === 0,
                    style: {
                      padding: '6px 12px',
                      backgroundColor: searchResults.length === 0 ? '#d1d5db' : '#6b7280',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      fontSize: '0.75rem',
                      cursor: searchResults.length === 0 ? 'not-allowed' : 'pointer',
                      fontWeight: '500'
                    }
                  }, t('next')),
                  React.createElement('span', {
                    style: { 
                      color: '#6b7280',
                      fontSize: '0.7rem',
                      minWidth: '70px'
                    }
                  }, searchResults.length > 0 
                    ? `${currentSearchIndex + 1}/${searchResults.length} ${t('matches')}`
                    : `${t('matches')}: 0`
                  )
                ),

                React.createElement('div', {
                  style: { display: 'flex', flexWrap: 'wrap', gap: '8px', alignItems: 'center', justifyContent: 'space-between' }
                },
                  React.createElement('div', {
                    style: { display: 'flex', flexWrap: 'wrap', gap: '8px', alignItems: 'center' }
                  },
                    ...lanes.map((lane, idx) =>
                      React.createElement('div', {
                        key: lane.courseId,
                        style: { display: 'flex', alignItems: 'center', gap: '3px' }
                      },
                        React.createElement('div', {
                          style: {
                            width: '8px',
                            height: '8px',
                            borderRadius: '2px',
                            backgroundColor: lane.color || ['#86efac', '#7dd3fc', '#fde047', '#c4b5fd'][idx]
                          }
                        }),
                        React.createElement('span', {
                          style: { fontSize: '0.7rem', color: '#6b7280' }
                        }, `${t('course')} ${lane.label.replace('Course ', '')}`)
                      )
                    )
                  ),
                  
                  React.createElement('div', {
                    style: { display: 'flex', gap: '8px', alignItems: 'center' }
                  },
                    React.createElement('select', {
                      value: language,
                      onChange: (e) => setLanguage(e.target.value),
                      style: {
                        padding: '4px 8px',
                        border: '1px solid #d1d5db',
                        borderRadius: '4px',
                        fontSize: '0.7rem',
                        backgroundColor: 'white',
                        fontWeight: '500'
                      }
                    },
                      React.createElement('option', { value: 'en' }, 'ðŸ‡ºðŸ‡¸ English'),
                      React.createElement('option', { value: 'th' }, 'ðŸ‡¹ðŸ‡­ à¹„à¸—à¸¢'),
                      React.createElement('option', { value: 'ko' }, 'ðŸ‡°ðŸ‡· í•œêµ­ì–´'),
                      React.createElement('option', { value: 'ja' }, 'ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž')
                    ),
                    
                    React.createElement('button', {
                      onClick: () => {
                        if (confirm(`âš ï¸ ${t('confirmDeleteBooking')?.replace('booking', 'ALL BOOKINGS FOR THE DAY')} This action cannot be undone!`)) {
                          if (confirm('ðŸš¨ FINAL WARNING: You are about to delete ALL bookings for the entire day. Are you absolutely sure?')) {
                            onClearDay && onClearDay();
                          }
                        }
                      },
                      style: {
                        padding: '6px 10px',
                        backgroundColor: '#dc2626',
                        color: 'white',
                        border: '1px solid #991b1b',
                        borderRadius: '4px',
                        fontSize: '0.7rem',
                        cursor: 'pointer',
                        fontWeight: '600',
                        whiteSpace: 'nowrap'
                      }
                    }, `ðŸ—‘ï¸ ${t('clearDay')}`)
                  )
                )
              ),

              React.createElement('div', {
                style: { 
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '8px',
                  marginTop: '8px',
                  paddingTop: '8px',
                  borderTop: '1px solid #e5e7eb'
                }
              },
                React.createElement('div', {
                  style: {
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))',
                    gap: '12px'
                  }
                },
                  React.createElement('div', null,
                    React.createElement('label', {
                      style: { display: 'block', marginBottom: '4px', fontSize: '0.75rem', fontWeight: '500', color: '#374151' }
                    }, t('complex')),
                    React.createElement('select', {
                      value: localFilters.complex || '36 holes (A/B/C/D)',
                      onChange: (e) => updateFilters({complex: e.target.value}),
                      style: {
                        width: '100%',
                        padding: '6px 8px',
                        border: '1px solid #d1d5db',
                        borderRadius: '4px',
                        fontSize: '0.75rem'
                      }
                    },
                      React.createElement('option', null, '36 holes (A/B/C/D)'),
                      React.createElement('option', null, '18 holes (A/B)'),
                      React.createElement('option', null, '27 holes (A/B/C)')
                    )
                  ),

                  React.createElement('div', null,
                    React.createElement('label', {
                      style: { display: 'block', marginBottom: '4px', fontSize: '0.75rem', fontWeight: '500', color: '#374151' }
                    }, t('date')),
                    React.createElement('input', {
                      type: 'date',
                      value: localFilters.date || date,
                      onChange: (e) => updateFilters({date: e.target.value}),
                      style: {
                        width: '100%',
                        padding: '6px 8px',
                        border: '1px solid #d1d5db',
                        borderRadius: '4px',
                        fontSize: '0.75rem'
                      }
                    })
                  ),

                  React.createElement('div', null,
                    React.createElement('label', {
                      style: { display: 'block', marginBottom: '4px', fontSize: '0.75rem', fontWeight: '500', color: '#374151' }
                    }, t('totalTees')),
                    React.createElement('div', {
                      style: { 
                        padding: '6px 8px',
                        backgroundColor: '#f3f4f6',
                        borderRadius: '4px',
                        fontSize: '0.75rem',
                        fontWeight: '500',
                        color: '#374151',
                        border: '1px solid #e5e7eb'
                      }
                    }, totalTees)
                  )
                ),
                
                React.createElement('div', {
                  style: {
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))',
                    gap: '12px'
                  }
                },
                  React.createElement('div', null,
                    React.createElement('label', {
                      style: { display: 'block', marginBottom: '4px', fontSize: '0.75rem', fontWeight: '500', color: '#374151' }
                    }, `${t('start')} / ${t('end')}`),
                    React.createElement('div', {
                      style: { display: 'flex', gap: '6px' }
                    },
                      React.createElement('input', {
                        type: 'time',
                        value: localFilters.startTime || '08:00',
                        onChange: (e) => updateFilters({startTime: e.target.value}),
                        style: {
                          flex: 1,
                          padding: '6px 8px',
                          border: '1px solid #d1d5db',
                          borderRadius: '4px',
                          fontSize: '0.75rem'
                        }
                      }),
                      React.createElement('input', {
                        type: 'time',
                        value: localFilters.endTime || '12:00',
                        onChange: (e) => updateFilters({endTime: e.target.value}),
                        style: {
                          flex: 1,
                          padding: '6px 8px',
                          border: '1px solid #d1d5db',
                          borderRadius: '4px',
                          fontSize: '0.75rem'
                        }
                      })
                    )
                  ),

                  React.createElement('div', null,
                    React.createElement('label', {
                      style: { display: 'block', marginBottom: '4px', fontSize: '0.75rem', fontWeight: '500', color: '#374151' }
                    }, `${t('interval')} / ${t('teesPerCourse')}`),
                    React.createElement('div', {
                      style: { display: 'flex', gap: '6px' }
                    },
                      React.createElement('select', {
                        value: localFilters.interval || '10 min',
                        onChange: (e) => updateFilters({interval: e.target.value}),
                        style: {
                          flex: 1,
                          padding: '6px 8px',
                          border: '1px solid #d1d5db',
                          borderRadius: '4px',
                          fontSize: '0.75rem'
                        }
                      },
                        React.createElement('option', null, '5 min'),
                        React.createElement('option', null, '10 min'),
                        React.createElement('option', null, '15 min')
                      ),
                      React.createElement('select', {
                        value: localFilters.teesPerCourse || 2,
                        onChange: (e) => updateFilters({teesPerCourse: parseInt(e.target.value)}),
                        style: {
                          flex: 1,
                          padding: '6px 8px',
                          border: '1px solid #d1d5db',
                          borderRadius: '4px',
                          fontSize: '0.75rem'
                        }
                      },
                        React.createElement('option', { value: 1 }, '1'),
                        React.createElement('option', { value: 2 }, '2'),
                        React.createElement('option', { value: 3 }, '3'),
                        React.createElement('option', { value: 4 }, '4')
                      )
                    )
                  )
                )
              )
            ),

            React.createElement('div', {
              style: {
                backgroundColor: 'white',
                borderRadius: '8px',
                border: '1px solid #e5e7eb',
                boxShadow: '0 4px 6px rgba(0,0,0,0.05)',
                width: '100%',
                boxSizing: 'border-box'
              }
            },
              React.createElement('div', {
                style: {
                  width: '100%',
                  overflow: 'auto',
                  maxHeight: '70vh'
                }
              },
                React.createElement('table', {
                  style: { 
                    width: '100%', 
                    borderCollapse: 'collapse',
                    fontSize: '0.8rem',
                    minWidth: '800px'
                  }
                },
                  React.createElement('thead', null,
                    React.createElement('tr', null,
                      React.createElement('th', {
                        style: { 
                          padding: '10px 6px',
                          border: '1px solid #e5e7eb',
                          backgroundColor: '#f9fafb',
                          fontSize: '0.7rem',
                          color: '#6b7280',
                          minWidth: '60px',
                          position: 'sticky',
                          left: 0,
                          zIndex: 10
                        }
                      }),
                      ...headerCols.map((col, colIndex) => {
                        const needsDivider = colIndex > 0 && 
                          headerCols[colIndex - 1].nine !== col.nine;
                        
                        return React.createElement('th', {
                          key: col.key,
                          style: { 
                            padding: '6px 4px',
                            border: '1px solid #e5e7eb',
                            backgroundColor: col.color,
                            fontSize: '0.7rem',
                            fontWeight: '600',
                            textAlign: 'center',
                            minWidth: '100px',
                            color: '#1f2937',
                            borderLeft: needsDivider ? `3px solid ${col.color}` : '1px solid #e5e7eb',
                            position: 'relative'
                          }
                        },
                          needsDivider && React.createElement('div', {
                            style: {
                              position: 'absolute',
                              left: '-2px',
                              top: '0',
                              bottom: '0',
                              width: '2px',
                              backgroundColor: col.color,
                              filter: 'brightness(0.7)',
                              zIndex: 1
                            }
                          }),
                          col.label,
                          needsDivider && React.createElement('div', {
                            style: {
                              position: 'absolute',
                              left: '-1px',
                              top: '-1px',
                              fontSize: '0.6rem',
                              color: '#374151',
                              fontWeight: '700',
                              backgroundColor: 'rgba(255,255,255,0.9)',
                              padding: '1px 3px',
                              borderRadius: '2px',
                              transform: 'rotate(-90deg)',
                              transformOrigin: 'left bottom',
                              whiteSpace: 'nowrap'
                            }
                          }, col.nine === 'back' ? (language === 'th' ? 'à¸«à¸¥à¸±à¸‡ 9' : language === 'ko' ? 'ë°±ë‚˜ì¸' : 'Back 9') : '')
                        );
                      })
                    ),
                    React.createElement('tr', null,
                      React.createElement('th', {
                        style: { 
                          padding: '6px',
                          border: '1px solid #e5e7eb',
                          backgroundColor: '#f9fafb',
                          fontSize: '0.7rem',
                          fontWeight: '600',
                          position: 'sticky',
                          left: 0,
                          zIndex: 10
                        }
                      }, t('time')),
                      ...headerCols.map((col, colIndex) => {
                        const needsDivider = colIndex > 0 && 
                          headerCols[colIndex - 1].nine !== col.nine;
                        
                        return React.createElement('th', {
                          key: `${col.key}-sub`,
                          style: { 
                            padding: '3px',
                            border: '1px solid #e5e7eb',
                            backgroundColor: '#f9fafb',
                            fontSize: '0.65rem',
                            color: '#6b7280',
                            borderLeft: needsDivider ? `3px solid ${col.color}` : '1px solid #e5e7eb',
                            position: 'relative'
                          }
                        },
                          needsDivider && React.createElement('div', {
                            style: {
                              position: 'absolute',
                              left: '-2px',
                              top: '0',
                              bottom: '0',
                              width: '2px',
                              backgroundColor: col.color,
                              filter: 'brightness(0.7)',
                              zIndex: 1
                            }
                          }),
                          col.key
                        );
                      })
                    )
                  ),
                  React.createElement('tbody', null,
                    ...enhancedRows.map((row, timeIdx) =>
                      React.createElement('tr', { key: row.time },
                        React.createElement('td', {
                          style: { 
                            padding: '6px',
                            border: '1px solid #e5e7eb',
                            backgroundColor: '#f9fafb',
                            fontWeight: '600',
                            fontSize: '0.7rem',
                            textAlign: 'center',
                            position: 'sticky',
                            left: 0,
                            zIndex: 5
                          }
                        }, row.time),
                        ...row.slots.map((slot, colIdx) => {
                          const hasBooking = !!slot.booking;
                          const isDropTarget = dragOverSlot === slot.id;
                          
                          const needsDivider = colIdx > 0 && 
                            headerCols[colIdx - 1]?.nine !== headerCols[colIdx]?.nine;
                          const currentCol = headerCols[colIdx];
                          
                          return React.createElement('td', {
                            key: slot.id,
                            style: { 
                              padding: '1px',
                              border: '1px solid #e5e7eb',
                              height: '45px',
                              verticalAlign: 'middle',
                              borderLeft: needsDivider ? `3px solid ${currentCol?.color}` : '1px solid #e5e7eb',
                              position: 'relative'
                            }
                          },
                            needsDivider && React.createElement('div', {
                              style: {
                                position: 'absolute',
                                left: '-2px',
                                top: '0',
                                bottom: '0',
                                width: '2px',
                                backgroundColor: currentCol?.color,
                                filter: 'brightness(0.7)',
                                zIndex: 1
                              }
                            }),
                            React.createElement('div', {
                              'data-slot-id': slot.id,
                              style: {
                                width: '100%',
                                height: '100%',
                                backgroundColor: slot.locked ? '#fef2f2' : 
                                               isDropTarget ? '#dbeafe' : 
                                               highlightedSlot === slot.id ? '#fef3c7' :
                                               hasBooking ? '#eff6ff' : 'white',
                                border: isDropTarget ? '2px dashed #3b82f6' : 
                                       highlightedSlot === slot.id ? '3px solid #f59e0b' :
                                       slot.locked ? '2px solid #ef4444' :
                                       '1px solid transparent',
                                borderRadius: '4px',
                                padding: '2px',
                                cursor: slot.locked ? 'not-allowed' : hasBooking ? 'grab' : 'pointer',
                                display: 'flex',
                                flexDirection: 'column',
                                justifyContent: 'center',
                                position: 'relative',
                                overflow: 'hidden',
                                boxShadow: highlightedSlot === slot.id ? '0 0 8px rgba(245, 158, 11, 0.6)' : 
                                         hasBooking ? '0 1px 2px rgba(0,0,0,0.1)' : 'none',
                                transition: 'all 0.3s ease',
                                minHeight: '40px'
                              },
                              draggable: (!!slot.booking && !slot.locked),
                              onDragStart: (e) => {
                                if (!slot.booking || slot.locked) return;
                                try {
                                  e.dataTransfer.setData('text/plain', slot.id);
                                  e.dataTransfer.effectAllowed = 'move';
                                } catch(_) {}
                              },
                              onDragOver: (e) => {
                                if (slot.locked) return;
                                e.preventDefault();
                                if (setDragOverSlot) setDragOverSlot(slot.id);
                              },
                              onDragLeave: () => {
                                if (dragOverSlot === slot.id && setDragOverSlot) setDragOverSlot(null);
                              },
                              onDrop: (e) => {
                                if (slot.locked) return;
                                e.preventDefault();
                                const fromId = (e.dataTransfer && e.dataTransfer.getData) ? e.dataTransfer.getData('text/plain') : null;
                                if (fromId && fromId !== slot.id) {
                                  if (onMoveBooking) onMoveBooking(fromId, slot.id);
                                }
                                if (setDragOverSlot) setDragOverSlot(null);
                              },
    
                              onClick: (e) => {
                                if (e.ctrlKey || e.metaKey) {
                                  e.preventDefault();
                                  if (onToggleLock) {
                                    onToggleLock(slot);
                                  }
                                } else if (!slot.locked && onSelectSlot) {
                                  onSelectSlot(slot);
                                }
                              },
                              onContextMenu: (e) => {
                                e.preventDefault();
                                if (onToggleLock) {
                                  onToggleLock(slot);
                                }
                              },
                              title: slot.locked 
                                ? "ðŸ”’ LOCKED - Right-click or Ctrl+click to UNLOCK" 
                                : "ðŸ”“ UNLOCKED - Right-click or Ctrl+click to LOCK this slot"
                            },
                              hasBooking && slot.booking && React.createElement('div', {
                                style: { width: '100%' }
                              },
                                React.createElement('div', {
                                  style: {
                                    fontSize: '0.6rem',
                                    fontWeight: '600',
                                    color: 'white',
                                    backgroundColor: getBookingTypeColor(slot.booking.bookingType),
                                    padding: '1px 4px',
                                    borderRadius: '3px',
                                    marginBottom: '2px',
                                    textAlign: 'center'
                                  }
                                }, t(slot.booking.bookingType).toUpperCase()),
                                
                                ...slot.booking.golfers.slice(0, 2).map((golfer, idx) => {
                                  const caddyBooking = slot.booking.caddyBookings?.find(cb => cb.golferId === golfer.id);
                                  return React.createElement('div', {
                                    key: golfer.id,
                                    style: {
                                      fontSize: '0.65rem',
                                      lineHeight: '1.1',
                                      color: '#1f2937',
                                      fontWeight: '500',
                                      whiteSpace: 'nowrap',
                                      overflow: 'hidden',
                                      textOverflow: 'ellipsis',
                                      marginBottom: '1px',
                                      fontFamily: golfer.inputLang === 'th' ? 'system-ui, "Noto Sans Thai", sans-serif' :
                                                  golfer.inputLang === 'ko' ? 'system-ui, "Noto Sans KR", sans-serif' :
                                                  'system-ui, sans-serif'
                                    }
                                  },
                                    React.createElement('div', null, `${golfer.name} ${golfer.handicap ? `(${golfer.handicap})` : ''}`),
                                    caddyBooking && React.createElement('div', {
                                      style: {
                                        fontSize: '0.55rem',
                                        color: caddyBooking.isWaitlisted ? '#d97706' : '#059669',
                                        fontStyle: 'italic'
                                      }
                                    }, `${caddyBooking.isWaitlisted ? 'ðŸ“‹' : 'â†—'} #${caddyBooking.caddyNumber || '000'} ${caddyBooking.caddyName}${caddyBooking.isWaitlisted ? React.createElement('span', { style: { fontSize: '0.5rem' } }, ' (waitlist)') : ''}`)
                                  );
                                }),
                                
                                slot.booking.golfers.length > 2 && React.createElement('div', {
                                  style: {
                                    fontSize: '0.6rem',
                                    color: '#6b7280',
                                    fontWeight: '500'
                                  }
                                }, `+${slot.booking.golfers.length - 2} more`),
                                
                                slot.booking.notes && React.createElement('div', {
                                  style: {
                                    fontSize: '0.55rem',
                                    color: '#8b5cf6',
                                    fontStyle: 'italic',
                                    marginTop: '1px',
                                    fontFamily: slot.booking.notesLang === 'th' ? 'system-ui, "Noto Sans Thai", sans-serif' :
                                                slot.booking.notesLang === 'ko' ? 'system-ui, "Noto Sans KR", sans-serif' :
                                                'system-ui, sans-serif'
                                  }
                                }, `${slot.booking.notes.slice(0, 15)}${slot.booking.notes.length > 15 ? '...' : ''}`)
                              ),
                              
                              slot.locked && React.createElement('div', {
                                style: {
                                  fontSize: '0.6rem',
                                  color: '#ef4444',
                                  fontWeight: '700',
                                  textAlign: 'center',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  height: '100%'
                                }
                              }, 'ðŸ”’ LOCKED'),
                              
                              !hasBooking && !slot.locked && isDropTarget && React.createElement('div', {
                                style: {
                                  fontSize: '0.6rem',
                                  color: '#3b82f6',
                                  textAlign: 'center',
                                  fontWeight: '500'
                                }
                              }, 'Drop here')
                            )
                          );
                        })
                      )
                    )
                  )
                )
              )
            )
          );
        };

        // Demo Data
        const demoLanes = [
          { 
            courseId: "course-a", 
            label: "Course A", 
            labelEn: "Course A",
            labelTh: "à¸ªà¸™à¸²à¸¡ à¹€à¸­",
            labelKo: "ì½”ìŠ¤ A",
            color: "#86efac" 
          },
          { 
            courseId: "course-b", 
            label: "Course B", 
            labelEn: "Course B",
            labelTh: "à¸ªà¸™à¸²à¸¡ à¸šà¸µ",
            labelKo: "ì½”ìŠ¤ B",
            color: "#7dd3fc" 
          }, 
          { 
            courseId: "course-c", 
            label: "Course C", 
            labelEn: "Course C",
            labelTh: "à¸ªà¸™à¸²à¸¡ à¸‹à¸µ",
            labelKo: "ì½”ìŠ¤ C",
            color: "#fde047" 
          },
          { 
            courseId: "course-d", 
            label: "Course D", 
            labelEn: "Course D",
            labelTh: "à¸ªà¸™à¸²à¸¡ à¸”à¸µ",
            labelKo: "ì½”ìŠ¤ D",
            color: "#c4b5fd" 
          }
        ];

        const demoCaddies = [
          { id: 'c001', number: '001', name: 'Somchai', nameEn: 'Somchai', nameTh: 'à¸ªà¸¡à¸Šà¸²à¸¢', nameKo: 'ì†œì°¨ì´', rating: 4.8, languages: ['Thai', 'English'], status: 'available' },
          { id: 'c003', number: '003', name: 'Niran', nameEn: 'Niran', nameTh: 'à¸™à¸´à¸£à¸±à¸™à¸”à¸£à¹Œ', nameKo: 'ë‹ˆëž€', rating: 4.6, languages: ['Thai', 'English', 'Japanese'], status: 'available' },
          { id: 'c007', number: '007', name: 'Mali', nameEn: 'Mali', nameTh: 'à¸¡à¸²à¸¥à¸µ', nameKo: 'ë§ë¦¬', rating: 4.9, languages: ['Thai', 'English'], status: 'available' },
          { id: 'c012', number: '012', name: 'Porn', nameEn: 'Porn', nameTh: 'à¸žà¸£', nameKo: 'í°', rating: 4.7, languages: ['Thai', 'Korean'], status: 'available' },
          { id: 'c015', number: '015', name: 'Lek', nameEn: 'Lek', nameTh: 'à¹€à¸¥à¹‡à¸', nameKo: 'ë ‰', rating: 4.8, languages: ['Thai', 'Korean', 'English'], status: 'available' },
          { id: 'c023', number: '023', name: 'Malee', nameEn: 'Malee', nameTh: 'à¸¡à¸²à¸¥à¸µ', nameKo: 'ë§ë¦¬', rating: 4.5, languages: ['Thai', 'English'], status: 'available' },
          { id: 'c031', number: '031', name: 'Jin', nameEn: 'Jin', nameTh: 'à¸ˆà¸´à¸™', nameKo: 'ì§„', rating: 4.4, languages: ['Thai', 'Korean'], status: 'booked' },
          { id: 'c042', number: '042', name: 'Noi', nameEn: 'Noi', nameTh: 'à¸™à¹‰à¸­à¸¢', nameKo: 'ë…¸ì´', rating: 4.9, languages: ['Thai', 'English', 'Chinese'], status: 'on-course' },
          { id: 'c056', number: '056', name: 'Benz', nameEn: 'Benz', nameTh: 'à¹€à¸šà¸™à¸‹à¹Œ', nameKo: 'ë²¤ì¸ ', rating: 4.3, languages: ['Thai', 'English'], status: 'on-break' },
          { id: 'c067', number: '067', name: 'Oy', nameEn: 'Oy', nameTh: 'à¸­à¹‰à¸­à¸¢', nameKo: 'ì˜¤ì´', rating: 4.6, languages: ['Thai', 'Japanese'], status: 'available' }
        ];

        const sampleBookings = [
          {
            id: 'booking-1',
            golfers: [
              { id: 'g1', name: 'John Smith', handicap: 8, inputLang: 'en' },
              { id: 'g2', name: 'Mike Johnson', handicap: 12, inputLang: 'en' }
            ],
            notes: 'VIP members, prefer Course A',
            notesLang: 'en',
            bookingType: 'vip',
            status: 'confirmed',
            caddyBookings: [
              { golferId: 'g1', caddyId: 'c001', golferName: 'John Smith', caddyName: 'Somchai', caddyNumber: '001', status: 'confirmed' },
              { golferId: 'g2', caddyId: 'c007', golferName: 'Mike Johnson', caddyName: 'Mali', caddyNumber: '007', status: 'confirmed' }
            ]
          },
          {
            id: 'booking-2',
            golfers: [
              { id: 'g3', name: 'ë°•ì§€ì„±', handicap: 15, inputLang: 'ko' },
              { id: 'g4', name: 'ê¹€ë¯¼ìˆ˜', handicap: 6, inputLang: 'ko' },
              { id: 'g5', name: 'à¸ªà¸¡à¸¨à¸±à¸à¸”à¸´à¹Œ', handicap: 20, inputLang: 'th' },
              { id: 'g6', name: 'à¸§à¸´à¸Šà¸²à¸¢', handicap: 10, inputLang: 'th' }
            ],
            notes: 'ê¸°ì—… í† ë„ˆë¨¼íŠ¸ ê·¸ë£¹ / à¸à¸¥à¸¸à¹ˆà¸¡à¸—à¸±à¸§à¸£à¹Œà¸™à¸²à¹€à¸¡à¸™à¸•à¹Œà¸šà¸£à¸´à¸©à¸±à¸—',
            notesLang: 'ko',
            bookingType: 'tournament',
            status: 'confirmed',
            caddyBookings: [
              { golferId: 'g3', caddyId: 'c012', golferName: 'ë°•ì§€ì„±', caddyName: 'Porn', caddyNumber: '012', status: 'confirmed' },
              { golferId: 'g4', caddyId: 'c015', golferName: 'ê¹€ë¯¼ìˆ˜', caddyName: 'Lek', caddyNumber: '015', status: 'confirmed' },
              { golferId: 'g5', caddyId: 'c023', golferName: 'à¸ªà¸¡à¸¨à¸±à¸à¸”à¸´à¹Œ', caddyName: 'Malee', caddyNumber: '023', status: 'confirmed' },
              { golferId: 'g6', caddyId: 'c067', golferName: 'à¸§à¸´à¸Šà¸²à¸¢', caddyName: 'Oy', caddyNumber: '067', status: 'confirmed' }
            ]
          }
        ];

        const TeeSheetDemo = () => {
          const [modalOpen, setModalOpen] = useState(false);
          const [selectedSlot, setSelectedSlot] = useState(null);
          const [demoRows, setDemoRows] = useState([]);
          const [language, setLanguage] = useState('en');
          
          const [filters, setFilters] = useState({
            complex: '36 holes (A/B/C/D)',
            startTime: '08:00',
            endTime: '12:00',
            interval: '10 min',
            teesPerCourse: 2,
            date: new Date().toISOString().split('T')[0]
          });

          const getInstructionText = (lang) => {
            const mciProMode = MciProBridge.isInMciPro;
            const instructions = {
              en: {
                title: mciProMode ? 'MciPro Tee Sheet' : 'Golf Tee Sheet Demo',
                content: `
                  <strong>NEW Multi-Language Features:</strong><br/>
                  â€¢ Each golfer name has individual language setting<br/>
                  â€¢ Notes support multiple languages<br/>
                  â€¢ Caddy search with language-specific names<br/>
                  â€¢ Auto language detection<br/>
                  â€¢ Bulk language controls<br/>
                  <br/>
                  <strong>Interactions:</strong><br/>
                  â€¢ <strong>Left-click</strong>: Book/edit tee times<br/>
                  â€¢ <strong>Right-click or Ctrl+click</strong>: Lock/unlock slots<br/>
                  â€¢ Search supports multilingual content<br/>
                  â€¢ Try different languages (EN/TH/KO)<br/>
                `
              },
              th: {
                title: 'à¸à¸²à¸£à¸ªà¸²à¸˜à¸´à¸•à¸£à¸°à¸šà¸šà¸•à¸²à¸£à¸²à¸‡à¸—à¸µà¸­à¸­à¸Ÿà¸‚à¸±à¹‰à¸™à¸ªà¸¹à¸‡',
                content: `
                  <strong>à¸Ÿà¸µà¹€à¸ˆà¸­à¸£à¹Œà¹ƒà¸«à¸¡à¹ˆà¸«à¸¥à¸²à¸¢à¸ à¸²à¸©à¸²:</strong><br/>
                  â€¢ à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¹à¸•à¹ˆà¸¥à¸°à¸„à¸™à¸¡à¸µà¸à¸²à¸£à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸ à¸²à¸©à¸²à¹à¸¢à¸<br/>
                  â€¢ à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸à¸£à¸­à¸‡à¸£à¸±à¸šà¸«à¸¥à¸²à¸¢à¸ à¸²à¸©à¸²<br/>
                  â€¢ à¸„à¹‰à¸™à¸«à¸²à¹à¸„à¸”à¸”à¸µà¹‰à¸”à¹‰à¸§à¸¢à¸Šà¸·à¹ˆà¸­à¹€à¸‰à¸žà¸²à¸°à¸ à¸²à¸©à¸²<br/>
                  â€¢ à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸ à¸²à¸©à¸²à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´<br/>
                  â€¢ à¸à¸²à¸£à¸„à¸§à¸šà¸„à¸¸à¸¡à¸ à¸²à¸©à¸²à¹à¸šà¸šà¸à¸¥à¸¸à¹ˆà¸¡<br/>
                  <br/>
                  <strong>à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™:</strong><br/>
                  â€¢ <strong>à¸„à¸¥à¸´à¸à¸‹à¹‰à¸²à¸¢</strong>: à¸ˆà¸­à¸‡/à¹à¸à¹‰à¹„à¸‚à¹€à¸§à¸¥à¸²à¹€à¸¥à¹ˆà¸™<br/>
                  â€¢ <strong>à¸„à¸¥à¸´à¸à¸‚à¸§à¸²à¸«à¸£à¸·à¸­ Ctrl+à¸„à¸¥à¸´à¸</strong>: à¸¥à¹‡à¸­à¸„/à¸›à¸¥à¸”à¸¥à¹‡à¸­à¸„à¸Šà¹ˆà¸­à¸‡<br/>
                  â€¢ à¸à¸²à¸£à¸„à¹‰à¸™à¸«à¸²à¸£à¸­à¸‡à¸£à¸±à¸šà¹€à¸™à¸·à¹‰à¸­à¸«à¸²à¸«à¸¥à¸²à¸¢à¸ à¸²à¸©à¸²<br/>
                  â€¢ à¸¥à¸­à¸‡à¹ƒà¸Šà¹‰à¸ à¸²à¸©à¸²à¸•à¹ˆà¸²à¸‡à¹† (à¸­à¸±à¸‡à¸à¸¤à¸©/à¹„à¸—à¸¢/à¹€à¸à¸²à¸«à¸¥à¸µ)<br/>
                `
              },
              ko: {
                title: 'í–¥ìƒëœ ê³¨í”„ í‹° ì‹œíŠ¸ ë°ëª¨',
                content: `
                  <strong>ìƒˆë¡œìš´ ë‹¤êµ­ì–´ ê¸°ëŠ¥:</strong><br/>
                  â€¢ ê° ê³¨í¼ ì´ë¦„ì€ ê°œë³„ ì–¸ì–´ ì„¤ì • ê°€ëŠ¥<br/>
                  â€¢ ë©”ëª¨ëŠ” ì—¬ëŸ¬ ì–¸ì–´ ì§€ì›<br/>
                  â€¢ ì–¸ì–´ë³„ ìºë”” ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰<br/>
                  â€¢ ìžë™ ì–¸ì–´ ê°ì§€<br/>
                  â€¢ ì¼ê´„ ì–¸ì–´ ì œì–´<br/>
                  <br/>
                  <strong>ìƒí˜¸ìž‘ìš©:</strong><br/>
                  â€¢ <strong>ì™¼ìª½ í´ë¦­</strong>: í‹°íƒ€ìž„ ì˜ˆì•½/íŽ¸ì§‘<br/>
                  â€¢ <strong>ì˜¤ë¥¸ìª½ í´ë¦­ ë˜ëŠ” Ctrl+í´ë¦­</strong>: ìŠ¬ë¡¯ ìž ê¸ˆ/í•´ì œ<br/>
                  â€¢ ê²€ìƒ‰ì€ ë‹¤êµ­ì–´ ì½˜í…ì¸  ì§€ì›<br/>
                  â€¢ ë‹¤ì–‘í•œ ì–¸ì–´ ì‹œë„ (ì˜ì–´/íƒœêµ­ì–´/í•œêµ­ì–´)<br/>
                `
              }
            
              ,
              ja: {
                title: 'æ‹¡å¼µã‚´ãƒ«ãƒ• Tã‚·ãƒ¼ãƒˆ ãƒ‡ãƒ¢',
                content: `
                  <strong>å¤šè¨€èªžå¯¾å¿œã®æ–°æ©Ÿèƒ½:</strong><br/>
                  â€¢ å„ã‚´ãƒ«ãƒ•ã‚¡ãƒ¼åã«å€‹åˆ¥ã®å…¥åŠ›è¨€èªžã‚’è¨­å®š<br/>
                  â€¢ ãƒ¡ãƒ¢ã¯è¤‡æ•°è¨€èªžã«å¯¾å¿œ<br/>
                  â€¢ è¨€èªžåˆ¥ã®ã‚­ãƒ£ãƒ‡ã‚£åã§æ¤œç´¢å¯èƒ½<br/>
                  â€¢ è‡ªå‹•è¨€èªžåˆ¤å®š<br/>
                  â€¢ ä¸€æ‹¬è¨€èªžè¨­å®š<br/>
                  <br/>
                  <strong>æ“ä½œæ–¹æ³•:</strong><br/>
                  â€¢ <strong>å·¦ã‚¯ãƒªãƒƒã‚¯</strong>: ãƒ†ã‚£ãƒ¼ã‚¿ã‚¤ãƒ ã®äºˆç´„/ç·¨é›†<br/>
                  â€¢ <strong>å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ Ctrl+ã‚¯ãƒªãƒƒã‚¯</strong>: ã‚¹ãƒ­ãƒƒãƒˆã®ãƒ­ãƒƒã‚¯/è§£é™¤<br/>
                  â€¢ æ¤œç´¢ã¯å¤šè¨€èªžå…¥åŠ›ã«å¯¾å¿œ<br/>
                  â€¢ è¨€èªžåˆ‡æ›¿ã‚’è©¦ã—ã¦ãã ã•ã„ (EN/TH/KO/JA)<br/>
                `
              }
};
            
            return instructions[lang];
          };

          useEffect(() => {
            const intervalMinutes = parseInt(filters.interval?.replace(/\D/g, '') || '10');
            const timeSlots = buildTimes(filters.startTime, filters.endTime, intervalMinutes);

            // Use MciPro data when available, otherwise use demo data
            const activeLanes = MciProBridge.getCourses() || demoLanes;
            const activeCaddies = MciProBridge.getCaddies() || demoCaddies;
            const mciProBookings = MciProBridge.getBookings(filters.date) || [];

            // Create a map of MciPro bookings by time for quick lookup
            const bookingsByTime = new Map();
            mciProBookings.forEach(b => {
              const key = `${b.time}-${b.courseId}`;
              bookingsByTime.set(key, b);
            });

            const initialRows = timeSlots.map(time => ({
              time,
              slots: activeLanes.flatMap(lane =>
                Array.from({length: filters.teesPerCourse}, (_, teeIndex) => {
                  const teeNum = teeIndex + 1;
                  const slotId = `${time}-${lane.courseId}-${teeNum}`;

                  // Get caddies for this specific course when in MciPro mode
                  const courseCaddies = MciProBridge.isInMciPro
                    ? (MciProBridge.getCaddies(lane.courseId) || activeCaddies)
                    : activeCaddies;

                  const slot = {
                    id: slotId,
                    courseId: lane.courseId,
                    time,
                    capacity: 4,
                    players: 0,
                    availableCaddies: courseCaddies,
                    locked: false // Don't randomly lock in production
                  };

                  // Check for MciPro booking at this slot first
                  const mciBookingKey = `${time}-${lane.courseId}`;
                  const mciBooking = bookingsByTime.get(mciBookingKey);
                  if (mciBooking) {
                    slot.booking = mciBooking;
                  } else if (!MciProBridge.isInMciPro) {
                    // Only show demo bookings when not in MciPro mode
                    if (time === '08:30' && lane.courseId === 'course-a' && teeNum === 1) {
                      slot.booking = sampleBookings[0];
                    } else if (time === '09:00' && lane.courseId === 'course-b' && teeNum === 1) {
                      slot.booking = sampleBookings[1];
                    } else if (Math.random() < 0.12) {
                      const languages = ['en', 'th', 'ko'];
                      const randomLang = languages[Math.floor(Math.random() * languages.length)];
                      const randomNames = {
                        en: ['Player', 'Golfer', 'Member'],
                        th: ['à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™', 'à¸™à¸±à¸à¸à¸­à¸¥à¹Œà¸Ÿ', 'à¸ªà¸¡à¸²à¸Šà¸´à¸'],
                        ko: ['í”Œë ˆì´ì–´', 'ê³¨í¼', 'íšŒì›']
                      };

                      const randomBooking = {
                        id: `random-${Math.random()}`,
                        golfers: [
                          {
                            id: 'rg1',
                            name: `${randomNames[randomLang][Math.floor(Math.random() * randomNames[randomLang].length)]} ${Math.floor(Math.random() * 100)}`,
                            handicap: Math.floor(Math.random() * 28),
                            inputLang: randomLang
                          }
                        ],
                        bookingType: ['regular', 'vip', 'society'][Math.floor(Math.random() * 3)],
                        status: 'confirmed',
                        notes: Math.random() < 0.3 ? 'Special requests noted' : undefined,
                        notesLang: randomLang
                      };
                      slot.booking = randomBooking;
                    }
                  }

                  return slot;
                })
              )
            }));

            setDemoRows(initialRows);
          }, [filters.startTime, filters.endTime, filters.interval, filters.teesPerCourse, filters.date]);

          const handleSelectSlot = (slot) => {
            setSelectedSlot(slot);
            setModalOpen(true);
          };

          const handleSaveBooking = async (slot, booking) => {
            if (booking.status === 'cancelled') {
              const syncManager = ScheduleSyncManager.getInstance();
              await syncManager.cancelBooking(booking.id);

              setDemoRows(prevRows =>
                prevRows.map(row => ({
                  ...row,
                  slots: row.slots.map(s =>
                    s.id === slot.id
                      ? { ...s, booking: undefined }
                      : s
                  )
                }))
              );
              return;
            }

            // Save to MciPro when available
            if (MciProBridge.isInMciPro) {
              const result = await MciProBridge.saveBooking(booking, slot);
              if (!result.success) {
                console.error('[TeeSheet] Failed to save booking to MciPro:', result.error);
                alert('Failed to save booking. Please try again.');
                return;
              }
              console.log('[TeeSheet] Booking saved to MciPro:', result.bookingId);

              // Update caddy status if caddies were assigned
              if (booking.caddyBookings?.length > 0) {
                booking.caddyBookings.forEach(cb => {
                  MciProBridge.updateCaddyStatus(cb.caddyId, 'booked');
                });
              }
            }

            setDemoRows(prevRows =>
              prevRows.map(row => ({
                ...row,
                slots: row.slots.map(s =>
                  s.id === slot.id
                    ? { ...s, booking }
                    : s
                )
              }))
            );
          };

          const handleClearDay = () => {
            if (confirm('âš ï¸ Are you sure you want to clear all bookings for this day? This action cannot be undone!')) {
              if (confirm('ðŸš¨ FINAL WARNING: You are about to delete ALL bookings for the entire day. Are you absolutely sure?')) {
                setDemoRows(prevRows => 
                  prevRows.map(row => ({
                    ...row,
                    slots: row.slots.map(slot => ({ ...slot, booking: undefined }))
                  }))
                );
              }
            }
          };

          const handleToggleLock = (slot) => {
            setDemoRows(prevRows => {
              const newRows = prevRows.map(row => ({
                ...row,
                slots: row.slots.map(s => 
                  s.id === slot.id 
                    ? { ...s, locked: !slot.locked }
                    : s
                )
              }));
              return newRows;
            });
          }

          const handleMoveBooking = (fromSlotId, toSlotId) => {
            if (!fromSlotId || !toSlotId || fromSlotId === toSlotId) return;
            setDemoRows(prevRows => {
              let moved = null;
              let destHas = null;
              // Extract booking from source and clear it
              const removed = prevRows.map(row => ({
                ...row,
                slots: row.slots.map(s => {
                  if (s.id === fromSlotId) {
                    moved = s.booking ? { ...s.booking } : null;
                    return { ...s, booking: undefined };
                  }
                  if (s.id === toSlotId) {
                    destHas = s.booking ? { ...s.booking } : null;
                  }
                  return s;
                })
              }));
              if (!moved) return prevRows; // nothing to move
              // Apply booking to destination (swap if needed)
              const applied = removed.map(row => ({
                ...row,
                slots: row.slots.map(s => {
                  if (s.id === toSlotId) {
                    return { ...s, booking: moved };
                  }
                  if (destHas && s.id === fromSlotId) {
                    return { ...s, booking: destHas };
                  }
                  return s;
                })
              }));
              return applied;
            });
          };
;

          // Use MciPro courses when available
          const activeLanes = MciProBridge.getCourses() || demoLanes;
          const totalTees = activeLanes.length * filters.teesPerCourse;

          return React.createElement('div', null,
            // Show MciPro mode indicator
            MciProBridge.isInMciPro && React.createElement('div', {
              style: {
                position: 'fixed',
                top: '10px',
                left: '10px',
                backgroundColor: '#10b981',
                color: 'white',
                padding: '6px 12px',
                borderRadius: '6px',
                fontSize: '0.75rem',
                fontWeight: '600',
                zIndex: 9999,
                boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
              }
            }, 'âœ“ Connected to MciPro'),

            React.createElement(TeeSheet, {
              date: filters.date,
              lanes: activeLanes,
              rows: demoRows,
              filters: filters,
              totalTees: totalTees,
              matches: 0,
              onSelectSlot: handleSelectSlot,
              onClearDay: handleClearDay,
              onLanguageChange: setLanguage,
              onToggleLock: handleToggleLock,
              onMoveBooking: handleMoveBooking,
              onRangeChange: (from, to) => {
                setFilters(prev => ({
                  ...prev,
                  startTime: from,
                  endTime: to
                }));
              }
            }),
            
            React.createElement(BookingModal, {
              isOpen: modalOpen,
              slot: selectedSlot,
              language: language,
              onClose: () => {
                setModalOpen(false);
                setSelectedSlot(null);
              },
              onSaveBooking: handleSaveBooking
            }),
            
            React.createElement('div', {
              style: {
                position: 'fixed',
                bottom: '10px',
                right: '10px',
                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                color: 'white',
                padding: '12px',
                borderRadius: '8px',
                fontSize: '0.7rem',
                maxWidth: '280px',
                zIndex: 9999,
                border: '1px solid rgba(255,255,255,0.1)',
                backdropFilter: 'blur(10px)',
                boxSizing: 'border-box'
              }
            },
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }
              },
                React.createElement('h4', {
                  style: { margin: 0, fontSize: '0.8rem', display: 'flex', alignItems: 'center', gap: '6px' }
                }, `ðŸŒï¸â€â™‚ï¸ ${getInstructionText(language).title}`),
                React.createElement('select', {
                  value: language,
                  onChange: (e) => setLanguage(e.target.value),
                  style: {
                    padding: '2px 4px',
                    fontSize: '0.65rem',
                    backgroundColor: 'rgba(255,255,255,0.1)',
                    color: 'white',
                    border: '1px solid rgba(255,255,255,0.3)',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  }
                },
                  React.createElement('option', { value: 'en', style: { backgroundColor: '#000', color: 'white' } }, 'ðŸ‡ºðŸ‡¸ EN'),
                  React.createElement('option', { value: 'th', style: { backgroundColor: '#000', color: 'white' } }, 'ðŸ‡¹ðŸ‡­ TH'),
                  React.createElement('option', { value: 'ko', style: { backgroundColor: '#000', color: 'white' } }, 'ðŸ‡°ðŸ‡· KO')
                )
              ),
              React.createElement('div', {
                style: { lineHeight: '1.3' },
                dangerouslySetInnerHTML: { __html: getInstructionText(language).content }
              })
            )
          );
        };

        (function() {
  const container = document.getElementById('root');
  const root = ReactDOM.createRoot(container);
  root.render(React.createElement(TeeSheetDemo));
})();
    </script>

<script>
(function(){
  function findScrollContainer() {
    // Find any slot and climb to a vertically scrollable wrapper
    var sample = document.querySelector('[data-slot-id]');
    if (!sample) return null;
    var el = sample.parentElement;
    while (el && !(el.scrollHeight > el.clientHeight + 10)) el = el.parentElement;
    return el;
  }
  function updateGuides() {
    var sample = document.querySelector('[data-slot-id]');
    var scroller = findScrollContainer();
    if (!sample || !scroller) return;
    var h = sample.offsetHeight || 44;
    var color = 'rgba(71,85,105,0.95)'; // slate-600
    scroller.style.backgroundImage =
      'repeating-linear-gradient(to bottom,'+color+' 0,'+color+' 2px, transparent 2px, transparent ' + h + 'px)';
    scroller.style.backgroundOrigin = 'content-box';
    scroller.style.backgroundClip = 'content-box';
    scroller.style.backgroundAttachment = 'local';
  }
  var ready = false;
  function tryInstall(n){
    if (ready) return;
    updateGuides();
    if (document.querySelector('[data-slot-id]')) ready = true;
    if (!ready && n>0) setTimeout(function(){ tryInstall(n-1); }, 250);
  }
  document.addEventListener('DOMContentLoaded', function(){ tryInstall(20); });
  window.addEventListener('load', function(){ tryInstall(10); });
  window.addEventListener('resize', updateGuides);
})();
</script>


<!-- Surgical Tee Sheet â†’ Cockpit Bridge -->
<script>
(function(){
  function pct(n){ return Math.max(0, Math.min(1, n || 0)); }
  function safeLen(x){ try { return (x && x.length) ? x.length : (Array.isArray(x) ? x.length : 0); } catch(e){ return 0; } }
  function round(n,d){ var p = Math.pow(10, d||2); return Math.round((n||0)*p)/p; }

  function computeMetrics(){
    try {
      var mgr = (window.ScheduleSyncManager && window.ScheduleSyncManager.getInstance) ? window.ScheduleSyncManager.getInstance() : null;
      var slots = window.timeSlots || [];
      var lanes = window.demoLanes || [];
      var teesPerCourse = (window.filters && window.filters.teesPerCourse) ? window.filters.teesPerCourse : 1;

      var activeBookings = mgr && mgr.activeBookings ? Array.from(mgr.activeBookings.values()) : [];
      var totalBookings = activeBookings.length;
      var totalCapacity = Math.max(1, safeLen(slots) * Math.max(1, safeLen(lanes)) * Math.max(1, teesPerCourse));

      var utilization = pct(totalBookings / totalCapacity);

      var waitlisted = 0;
      try {
        waitlisted = activeBookings.reduce((acc, b)=>{
          var cbs = (b && b.caddyBookings) ? b.caddyBookings : [];
          return acc + cbs.filter(cb => cb && (cb.isWaitlisted || cb.status === 'waitlisted')).length;
        }, 0);
      } catch(e){ waitlisted = 0; }
      var waitlist_fill = totalBookings ? Math.min(1, waitlisted / totalBookings) : 0;

      var nowTs = Date.now();
      var noShowNumer = 0;
      try {
        noShowNumer = activeBookings.filter(b => {
          var confirmed = (b && (b.isConfirmed || b.confirmed));
          var t = (b && b.time) ? new Date(b.time).getTime() : null;
          return (!confirmed) && t && (t - nowTs) < (60*60*1000) && (t - nowTs) > -(30*60*1000);
        }).length;
      } catch(e){ noShowNumer = 0; }
      var no_show_risk = totalBookings ? round(noShowNumer / totalBookings, 3) : 0;

      var pace_p50 = (window.PACE && window.PACE.p50) || null;
      var pace_p90 = (window.PACE && window.PACE.p90) || null;

      var caddySchedules = (mgr && mgr.caddySchedules) ? mgr.caddySchedules : {};
      var caddyCount = Object.keys(caddySchedules || {}).length;
      var caddyAssigned = 0;
      try {
        caddyAssigned = activeBookings.reduce((acc,b)=> acc + (b.caddyBookings ? b.caddyBookings.length : 0), 0);
      } catch(e){ caddyAssigned = 0; }
      var caddy_utilization = caddyCount ? round(caddyAssigned / caddyCount, 2) : null;

      return {
        ts: new Date().toISOString(),
        rounds_today: totalBookings,
        utilization: round(utilization, 4),
        waitlist_fill: round(waitlist_fill, 4),
        no_show_risk: no_show_risk,
        pace_p50: pace_p50,
        pace_p90: pace_p90,
        caddy_utilization: caddy_utilization,
        capacity_slots: totalCapacity
      };
    } catch(err){
      return {
        ts: new Date().toISOString(),
        rounds_today: 0,
        utilization: 0,
        waitlist_fill: 0,
        no_show_risk: 0,
        capacity_slots: 0,
        error: String(err && err.message || err)
      };
    }
  }

  window.exportTeeSheetMetrics = function(){
    return computeMetrics();
  };
  window.getTeeSheetMetrics = window.exportTeeSheetMetrics;

  function broadcast(){
    var payload = computeMetrics();
    try { window.postMessage({ type: 'TEE_SHEET_METRICS', payload: payload }, '*'); } catch(e){}
    try {
      if (window.DATA){
        window.DATA.rounds_today = payload.rounds_today;
        window.DATA.utilization = payload.utilization;
        window.DATA.waitlist_fill = payload.waitlist_fill;
        window.DATA.no_show_risk = payload.no_show_risk;
        document.dispatchEvent(new CustomEvent('tee-metrics', { detail: payload }));
      }
    } catch(e){}
  }

  var _teeBridgeInterval = setInterval(broadcast, 10000);
  document.addEventListener('visibilitychange', function(){ if (!document.hidden) broadcast(); });
  setTimeout(broadcast, 50);
})();
</script>


<style>
  .send-to-cockpit-btn{
    position:fixed; right:16px; bottom:16px; z-index:9999;
    background:#0ea5e9; color:#fff; border:none; border-radius:999px;
    padding:10px 14px; font-weight:700; box-shadow:0 6px 18px rgba(2,132,199,.3);
    cursor:pointer;
  }
  .send-to-cockpit-btn:hover{ filter:brightness(1.05); }
</style>
<button class="send-to-cockpit-btn" id="btnSendCockpit" title="Send live metrics to GM Cockpit">Send to Cockpit</button>
<script>
(function(){
  function safeExport(){ try { return (window.exportTeeSheetMetrics && window.exportTeeSheetMetrics()) || null; } catch(e){ return null; } }
  var btn = document.getElementById('btnSendCockpit');
  if (btn){
    btn.addEventListener('click', function(){
      var payload = safeExport();
      if (payload){
        try { window.postMessage({ type: 'TEE_SHEET_METRICS', payload: payload }, '*'); } catch(e){}
        try { window.postMessage({ type: 'FOCUS_COCKPIT' }, '*'); } catch(e){}
        try { document.dispatchEvent(new CustomEvent('tee-metrics', { detail: payload })); } catch(e){}
        try { document.dispatchEvent(new CustomEvent('focus-cockpit')); } catch(e){}
      }
    });
  }
})();
</script>

</body>
</html>