
You said:
To utilize agents on a platform to gather content and data off of that page, to put it into an existing module to push out what we call an event card, could the agent do that? So if I have a module, let's just say we'll use, because I'm building a Golf platform, I've got a Golf Society page where the society organizers have schedules that they run daily, Monday through Saturday, and they type it in on an Excel or just have it on a web page, on their web page, we'll use that as a primary. It's on their website because they want to put a calendar out for their members. Can we build an agent to scrape or take all of what's on the web page, their calendar, and put it into the form that we create that gives, obviously, the title of the event, the date, the time, departure time, the cost, and any other information that would be relevant to the event card?
ChatGPT said:

Thought for 12s
Short answer: yes—totally doable. You can build an agent that visits a society’s web page (or calendar feed), extracts the schedule, normalizes it, and outputs your “event card” objects (title, date, time, departure time, cost, notes, etc.). Below is a practical blueprint you can hand to engineering.

What to build
1) Event schema (your “event card”)
Define a single internal schema that every source maps into. Keep it strict and typed.

{
  "id": "string",
  "source_url": "string",
  "title": "string",
  "start_date": "YYYY-MM-DD",
  "start_time": "HH:mm",
  "end_time": "HH:mm|null",
  "departure_time": "HH:mm|null",
  "location_name": "string|null",
  "address": "string|null",
  "cost": "number|null",
  "currency": "string|null",
  "notes": "string|null",
  "organizer": "string|null",
  "last_seen_at": "ISO-8601",
  "raw_text": "string"   // for debugging & re-parsing
}
2) Source adapters (ordered from easiest → hardest)
ICS / iCal (ideal): many sites (including Google Calendar embeds) expose a .ics URL. Parse with an iCal library and map fields directly.

Structured HTML: tables, consistent <div> blocks, or pages with schema.org/Event microdata/JSON-LD.

Semi-structured text: freeform paragraphs like “Mon 10/20 — 8:00 am shotgun at Royal… $45”. Use patterns + date parsing.

JS-rendered pages: use a headless browser to render before parsing.

PDFs or images (if any): OCR fallback (Tesseract), but keep this as last resort.

3) Extraction pipeline
Fetch: Respect robots.txt and caches; set a polite User-Agent.

Render (if needed): Use Playwright/Puppeteer for SPA pages.

Detect format:

If page exposes JSON-LD with @type: "Event", parse that first.

Else, try table/list heuristics.

Else, fall back to regex + LLM-assisted parsing (see below).

Normalize: Map into your event schema; infer missing pieces (e.g., year) with rules.

Deduplicate: Hash on (title, date, time, location) or source event UID for iCal. Maintain a small similarity check (e.g., fuzzy title match within same day).

Validate: Hard checks (date present) and soft checks (time format, cost numeric).

Upsert: Insert/Update in your DB; mark last_seen_at. Soft-delete events not seen for N runs.

Publish: Emit to your “Event Card” module / API.

4) LLM assist (optional but powerful)
For ugly pages, send the raw, cleaned text to an LLM with a strict extraction prompt and JSON schema. Wrap it with:

Guardrails: JSON schema validation; reject if missing required fields.

Confidence thresholds: If fields are low confidence (e.g., cost), keep them null and surface to an admin review queue.

Few-shot examples: Show the model 2–3 examples of the society’s formatting.

5) Scheduling & ops
Cron/Queue: Run every morning (or multiple times/day if needed).

Caching/E-tags: Avoid re-parsing unchanged pages.

Monitoring: Alert if extraction drops to 0 events, or schema validation fails >X times.

Admin UI: Quick manual fix tool (edit an event, remap a selector).

Tech choices (battle-tested)
Language: Python or Node; Python has great parsing libs.

Fetching: requests/httpx (Python) or node-fetch + retry/backoff.

Headless: Playwright.

Parsing:

HTML: BeautifulSoup (Python) or Cheerio (Node).

iCal: ics / icalendar (Python), ical.js (Node).

Dates: dateparser (Python) or luxon (Node).

JSON-LD: find <script type="application/ld+json">.

Storage: Postgres with a unique index for dedupe; include a raw blob column.

Validation: JSON Schema (jsonschema Python).

LLM extraction (optional): call your provider with function/tool schema.

Minimal code sketch (Python-ish)
1) Try ICS first

from icalendar import Calendar
import requests
from datetime import datetime

def events_from_ics(url):
    cal = Calendar.from_ical(requests.get(url, timeout=20).content)
    out = []
    for comp in cal.walk('VEVENT'):
        start = comp.get('dtstart').dt
        end = comp.get('dtend').dt if comp.get('dtend') else None
        out.append({
            "id": comp.get('uid') or f"{url}#{start.isoformat()}",
            "source_url": url,
            "title": str(comp.get('summary') or '').strip(),
            "start_date": start.strftime('%Y-%m-%d'),
            "start_time": start.strftime('%H:%M') if isinstance(start, datetime) else None,
            "end_time": end.strftime('%H:%M') if isinstance(end, datetime) else None,
            "departure_time": None,
            "location_name": str(comp.get('location') or None),
            "address": None,
            "cost": None,
            "currency": None,
            "notes": str(comp.get('description') or None),
            "organizer": str(comp.get('organizer') or None),
            "last_seen_at": datetime.utcnow().isoformat(),
            "raw_text": str(comp.to_ical())
        })
    return out
2) JSON-LD Events

from bs4 import BeautifulSoup
import json, re, requests

def events_from_jsonld(url):
    html = requests.get(url, timeout=20).text
    soup = BeautifulSoup(html, 'html.parser')
    out = []
    for tag in soup.select('script[type="application/ld+json"]'):
        try:
            data = json.loads(tag.string)
            items = data if isinstance(data, list) else [data]
        except Exception:
            continue
        for item in items:
            if (item.get('@type') == 'Event') or ('Event' in item.get('@type', [])):
                start = item.get('startDate', '')
                out.append({
                    "id": item.get('identifier') or f"{url}#{start}#{item.get('name')}",
                    "source_url": url,
                    "title": item.get('name'),
                    "start_date": start[:10] if start else None,
                    "start_time": start[11:16] if len(start) >= 16 else None,
                    "end_time": (item.get('endDate') or '')[11:16] or None,
                    "departure_time": None,
                    "location_name": (item.get('location') or {}).get('name'),
                    "address": (item.get('location') or {}).get('address'),
                    "cost": float(re.sub(r'[^\d.]','', item.get('offers', {}).get('price',''))) if item.get('offers') else None,
                    "currency": item.get('offers', {}).get('priceCurrency'),
                    "notes": item.get('description'),
                    "organizer": (item.get('organizer') or {}).get('name'),
                    "last_seen_at": datetime.utcnow().isoformat(),
                    "raw_text": tag.string[:4000]
                })
    return out
3) Table/List heuristics (simplified)

def events_from_table(url):
    html = requests.get(url, timeout=20).text
    soup = BeautifulSoup(html, 'html.parser')
    rows = soup.select('table tr') or soup.select('.event, li')
    out = []
    for r in rows:
        text = ' '.join(r.stripped_strings)
        # naive patterns: adjust per site
        # e.g., "Mon 10/20 08:00 Shotgun – Royal CC – $45 – depart 06:30"
        # parse with regex + dateparser here, then map to schema
        # ...
    return out
4) LLM fallback

Send the cleaned block text + your JSON schema and require valid JSON.

Validate; reject if not conformant.

Key considerations (so you don’t get burned)
Permissions & legality: Check robots.txt and terms. When in doubt, get written permission from the society.

Stability: HTML changes break scrapers. Prefer ICS/JSON-LD first; pure HTML scrapers should have selectors in config so you can hot-fix without code changes.

Time zones: Decide a canonical timezone (e.g., society’s local TZ) and normalize.

Ambiguity: If the page says “Shotgun 8am” with no date context, infer from the page header but mark low-confidence fields.

Costs: Headless rendering is heavier; cache aggressively. LLM parsing should be rate-limited and only used when rules fail.

Data quality: Add a small “needs review” queue for events missing date/time or with costs that look off (e.g., “$0.00” on a weekend outing).

Change tracking: Keep raw_text and a checksum; if the source row changes, update your event and record a revision.

Ideal integration path
MVP: Support one society page that exposes an ICS or predictable HTML table. Store to Postgres, render your event cards.

Config-driven adapters: For each society, define:

fetch_url, time_zone

priority of parsers: ["ics", "jsonld", "html_table", "llm"]

CSS selectors / regex patterns

Admin tools: One-click fix for a broken field; remap a column; preview the parsed event vs. raw.

Scale-out: Add rate limits, retries, and monitoring; onboard more society sites by adding config, not code.

If you want, I can draft a site-specific adapter template and a JSON schema + validation rules you can drop straight into your codebase.

You said:
Uploaded image
Uploaded image
go to the webpage with their calendar schedule and scrape it into our form and produce the event card
ChatGPT said:
Absolutely—let’s make this concrete. Below is a drop-in pattern you can hand to engineering that:

pulls a society’s schedule from the web (ICS, JSON-LD, or HTML table/list),

normalizes it to your Event Card schema, then

drives your “Create Event” form in a headless browser to publish cards.

I’m showing Node + Playwright for the agent (form fill) and small extractors for the 3 common calendar formats.

1) Canonical “Event Card” schema
Use one strict shape for everything you scrape; every parser maps into this before publishing.

// event.types.ts
export type EventCard = {
  sourceUrl: string
  title: string
  eventDate: string        // 'YYYY-MM-DD'
  departureTime?: string   // 'HH:mm'
  cutoffDate?: string      // 'YYYY-MM-DD'
  cutoffTime?: string      // 'HH:mm'
  course?: string
  format?: string          // 'Stroke Play' | 'Stableford' | ...
  maxPlayers?: number
  fees?: {
    green?: number
    cart?: number
    caddy?: number
    transport?: number
    competition?: number
    currency?: string      // 'THB' default
  }
  notes?: string
}
2) Scrapers (pick best available per site)
2a) ICS / iCal (ideal)
// extractors/ics.ts
import ical from 'ical'
import { DateTime } from 'luxon'
import type { EventCard } from '../event.types'

export async function fromICS(icsUrl: string): Promise<EventCard[]> {
  const res = await fetch(icsUrl, { headers: { 'User-Agent': 'Golf-Agent/1.0' } })
  const text = await res.text()
  const data = ical.parseICS(text)

  const out: EventCard[] = []
  for (const k in data) {
    const ev: any = (data as any)[k]
    if (ev.type !== 'VEVENT') continue
    const start = DateTime.fromJSDate(ev.start)
    const end   = ev.end ? DateTime.fromJSDate(ev.end) : null

    out.push({
      sourceUrl: icsUrl,
      title: (ev.summary || '').trim(),
      eventDate: start.toFormat('yyyy-LL-dd'),
      departureTime: start.isValid ? start.toFormat('HH:mm') : undefined,
      course: ev.location || undefined,
      notes: ev.description || undefined,
      fees: { currency: 'THB' },
    })
  }
  return out
}
2b) JSON-LD (schema.org/Event) on the page
// extractors/jsonld.ts
import { JSDOM } from 'jsdom'
import { DateTime } from 'luxon'
import type { EventCard } from '../event.types'

export async function fromJSONLD(url: string): Promise<EventCard[]> {
  const html = await (await fetch(url)).text()
  const dom = new JSDOM(html)
  const blocks = [...dom.window.document.querySelectorAll('script[type="application/ld+json"]')]
  const out: EventCard[] = []

  for (const b of blocks) {
    try {
      const raw = JSON.parse(b.textContent || 'null')
      const items = Array.isArray(raw) ? raw : [raw]
      for (const it of items) {
        const isEvent = it?.['@type'] === 'Event' || it?.['@type']?.includes?.('Event')
        if (!isEvent) continue
        const start = DateTime.fromISO(it.startDate || '')
        const cutoff = DateTime.fromISO(it.doorTime || it.endDate || '')
        out.push({
          sourceUrl: url,
          title: it.name || '',
          eventDate: start.toFormat('yyyy-LL-dd'),
          departureTime: start.isValid ? start.toFormat('HH:mm') : undefined,
          cutoffDate: cutoff.isValid ? cutoff.toFormat('yyyy-LL-dd') : undefined,
          cutoffTime: cutoff.isValid ? cutoff.toFormat('HH:mm') : undefined,
          course: it.location?.name,
          notes: it.description,
          fees: {
            currency: it.offers?.priceCurrency || 'THB',
            competition: it.offers?.price ? Number(String(it.offers.price).replace(/[^\d.]/g,'')) : undefined
          }
        })
      }
    } catch {}
  }
  return out
}
2c) HTML table/list (config-driven selectors)
// extractors/html.ts
import { JSDOM } from 'jsdom'
import { DateTime } from 'luxon'
import type { EventCard } from '../event.types'

type Selectors = {
  row: string                // e.g. 'table.schedule tr' or '.event-row'
  title: string              // relative to row, e.g. '.title'
  date: string               // e.g. '.date' -> '10/10/2025'
  time?: string              // e.g. '.time'  -> '6:30 AM'
  course?: string
  fee?: string               // e.g. '.fee'   -> 'Green 2100, Cart 600...'
  notes?: string
}

export async function fromHTML(url: string, s: Selectors): Promise<EventCard[]> {
  const html = await (await fetch(url)).text()
  const dom = new JSDOM(html)
  const doc = dom.window.document
  const rows = [...doc.querySelectorAll(s.row)]
  const out: EventCard[] = []

  for (const r of rows) {
    const title = r.querySelector(s.title)?.textContent?.trim() || ''
    const dateTxt = r.querySelector(s.date)?.textContent?.trim() || ''
    const timeTxt = s.time ? r.querySelector(s.time)?.textContent?.trim() || '' : ''
    const dt = DateTime.fromFormat(dateTxt, 'M/d/yyyy', { zone: 'local' })

    const depart = DateTime.fromFormat(timeTxt, 'h:mm a', { zone: 'local' })
    const notes = s.notes ? r.querySelector(s.notes)?.textContent?.trim() : undefined

    // naive fee parsing; customize per site
    const feeTxt = s.fee ? r.querySelector(s.fee)?.textContent || '' : ''
    const pick = (label: string) => {
      const m = new RegExp(`${label}\\s*[:=]?\\s*฿?\\s*([\\d,.]+)`, 'i').exec(feeTxt)
      return m ? Number(m[1].replace(/[,]/g,'')) : undefined
    }

    out.push({
      sourceUrl: url,
      title,
      eventDate: dt.isValid ? dt.toFormat('yyyy-LL-dd') : '',
      departureTime: depart.isValid ? depart.toFormat('HH:mm') : undefined,
      course: s.course ? r.querySelector(s.course)?.textContent?.trim() : undefined,
      notes,
      fees: {
        currency: 'THB',
        green: pick('Green'),
        cart: pick('Cart'),
        caddy: pick('Caddy|Caddie'),
        transport: pick('Transport'),
        competition: pick('Comp|Competition'),
      }
    })
  }
  return out
}
3) Agent: fill your form and publish the card (Playwright)
Tip: add stable attributes to your form (e.g., data-testid="event-date").
Below I use getByLabel/getByPlaceholder that match your screenshot placeholders.

// agent/publish.ts
import { chromium, expect } from '@playwright/test'
import { DateTime } from 'luxon'
import type { EventCard } from '../event.types'

export async function publishEvents(
  events: EventCard[],
  opts: { adminUrl: string; username: string; password: string }
) {
  const browser = await chromium.launch({ headless: true })
  const ctx = await browser.newContext()
  const page = await ctx.newPage()

  // 1) Login (adjust selectors)
  await page.goto(opts.adminUrl)
  await page.getByLabel(/email|username/i).fill(opts.username)
  await page.getByLabel(/password/i).fill(opts.password)
  await page.getByRole('button', { name: /sign in|log in/i }).click()

  for (const ev of events) {
    // 2) Open “Create Event”
    await page.getByRole('button', { name: /new event|create event/i }).click()

    // 3) Fill the form
    await page.getByPlaceholder(/e\.g\., Monthly Medal/i).fill(ev.title)

    // Event Date
    await page.getByLabel(/Event Date/i).fill(
      DateTime.fromISO(ev.eventDate).toFormat('MM/dd/yyyy')
    )

    // Departure Time
    if (ev.departureTime) {
      await page.getByLabel(/Departure Time/i).fill(
        DateTime.fromFormat(ev.departureTime, 'HH:mm').toFormat('hh:mm a')
      )
    }

    // Registration Cutoff (optional)
    if (ev.cutoffDate) {
      await page.getByLabel(/Registration Cutoff/i).fill(
        DateTime.fromISO(ev.cutoffDate).toFormat('MM/dd/yyyy') +
        (ev.cutoffTime ? ` ${DateTime.fromFormat(ev.cutoffTime,'HH:mm').toFormat('hh:mm a')}` : '')
      )
    }

    if (ev.course) await page.getByPlaceholder(/e\.g\., Phuket Country Club/i).fill(ev.course)
    if (ev.format) await page.getByRole('combobox', { name: /Event Format/i }).selectOption({ label: ev.format })
    if (ev.maxPlayers) await page.getByLabel(/Max Players/i).fill(String(ev.maxPlayers))

    // Fees (THB)
    const fee = ev.fees || {}
    await page.getByLabel(/Green Fee/i).fill(String(fee.green ?? 0))
    await page.getByLabel(/Cart Fee/i).fill(String(fee.cart ?? 0))
    await page.getByLabel(/Caddy Fee/i).fill(String(fee.caddy ?? 0))
    await page.getByLabel(/Transport Fee/i).fill(String(fee.transport ?? 0))
    await page.getByLabel(/Competition Fee/i).fill(String(fee.competition ?? 0))

    if (ev.notes) await page.getByLabel(/Notes/i).fill(ev.notes)

    // Enable auto waitlist (if you want it on by default)
    const auto = page.getByLabel(/Enable Auto Waitlist/i)
    if (await auto.isVisible()) {
      const checked = await auto.isChecked()
      if (!checked) await auto.check()
    }

    // 4) Submit and optionally capture the card URL
    await page.getByRole('button', { name: /Create|Save/i }).click()
    // Wait for the card page and copy URL
    await page.waitForURL(/\/events\/\w+/)
    const cardUrl = page.url()
    console.log(`Published: ${ev.title} → ${cardUrl}`)
  }

  await browser.close()
}
4) Putting it together (choose 1+ extractor, then publish)
// run.ts
import { fromICS } from './extractors/ics'
import { fromJSONLD } from './extractors/jsonld'
import { fromHTML } from './extractors/html'
import { publishEvents } from './agent/publish'

async function main() {
  // Pick whichever applies to the society you’re onboarding:
  const events =
    (await fromICS('https://example.com/society.ics'))          // try ICS
    .concat(await fromJSONLD('https://example.com/schedule'))    // also parse JSON-LD if present
    .concat(await fromHTML('https://example.com/schedule', {     // or configured HTML selectors
      row: 'table.schedule tr',
      title: '.title',
      date: '.date',
      time: '.time',
      course: '.course',
      fee: '.fees',
      notes: '.notes'
    }))

  // Optional: dedupe by (title + date + time)
  const uniqKey = (e: any) => [e.title, e.eventDate, e.departureTime ?? ''].join('|')
  const unique = Object.values(Object.fromEntries(events.map(e => [uniqKey(e), e])))

  await publishEvents(unique, {
    adminUrl: 'https://your-admin.example.com/login',
    username: process.env.ADMIN_USER!,
    password: process.env.ADMIN_PASS!
  })
}

main().catch(err => { console.error(err); process.exit(1) })
5) Practical notes (so this stays robust)
Prefer feeds over scraping: If the society can expose a .ics link (easy from Google Calendar), use that. It’s stable and won’t break on HTML changes.

Config, not code: Keep per-site CSS selectors and date/time formats in config files. No redeploys for new societies.

Time zones: Normalize to the society’s local TZ and convert to your UI format at render.

Validation: Before submission, hard-check required fields (title, date). If fees are missing, fill 0 and show the currency (“THB”) like your card.

UI stability: If possible, add data-testid to your form fields. That makes the Playwright selectors bulletproof.

Compliance: Respect robots.txt / terms. When in doubt, get written permission to fetch schedules.

If you share one society URL (or a snippet of its calendar HTML), I’ll tailor the extractor config and give you a ready-to-run fromHTML(...) with accurate date/time/fee parsing for that page.

You said:
https://trggpattaya.com/schedule/
ChatGPT said:

Thought for 49s
Nice—thanks for the URL. I tried fetching it directly and the site returns HTTP 406 (“Not Acceptable”) to non-browser clients, which is common bot protection. That’s fine: we’ll run the agent with a real browser (Playwright) + a standard desktop User-Agent, then parse the page DOM.

Below is a drop-in, site-specific adapter you can paste into the blueprint I shared earlier. It 1) loads the page with Playwright, 2) tries three structured paths (JSON-LD, “The Events Calendar”/WordPress classes, generic tables/lists), 3) falls back to regex on text, and 4) returns your normalized EventCard[]. You can pass its results straight into the publishEvents(...) function from my previous message.

TRGG Pattaya – extractor
// extractors/trgg.ts
import { chromium } from 'playwright'
import { DateTime } from 'luxon'
import type { EventCard } from '../event.types'

/**
 * Loads https://trggpattaya.com/schedule/ with a real browser UA (the site 406s generic bots),
 * extracts events via multiple strategies, and normalizes to EventCard[].
 */
export async function fromTRGG(url = 'https://trggpattaya.com/schedule/'): Promise<EventCard[]> {
  const browser = await chromium.launch({ headless: true })
  const ctx = await browser.newContext({
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36',
    javaScriptEnabled: true
  })
  const page = await ctx.newPage()
  await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 })
  await page.waitForLoadState('networkidle').catch(() => {})

  // Strategy A: JSON-LD Events (schema.org)
  const jsonld = await page.$$eval('script[type="application/ld+json"]', nodes => {
    const out: any[] = []
    for (const n of nodes) {
      try {
        const j = JSON.parse(n.textContent || 'null')
        const items = Array.isArray(j) ? j : [j]
        for (const it of items) out.push(it)
      } catch {}
    }
    return out
  })

  const cardsA: EventCard[] = []
  for (const it of jsonld) {
    const isEvent =
      it?.['@type'] === 'Event' || (Array.isArray(it?.['@type']) && it['@type'].includes('Event'))
    if (!isEvent) continue
    const start = DateTime.fromISO(it.startDate || '')
    const cutoff = DateTime.fromISO(it.doorTime || it.endDate || '')
    cardsA.push({
      sourceUrl: url,
      title: (it.name || '').trim(),
      eventDate: start.isValid ? start.toFormat('yyyy-LL-dd') : '',
      departureTime: start.isValid ? start.toFormat('HH:mm') : undefined,
      cutoffDate: cutoff.isValid ? cutoff.toFormat('yyyy-LL-dd') : undefined,
      cutoffTime: cutoff.isValid ? cutoff.toFormat('HH:mm') : undefined,
      course: it.location?.name,
      notes: it.description,
      fees: {
        currency: it.offers?.priceCurrency || 'THB',
        competition: Number(String(it.offers?.price || '').replace(/[^\d.]/g, '')) || undefined
      }
    })
  }

  // Strategy B: WordPress / The Events Calendar patterns (common class names)
  // If TRGG uses TEC or a similar plugin, these selectors often work out of the box.
  const cardsB = await page.evaluate(() => {
    const qs = (sel: string, el: Element | Document = document) =>
      Array.from(el.querySelectorAll(sel)) as HTMLElement[]

    const rows =
      qs('.tribe-events-calendar-list__event') // TEC v6 list view
        .concat(qs('.tribe-events-calendar-month__calendar-event')) // month grid events
        .concat(qs('.event, .events-list li, table tr')) // generic fallbacks
    const out: any[] = []

    for (const r of rows) {
      const pick = (sels: string[]) =>
        sels.map(s => r.querySelector<HTMLElement>(s)?.innerText?.trim()).find(Boolean)

      const title =
        pick([
          '.tribe-events-calendar-list__event-title a',
          '.tribe-events-calendar-list__event-title',
          '.tribe-events-calendar-month__calendar-event-title a',
          '.title',
          'a',
          'strong'
        ]) || ''

      const dateText =
        pick([
          'time[datetime]',
          '.tribe-event-date-start',
          '.date',
          '.tribe-events-calendar-list__event-datetime',
          '.tribe-common-b2'
        ]) || ''

      const timeText =
        pick(['.time', '.tribe-events-calendar-list__event-datetime-time', '.tribe-event-time']) ||
        ''

      const course = pick(['.venue, .course, .tribe-events-venue__name'.split(',').join(',')])
      const feeText = pick(['.fees', '.price', '.cost'])

      out.push({ title, dateText, timeText, course, feeText, blockText: r.innerText })
    }
    // de-duplicate naive
    const seen = new Set<string>()
    return out.filter(e => {
      const key = `${e.title}|${e.dateText}|${e.timeText}`
      if (seen.has(key)) return false
      seen.add(key)
      return e.title
    })
  })

  const parseMoney = (s?: string) => {
    if (!s) return undefined
    const m = (label: RegExp) => {
      const mm = new RegExp(`${label.source}\\s*[:=]?\\s*(?:฿|THB)?\\s*([\\d,.]+)`, 'i').exec(s)
      return mm ? Number(mm[1].replace(/,/g, '')) : undefined
    }
    return {
      green: m(/green|gf/),
      cart: m(/cart|buggy/),
      caddy: m(/cadd?y/),
      transport: m(/transport|bus|van/),
      competition: m(/comp|competition|pot/)
    }
  }

  const toISODate = (txt: string) => {
    // Handles formats like "10/10/2025" or "Fri 10 Oct 2025"
    const tryFormats = ['M/d/yyyy', 'd/M/yyyy', 'ccc d LLL yyyy', 'd LLL yyyy', 'LLL d, yyyy']
    for (const f of tryFormats) {
      const dt = DateTime.fromFormat(txt, f)
      if (dt.isValid) return dt.toFormat('yyyy-LL-dd')
    }
    const iso = DateTime.fromISO(txt)
    return iso.isValid ? iso.toFormat('yyyy-LL-dd') : ''
  }

  const toHHmm = (txt: string) => {
    const tryFormats = ['h:mm a', 'H:mm', 'ha', 'h a']
    for (const f of tryFormats) {
      const t = DateTime.fromFormat(txt.replace(/\./g, ':'), f)
      if (t.isValid) return t.toFormat('HH:mm')
    }
    return undefined
  }

  const cardsBnorm: EventCard[] = cardsB
    .map((e: any) => ({
      sourceUrl: url,
      title: e.title,
      eventDate: toISODate(e.dateText || e.blockText || ''),
      departureTime: toHHmm(e.timeText || e.blockText || ''),
      course: e.course,
      fees: { currency: 'THB', ...parseMoney(e.feeText || e.blockText) },
      notes: undefined
    }))
    .filter(e => e.title && e.eventDate)

  // Strategy C: pure text fallback (regex sweep over main content)
  const pageText = (await page.textContent('main, body')) || ''
  const lines = pageText.split('\n').map(s => s.trim()).filter(Boolean)
  const cardsC: EventCard[] = []
  for (const line of lines) {
    // Example pattern: "Fri 10/10/2025 6:30 AM – Burapha – Green 2100 / Cart 600 / Caddy 400 / Comp 250"
    const m =
      /(Mon|Tue|Wed|Thu|Fri|Sat|Sun)?\s*([0-9]{1,2}[\/\-][0-9]{1,2}[\/\-][0-9]{2,4}).{0,20}?([0-9]{1,2}:[0-9]{2}\s*[ap]m)/i.exec(
        line
      )
    if (!m) continue
    const eventDate = toISODate(m[2])
    const departureTime = toHHmm(m[3])
    const title = line.replace(m[0], '').split('–').map(s => s.trim()).filter(Boolean)[0] || 'Golf'
    const fees = {
      currency: 'THB',
      green: Number((/green[^0-9]*([0-9,]+)/i.exec(line)?.[1] || '').replace(/,/g, '')) || undefined,
      cart: Number((/cart[^0-9]*([0-9,]+)/i.exec(line)?.[1] || '').replace(/,/g, '')) || undefined,
      caddy:
        Number((/cadd?y[^0-9]*([0-9,]+)/i.exec(line)?.[1] || '').replace(/,/g, '')) || undefined,
      transport:
        Number((/transport[^0-9]*([0-9,]+)/i.exec(line)?.[1] || '').replace(/,/g, '')) ||
        undefined,
      competition:
        Number((/(comp|competition)[^0-9]*([0-9,]+)/i.exec(line)?.[2] || '').replace(/,/g, '')) ||
        undefined
    }
    cardsC.push({ sourceUrl: url, title, eventDate, departureTime, fees })
  }

  await browser.close()

  // Merge & de-dupe by (title|date|time)
  const all = [...cardsA, ...cardsBnorm, ...cardsC].filter(e => !!e.title && !!e.eventDate)
  const map = new Map<string, EventCard>()
  for (const ev of all) {
    const key = [ev.title.toLowerCase(), ev.eventDate, ev.departureTime || ''].join('|')
    if (!map.has(key)) map.set(key, ev)
  }
  return [...map.values()]
}
How to run it end-to-end
Add this extractor to your repo alongside the earlier publishEvents(...).

Call it, then pass the results into the publisher:

import { fromTRGG } from './extractors/trgg'
import { publishEvents } from './agent/publish'

const events = await fromTRGG('https://trggpattaya.com/schedule/')
await publishEvents(events, {
  adminUrl: process.env.ADMIN_URL!,
  username: process.env.ADMIN_USER!,
  password: process.env.ADMIN_PASS!
})
Notes specific to this site
Bot block (406): solved by Playwright + real UA (already in code). If it still refuses intermittently, add a small await page.waitForTimeout(500-1500) jitter and retry logic.

If they use The Events Calendar: your adapter will capture events via the tribe-* selectors and/or JSON-LD. Many TEC sites also expose an ICS feed (often at /events/?ical=1). If TRGG exposes one, switch to the ICS extractor for near-zero maintenance.

Currency & fees: your card shows THB with line-item fees; the regex in the adapter maps common labels (“Green/Cart/Caddy/Transport/Competition”). Tweak the labels if TRGG uses different phrasing.

Time zone: if TRGG’s times are local to Pattaya, set a fixed zone (e.g., Asia/Bangkok) in the Luxon calls when formatting/parsing.

If you want, give me a single row of the HTML (or a copy/paste text block from one schedule entry) and I’ll tighten the selectors/regex so it’s 100% aligned with their exact markup.