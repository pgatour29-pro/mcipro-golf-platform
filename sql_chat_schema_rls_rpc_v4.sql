-- mcipro chat fix pack v4
-- Schema + RLS + RPC (SECURITY DEFINER) for direct messages
-- Safe to re-run; uses IF NOT EXISTS where possible.

create extension if not exists pgcrypto;
create extension if not exists "uuid-ossp";

-- 1) Tables
create table if not exists public.rooms (
  id uuid primary key default gen_random_uuid(),
  kind text not null check (kind in ('dm','group')),
  slug text not null unique,
  created_at timestamptz not null default now()
);

create table if not exists public.conversation_participants (
  room_id uuid not null references public.rooms(id) on delete cascade,
  user_id uuid not null,
  joined_at timestamptz not null default now(),
  primary key(room_id, user_id)
);

create table if not exists public.chat_messages (
  id bigint generated by default as identity primary key,
  room_id uuid not null references public.rooms(id) on delete cascade,
  author_id uuid not null,
  content text not null check (length(content) > 0),
  created_at timestamptz not null default now()
);

-- 2) Helpful indexes
create index if not exists idx_conversation_participants_user on public.conversation_participants(user_id);
create index if not exists idx_chat_messages_room_time on public.chat_messages(room_id, created_at desc);

-- 3) RLS
alter table public.rooms enable row level security;
alter table public.conversation_participants enable row level security;
alter table public.chat_messages enable row level security;

-- Rooms: only members can see. No direct inserts from clients.
drop policy if exists rooms_select_if_member on public.rooms;
create policy rooms_select_if_member
  on public.rooms
  for select
  using (exists (
    select 1 from public.conversation_participants cp
    where cp.room_id = public.rooms.id
      and cp.user_id = auth.uid()
  ));

-- Conversation participants: members can see membership of their rooms.
drop policy if exists participants_select_if_member on public.conversation_participants;
create policy participants_select_if_member
  on public.conversation_participants
  for select
  using (exists (
    select 1 from public.conversation_participants cp2
    where cp2.room_id = public.conversation_participants.room_id
      and cp2.user_id = auth.uid()
  ));

-- Chat messages: members can read; only authors who are members can insert.
drop policy if exists messages_select_if_member on public.chat_messages;
create policy messages_select_if_member
  on public.chat_messages
  for select
  using (exists (
    select 1 from public.conversation_participants cp
    where cp.room_id = public.chat_messages.room_id
      and cp.user_id = auth.uid()
  ));

drop policy if exists messages_insert_if_author_member on public.chat_messages;
create policy messages_insert_if_author_member
  on public.chat_messages
  for insert
  with check (
    auth.uid() = author_id and exists (
      select 1 from public.conversation_participants cp
      where cp.room_id = public.chat_messages.room_id
        and cp.user_id = auth.uid()
    )
  );

-- 4) RPC for DM creation/open with fully qualified columns to avoid "slug is ambiguous"
drop function if exists public.ensure_direct_conversation(uuid);
create or replace function public.ensure_direct_conversation(partner uuid)
returns table (room_id uuid, room_slug text)
language plpgsql
security definer
set search_path = public
as $$
declare
  me uuid := auth.uid();
  s text;
  rid uuid;
begin
  if me is null then
    raise exception 'auth.uid() is null';
  end if;

  if partner is null then
    raise exception 'partner is null';
  end if;

  -- canonical slug order
  if me < partner then
    s := 'dm:' || me || ':' || partner;
  else
    s := 'dm:' || partner || ':' || me;
  end if;

  -- find room by slug (fully qualified to avoid ambiguity)
  select r.id
    into rid
  from public.rooms r
  where r.kind = 'dm' and r.slug = s
  limit 1;

  if rid is null then
    insert into public.rooms(id, kind, slug)
    values (gen_random_uuid(), 'dm', s)
    returning public.rooms.id into rid;

    insert into public.conversation_participants(room_id, user_id)
    values (rid, me), (rid, partner)
    on conflict do nothing;
  end if;

  return query select rid as room_id, s as room_slug;
end;
$$;

revoke all on function public.ensure_direct_conversation(uuid) from public;
grant execute on function public.ensure_direct_conversation(uuid) to authenticated;

-- 5) (Optional) Helper view for UI debugging
drop view if exists public.my_dm_rooms;
create view public.my_dm_rooms as
  select r.id as room_id, r.slug, r.created_at
  from public.rooms r
  where exists (
    select 1 from public.conversation_participants cp
    where cp.room_id = r.id and cp.user_id = auth.uid()
  );
